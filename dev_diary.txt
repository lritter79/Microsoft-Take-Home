Jun/27
-Scaffold porject with npm create vite@latest
-Enable Github copilot
-Watch some videos about the postgresql explain analyze command and try to understand it better
-Implement bullet proof react file structure, see https://github.com/alan2207/bulletproof-react/blob/master/docs/project-structure.md 
- Asked ChatGPT "Create a simple UI in react with a text area to paste in a string and a button to submit the string in the text area for validation. Ask me 5 clarifying questions before writing the components"
- follow ups 
    --"Not yet, could you make it so that after the user submits an improperly formatted, they see the error message, and start typing or do control x to clear the text area that the error message is no longer displayed?"
    --"1. JSON format validation
2. For more context the string should be the output of a a EXPLAIN ANALYZE command on a given postgresql query. After the string is validated there will be a visualization of the output in order to make it clearer to the user what that explain statement means. So, there will be an output area that is to be determined as far as specifics go. 
3. Only on a submit 
4. Definitely no store like Redux, maybe an external state, since another componet will need to rely on the parsed text
5. Plain CSS, maybe even CSS modules"

Jun/28
-Spent day studying what the output of EXPLAIN ANALYZE does
-Idea for visualization is a tree structure with a leaves from a root node, since the JSON is a tree structure
-Found a SQL sandbox https://onecompiler.com/postgresql/43p6erts3, used it to make some dummy data for testing
-Learned that the "triggers" property on the json is for db triggers that run on a given SQL script in the EXPLAIN statement
-Watched this lecture to understnad what the command does:https://www.youtube.com/watch?v=Kdjz2e8HYPU&t=4s&ab_channel=PostgresConfSouthAfrica
notes
EXPLAIN ANALYZE executes a SQL statmeent and returns query plan 
THe is what SQ
index only scan like index scan, but they get all their column infomation from that indexL did under the hood
This visualizer is really good https://tatiyants.com/pev/#/plans 
Postgres build a tree strucutre nodes representing actions taken
scans are the moethods postgees uses to soft through and access data being reuqsted
sequential scan iterates through table 1 row at a time, most common basic scan 
Index scan only reads portion of data relevant to query
Bitmap index scan combines indexes uses 1st index to locate rows that satisfy 1st filter then next to satisfy 2nd and so on

Bit map heap scan fetches rows from the table in the physical orde they are in
used when we would read too much for index scan, to little for sequential
down side is sequential order in on disk so you lose sorting
Nested loop iterated through all entries in table 1 and table 2, and so on
Hash joins creare hash table in memory with filtered table results

Merge joins are like hash join but dont fit into memory
sorts
external merge sort used when the data does not fit into memory, fastest sort moethods
qucick sort used for in memory sorting 
heap sort mainstains a head iwth a bounded size the swallows the input vlaues in sequence and sorts where it fits into the heap
Times 
estimated time a caculated use database statistics
time of upper level node inclused the times of of all its child nodes
NB the cost does not consider time spent transmitting result rows to the client 

width of a row is the sum of all the bytes of all the columns

Jun 29
Got chatgpt to write webscraper to get definitions for operations and definitions for all fields on an operation as returned
Used scraper to populate a record type with descriptions for later
used copilot to revise validation for textarea input
Found react flow for creating tree diagram: https://reactflow.dev/learn/customization/custom-nodes
Used Chaptgpt to make function for generating nodes and edges from plan nodes to use for the diagram
To dos 
Add more testing, used chatgpt for some 
Add tooltips to show all the extra infor per node
Consider showing more info in label
See docs for tooltips https://reactflow.dev/learn/tutorials/getting-started-with-react-flow-components#adding-your-first-components
Prompts used: "Make a simple tooltip react component that takes in a string as a parameter and shows a circled question mark that shows the string on hover. Ask me 5 clarifying questions before coding it out"
"consider the following styles: ".node {
  min-height: 50px;
  border: 1px solid #eee;
  padding: 5px;
  border-radius: 5px;
  background: white;
}
 
.node a {
  display: block;
  color: #777;
  font-size: 12px;
}" add styling for a hover effect and a class called "selected""
"consider the following TS objects: "  const nodes = [
    {
      id: "1",
      data: { label: "Hello" },
      position: { x: 0, y: 0 },
      type: "input",
    },
    {
      id: "2",
      data: { label: "World" },
      position: { x: -100, y: 100 },
    },
    {
      id: "3",
      data: { label: "World" },
      position: { x: -250, y: 200 },
    },
    {
      id: "4",
      data: { label: "World" },
      position: { x: -100, y: 200 },
    },
  ];

  const edges = [
    { id: "1-2", source: "1", target: "2" },
    { id: "2-3", source: "2", target: "3" },
    { id: "2-4", source: "2", target: "4" },
  ];"

Now conisder the following json for a SQL EXPLAIN ANALYZE plan: "[
  {
    "Plan": {
      "Node Type": "Sort",
      "Parallel Aware": false,
      "Async Capable": false,
      "Startup Cost": 32.11,
      "Total Cost": 32.82,
      "Plan Rows": 283,
      "Plan Width": 68,
      "Actual Startup Time": 0.037,
      "Actual Total Time": 0.041,
      "Actual Rows": 2,
      "Actual Loops": 1,
      "Sort Key": ["dept", "name"],
      "Sort Method": "quicksort",
      "Sort Space Used": 25,
      "Sort Space Type": "Memory",
      "Plans": [
        {
          "Node Type": "Bitmap Heap Scan",
          "Parent Relationship": "Outer",
          "Parallel Aware": false,
          "Async Capable": false,
          "Relation Name": "employee",
          "Alias": "employee",
          "Startup Cost": 6.34,
          "Total Cost": 20.59,
          "Plan Rows": 283,
          "Plan Width": 68,
          "Actual Startup Time": 0.008,
          "Actual Total Time": 0.011,
          "Actual Rows": 2,
          "Actual Loops": 1,
          "Recheck Cond": "(empid > 1)",
          "Rows Removed by Index Recheck": 0,
          "Filter": "(name ~~ '%a%'::text)",
          "Rows Removed by Filter": 0,
          "Exact Heap Blocks": 1,
          "Lossy Heap Blocks": 0,
          "Plans": [
            {
              "Node Type": "Bitmap Index Scan",
              "Parent Relationship": "Outer",
              "Parallel Aware": false,
              "Async Capable": false,
              "Index Name": "employee_pkey",
              "Startup Cost": 0.0,
              "Total Cost": 6.27,
              "Plan Rows": 283,
              "Plan Width": 0,
              "Actual Startup Time": 0.002,
              "Actual Total Time": 0.003,
              "Actual Rows": 2,
              "Actual Loops": 1,
              "Index Cond": "(empid > 1)"
            }
          ]
        }
      ]
    },
    "Planning Time": 0.997,
    "Triggers": [],
    "Execution Time": 0.064
  }
]" Write a function that takes the plan and its child nodes and returns edges and nodes similar to the ts objects from before. ask my 5 questions before writing the fxn"
"Write a component that takes in an array of the following b=object and displays the data by the keys in a logical way: "/**
 * This type represents a trigger in a PostgreSQL query plan.
 * A trigger is an event that occurs in the database, such as a row being inserted,
 * updated, or deleted. It includes the name of the trigger, the relation it is associated
 * with, the time it was triggered, and the number of calls made to it.
 * Triggers can be used to perform actions automatically in response to certain events,
 * such as logging changes, enforcing constraints, or updating related data.
 */
export type Trigger = {
  "Trigger Name": string;
  Relation: string;
  Time: number;
  Calls: number;
};"
Design decisions: 

I decided to use a tree strucutre because 1. exisitng postgres visualizer tools did the same and 2. The plan follows a tree structure with nodes that branch off and have leaves and it seemed like a logical choice. Instead of trying to code a tree diagram from scratch, I searched for existing visualization libraries for that use case. React Flow was by far the best and it had excellent documentation so I chose it to represent to the Query Plan. I decided to make the webscraper to fetch the copy text describing what the operation were actually doing, and what the data returned on each node meant because I thought it would contribute to the user understanding what the plan means in plain english. To me, a series of toolbars and tooltips was the best way to convey the information on demand without crowding the UI. 