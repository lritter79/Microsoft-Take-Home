import type { Operation } from "../types/operation";

// Auto-generated from pgMustard scraper
export const pgMustardFields: Record<
  Operation,
  Record<string, string>
> = {
  "Seq Scan": {
    "Parent Relationship":
      "A guide as to why this operation needs to be run in order to facilitate the parent operation. There are six different possibilities:\nOuter\n: The value you’ll see most often. It means “take in the rows from this operation as input, process them and pass them on”.\nInner\n: Only ever seen on the second child of join operations, and is always seen there. This is the “inner” part of the loop — for each outer row, we look up its match using this operation.\nMember\n: Used for all children of Append and ModifyTable nodes, and on bitmap processing nodes like BitmapAnd and BitmapOr operations.\nInitPlan\n: Used for calculations performed before the query can start, eg a constant referred to in the query or the result of a CTE scan.\nSubquery\n: The child is a subquery of the parent operation. Since Postgres always uses subquery scans to feed subquery data to parent queries, only ever appears on the children of subquery scans.\nSubPlan\n: Like a Subquery, represents a new query, but used when a subquery scan is not necessary.",
    "Parallel Aware":
      "Whether or not the operation will be run in a special mode to support parallelism. Some operations need to be aware that they are running in parallel, for example sequential scans need to know they only need to scan a smaller proportion of the table. Other operations can be run on several threads without each one having any knowledge of the others.",
    "Relation Name":
      "The data source being read/written from. Normally a table name (including when the data is accessed via an index), but can also be a materialised view or foreign data source.",
    Schema:
      "The schema of the “Relation Name” object.\nThis is only shown when VERBOSE is on.",
    Alias: "The alias used to refer to the Relation Name object.",
    "Startup Cost":
      "The estimated cost of returning the first row.\nThis is in an arbitrary unit, with the aim of being correlated to the startup time.",
    "Total Cost":
      "The estimated cost of returning all rows. This is in an arbitrary unit, with the aim of being correlated to the total time.\nThe Postgres query planner often has several ways it could resolve the same query. It calculates costs — which are hopefully correlated with the time it would take — for potential plans, and then picks the one with the lowest cost. It’s worth bearing in mind that the costs are unit-free — they’re not designed to convert into time, or disk reads. They’re just supposed to be bigger for slower operations, and smaller for faster ones.\nIf the planner thinks it can finish early due to a parent Limit operation, the total cost of the Limit operation will reflect this, but the total cost of its child operations will not.",
    "Plan Rows":
      "The number of rows,\nper-loop\n, that the planner expects to be returned by the operation.\nPoor row estimates can lead to suboptimal query planning. They can often be improved by running\nANALYZE\n(not the EXPLAIN parameter), by increasing statistics, or by allowing Postgres to understand correlation between columns using multivariate statistics.\nIf the planner thinks it can finish early due to a Limit operation, the plan rows of the Limit operation will reflect this, but the plan rows of its child operations will not.",
    "Plan Width":
      "The\nestimated\naverage size of the rows produced by the operation, in\nbytes\n.",
    "Actual Startup Time":
      "The amount of time, in\nmilliseconds\n, it takes to get the first row out of the operation.\nSometimes, this is very close to the setup time — for example on a sequential scan which returns all the rows in a table.\nOther times, though, it’s more or less the total time. For example, in order to return the first row of a sort, you have to sort all of the rows to work out which one comes first.",
    "Actual Total Time":
      "The actual amount of time in milliseconds spent on this operation\nand all of its children\n. It’s a\nper-loop average\n, rounded to the nearest thousandth of a millisecond.\nWorking out individual operation timings, especially where CTEs and SubPlans are concerned, can be tricky. This is one of the main reasons we decided to build\npgMustard\n.",
    "Actual Rows":
      "The number of rows returned by the operation\nper loop\n.\nThe important thing to notice about this is that it’s an average of all the loops executed, rounded to the nearest integer. This means that while “Actual Loops” multiplied by “Actual Rows” is a pretty good approximation for total number of rows returned most of the time, it can be off by as much as half of the number of loops. Usually it’s just slightly confusing as you see a row or two appear or disappear between operations, but on operations with lots of loops there is potential for serious miscalculation.\nPoor row estimates, where Actual Rows differs substantially from Plan Rows, can lead to suboptimal query planning. Estimates can often be improved by running\nANALYZE\n(not the EXPLAIN parameter), by increasing statistics, or by allowing Postgres to understand correlation between columns using multivariate statistics.",
    "Actual Loops":
      "The number of times the operation is executed. For a lot of operations it will have a value of one, but when it is not, there are three different cases:\nSome operations can be executed more than once. For example, “Nested Loops” run their “Inner” child once for every row returned by their “Outer” child.\nWhen an operation that would normally only consist of one loop is split across multiple threads, each partial operation is counted as a Loop.\nThe number of loops can be zero when an operation doesn’t need to be executed at all. For example if a table read is planned to provide candidates for an inner join, but there turns out to be no rows on the other side of the join, the operation can be effectively eliminated.",
    Output:
      "A list of the columns returned by the operation.\nThis is only shown when VERBOSE is on.",
    Filter:
      "When present, this is a filter used to remove rows.\nThe important thing to note is that this is a filter in the traditional sense: these rows are read in (either from a data source or another operation in the plan), inspected, and then approved or removed based on the filter.\nIf a high proportion of rows are being removed by the Filter, you may want to investigate whether a (more) selective index could help.\nIf you notice a lot of rows being filtered late in a query plan, this might be due to an operation (like a GROUP BY or SORT) using more columns than are necessary, requiring joins to take place before rows can be discarded. It is also sometimes a result of unnecessary or ill-advised uses of DISTINCT.",
    "Rows Removed by Filter":
      "The number of rows removed by the\nFilter\n. This is a\nper-loop average\n, rounded to the nearest integer.\nIf a high proportion of rows are being removed, you may want to investigate whether a (more) selective index could help.",
    "Shared Hit Blocks":
      "The number of blocks from indexes/tables that were found in the Postgres buffer cache.\nThis\nincludes\nvalues for child operations and is a\ntotal\nvalue (i.e. not a per-loop average).\nOnce you have subtracted child operation values, the proportion of shared hit to shared read blocks is an interesting measure of cache performance.\nThe ratio of shared blocks (hit plus read) to rows processed (including any filtered out) is also interesting: a high ratio means Postgres is reading a lot of data for what it is doing, which can be a sign of bloat.",
    "Shared Read Blocks":
      "The number of blocks from tables/indexes that were read from disk (or the OS cache).\nThis\nincludes\nvalues for child operations and is a\ntotal\nvalue (i.e. not per-loop).\nOnce you have subtracted child operation values, the proportion of shared hit to shared read blocks is an interesting measure of cache performance.\nThe ratio of shared blocks (hit plus read) to rows processed (including any filtered out) is also interesting: a high ratio means Postgres is reading a lot of data for what it is doing, which can be a sign of bloat.",
    "Shared Dirtied Blocks":
      "The number of blocks from tables/indexes that were modified by the operation.\nThis\nincludes\nvalues for child operations and is a\ntotal\nvalue (i.e. not per-loop).\nInterestingly, a SELECT query can report shared dirtied blocks when setting hint bits on recently-committed rows, or pruning old row versions. While somewhat surprising, both of these are perfectly normal and healthy.",
    "Shared Written Blocks":
      "The number of blocks from tables/indexes that were evicted from the cache.\nThis\nincludes\nvalues for child operations and is a\ntotal\nvalue (i.e. not a per-loop average).",
    "Local Hit Blocks":
      "The number of blocks from temporary tables and indexes that were found in the cache.\nThis\nincludes\nvalues for child operations and is a\ntotal\nvalue (not a per-loop average).",
    "Local Read Blocks":
      "The number of blocks read from\ntemporary tables and indexes that were not found in the Postgres cache (read from disk or the OS cache).\nThis\nincludes\nvalues for child operations and is a\ntotal\nvalue (not a per-loop average).",
    "Local Dirtied Blocks":
      "The number of blocks from\ntemporary tables and indexes that have been modified by the operation.\nThis\nincludes\nvalues for child operations and is a\ntotal\nvalue (i.e. not a per-loop average).",
    "Local Written Blocks":
      "The number of blocks from\ntemporary tables and indexes that were evicted from the cache.\nThis\nincludes\nvalues for child operations and is a\ntotal\nvalue (i.e. not a per-loop average).",
    "Temp Read Blocks":
      "The number of blocks read from short-term data used to calculate hashes, sorts, Materialize operations, and similar.\nThis\nincludes\nvalues for child operations and is a\ntotal\nvalue (i.e. not a per-loop average).\nYour settings of\nwork_mem\nand\nhash_mem_multiplier\ndetermine how much memory is available to Postgres per operation.",
    "Temp Written Blocks":
      "The number of blocks from short-term data (used to calculate operations like hashes, sorts, and materializes) that were evicted from the cache.\nThis\nincludes\nvalues for child operations and is a\ntotal\nvalue (i.e. not a per-loop average).\nYour settings of\nwork_mem\nand\nhash_mem_multiplier\ndetermine how much memory is available to Postgres per operation.",
    "Shared I/O Read Time":
      "The time spent reading data from tables and indexes, in\nmilliseconds\n.\nThis\nincludes\nvalues for child operations and is a total value (not a per-loop average).\nRequires\ntrack_io_timing\nand\nBUFFERS\nto be on.\nIn the latest version, the text format of explain displays this as\nI/O Timings: shared read\nIn PostgreSQL 15 and 16 it shows as a combined metric\nI/O Timings: shared/local read\nGetting timing information has an overhead, due to checking the system clock. You can use\npg_test_timing\nto measure this for your system.",
    "Shared I/O Write Time":
      "The time spent writing data for tables and indexes, in\nmilliseconds\n.\nThis\nincludes\nvalues for child operations and is a total value (not a per-loop average).\nRequires\ntrack_io_timing\nand\nBUFFERS\nto be on.\nIn the latest version, the text format of explain displays this as\nI/O Timings: shared write\nIn PostgreSQL 15 and 16 it shows as a combined metric\nI/O Timings: shared/local write\nGetting timing information has an overhead, due to checking the system clock. You can use\npg_test_timing\nto measure this for your system.",
    "Local I/O Read Time":
      "The time spent reading local data (e.g. from temporary tables and indexes), in\nmilliseconds\n.\nThis\nincludes\nvalues for child operations and is a total value (i.e. not a per-loop average).\nThis was added as a separate field in PostgreSQL 17, and requires both\ntrack_io_timing\nand\nBUFFERS\n.\nIn the default text format, this will show as\nI/O Timings: local read\nIn versions 15 and 16 it is available as a combined metric as\nshared/local\nGetting timing information has an overhead, due to checking the system clock. You can use\npg_test_timing\nto measure this for your system.",
    "Local I/O Write Time":
      "The time spent writing local data (e.g. for temporary tables and indexes), in\nmilliseconds\n.\nThis\nincludes\nvalues for child operations and is a total value (i.e. not a per-loop average).\nThis was added as a separate field in PostgreSQL 17, and requires both\ntrack_io_timing\nand\nBUFFERS\n.\nIn the default text format, this will show as\nI/O Timings: local write\nIn versions 15 and 16 it is available as a combined metric as\nshared/local\nGetting timing information has an overhead, due to checking the system clock. You can use\npg_test_timing\nto measure this for your system.",
    "Temp I/O Read Time":
      "The time spent reading short-term data, in\nmilliseconds\n(for example during sort and hash operations that were not done in memory).\nThis\nincludes\nvalues for child operations and is a total value (i.e. not a per-loop average).\nThis was added in PostgreSQL 15, and requires both\ntrack_io_timing\nand\nBUFFERS\n.\nIn the text format of explain, this shows as\nI/O Timings: temp read\nGetting timing information has an overhead, due to checking the system clock. You can use\npg_test_timing\nto measure this for your system.",
    "Temp I/O Write Time":
      "The time spent writing short-term data, in\nmilliseconds\n(for example during sort and hash operations that were not done in memory).\nThis\nincludes\nvalues for child operations and is a total value (i.e. not a per-loop average).\nThis was added in PostgreSQL 15, and requires both\ntrack_io_timing\nand\nBUFFERS\n.\nIn the text format of explain, this shows as\nI/O Timings: temp write\nGetting timing information has an overhead, due to checking the system clock. You can use\npg_test_timing\nto measure this for your system.",
    Workers:
      "A summary of the operation detail broken down by thread.\nThese entries\ndon’t\ninclude the main (or leader) thread.\nYou can work out the values for the main thread by subtracting the worker statistics from the total.\nThis information is only shown when VERBOSE is on.",
  },
  "Index Scan": {
    "Parent Relationship":
      "A guide as to why this operation needs to be run in order to facilitate the parent operation. There are six different possibilities:\nOuter\n: The value you’ll see most often. It means “take in the rows from this operation as input, process them and pass them on”.\nInner\n: Only ever seen on the second child of join operations, and is always seen there. This is the “inner” part of the loop — for each outer row, we look up its match using this operation.\nMember\n: Used for all children of Append and ModifyTable nodes, and on bitmap processing nodes like BitmapAnd and BitmapOr operations.\nInitPlan\n: Used for calculations performed before the query can start, eg a constant referred to in the query or the result of a CTE scan.\nSubquery\n: The child is a subquery of the parent operation. Since Postgres always uses subquery scans to feed subquery data to parent queries, only ever appears on the children of subquery scans.\nSubPlan\n: Like a Subquery, represents a new query, but used when a subquery scan is not necessary.",
    "Parallel Aware":
      "Whether or not the operation will be run in a special mode to support parallelism. Some operations need to be aware that they are running in parallel, for example sequential scans need to know they only need to scan a smaller proportion of the table. Other operations can be run on several threads without each one having any knowledge of the others.",
    "Scan Direction":
      "Postgres is able to do a\nforward\nor\nbackward\nscan of a (b-tree) index to get data in sorted order. In the default (text) format, the direction is forward unless stated otherwise.\nYou may also see scan direction of “NoMovement” in scans of other index types.",
    "Index Name":
      "Unsurprisingly, this is the name of the index being scanned.",
    "Relation Name":
      "The data source being read/written from. Normally a table name (including when the data is accessed via an index), but can also be a materialised view or foreign data source.",
    Schema:
      "The schema of the “Relation Name” object.\nThis is only shown when VERBOSE is on.",
    Alias: "The alias used to refer to the Relation Name object.",
    "Startup Cost":
      "The estimated cost of returning the first row.\nThis is in an arbitrary unit, with the aim of being correlated to the startup time.",
    "Total Cost":
      "The estimated cost of returning all rows. This is in an arbitrary unit, with the aim of being correlated to the total time.\nThe Postgres query planner often has several ways it could resolve the same query. It calculates costs — which are hopefully correlated with the time it would take — for potential plans, and then picks the one with the lowest cost. It’s worth bearing in mind that the costs are unit-free — they’re not designed to convert into time, or disk reads. They’re just supposed to be bigger for slower operations, and smaller for faster ones.\nIf the planner thinks it can finish early due to a parent Limit operation, the total cost of the Limit operation will reflect this, but the total cost of its child operations will not.",
    "Plan Rows":
      "The number of rows,\nper-loop\n, that the planner expects to be returned by the operation.\nPoor row estimates can lead to suboptimal query planning. They can often be improved by running\nANALYZE\n(not the EXPLAIN parameter), by increasing statistics, or by allowing Postgres to understand correlation between columns using multivariate statistics.\nIf the planner thinks it can finish early due to a Limit operation, the plan rows of the Limit operation will reflect this, but the plan rows of its child operations will not.",
    "Plan Width":
      "The\nestimated\naverage size of the rows produced by the operation, in\nbytes\n.",
    "Actual Startup Time":
      "The amount of time, in\nmilliseconds\n, it takes to get the first row out of the operation.\nSometimes, this is very close to the setup time — for example on a sequential scan which returns all the rows in a table.\nOther times, though, it’s more or less the total time. For example, in order to return the first row of a sort, you have to sort all of the rows to work out which one comes first.",
    "Actual Total Time":
      "The actual amount of time in milliseconds spent on this operation\nand all of its children\n. It’s a\nper-loop average\n, rounded to the nearest thousandth of a millisecond.\nWorking out individual operation timings, especially where CTEs and SubPlans are concerned, can be tricky. This is one of the main reasons we decided to build\npgMustard\n.",
    "Actual Rows":
      "The number of rows returned by the operation\nper loop\n.\nThe important thing to notice about this is that it’s an average of all the loops executed, rounded to the nearest integer. This means that while “Actual Loops” multiplied by “Actual Rows” is a pretty good approximation for total number of rows returned most of the time, it can be off by as much as half of the number of loops. Usually it’s just slightly confusing as you see a row or two appear or disappear between operations, but on operations with lots of loops there is potential for serious miscalculation.\nPoor row estimates, where Actual Rows differs substantially from Plan Rows, can lead to suboptimal query planning. Estimates can often be improved by running\nANALYZE\n(not the EXPLAIN parameter), by increasing statistics, or by allowing Postgres to understand correlation between columns using multivariate statistics.",
    "Actual Loops":
      "The number of times the operation is executed. For a lot of operations it will have a value of one, but when it is not, there are three different cases:\nSome operations can be executed more than once. For example, “Nested Loops” run their “Inner” child once for every row returned by their “Outer” child.\nWhen an operation that would normally only consist of one loop is split across multiple threads, each partial operation is counted as a Loop.\nThe number of loops can be zero when an operation doesn’t need to be executed at all. For example if a table read is planned to provide candidates for an inner join, but there turns out to be no rows on the other side of the join, the operation can be effectively eliminated.",
    Output:
      "A list of the columns returned by the operation.\nThis is only shown when VERBOSE is on.",
    "Index Cond":
      "The condition(s) used to find the locations of rows from the index.\nPostgres uses the structured nature of the index to jump to the rows it's looking for. Different index types use different strategies.\nUnfortunately, Postgres doesn’t yet distinguish between conditions used to access and conditions used to filter rows as part of the Index Cond. As such, you need to compare the index definition and query conditions to work it out, and can compare the\nCOSTS\nor\nBUFFERS\nbetween query plans as a check.\nAny conditions that could not be used to search the index will be added as a\nFilter\n, which later discards any rows necessary based on their values. This is naturally less efficient.",
    "Rows Removed by Index Recheck":
      "The number of rows returned by the index scan that do not meet the condition and are subsequently removed.\nThis will either be the result of a lossy bitmap scan, or an index type that doesn't guarantee that a row matches the condition.",
    Filter:
      "When present, this is a filter used to remove rows.\nThe important thing to note is that this is a filter in the traditional sense: these rows are read in (either from a data source or another operation in the plan), inspected, and then approved or removed based on the filter.\nIf a high proportion of rows are being removed by the Filter, you may want to investigate whether a (more) selective index could help.\nIf you notice a lot of rows being filtered late in a query plan, this might be due to an operation (like a GROUP BY or SORT) using more columns than are necessary, requiring joins to take place before rows can be discarded. It is also sometimes a result of unnecessary or ill-advised uses of DISTINCT.",
    "Rows Removed by Filter":
      "The number of rows removed by the\nFilter\n. This is a\nper-loop average\n, rounded to the nearest integer.\nIf a high proportion of rows are being removed, you may want to investigate whether a (more) selective index could help.",
    "Shared Hit Blocks":
      "The number of blocks from indexes/tables that were found in the Postgres buffer cache.\nThis\nincludes\nvalues for child operations and is a\ntotal\nvalue (i.e. not a per-loop average).\nOnce you have subtracted child operation values, the proportion of shared hit to shared read blocks is an interesting measure of cache performance.\nThe ratio of shared blocks (hit plus read) to rows processed (including any filtered out) is also interesting: a high ratio means Postgres is reading a lot of data for what it is doing, which can be a sign of bloat.",
    "Shared Read Blocks":
      "The number of blocks from tables/indexes that were read from disk (or the OS cache).\nThis\nincludes\nvalues for child operations and is a\ntotal\nvalue (i.e. not per-loop).\nOnce you have subtracted child operation values, the proportion of shared hit to shared read blocks is an interesting measure of cache performance.\nThe ratio of shared blocks (hit plus read) to rows processed (including any filtered out) is also interesting: a high ratio means Postgres is reading a lot of data for what it is doing, which can be a sign of bloat.",
    "Shared Dirtied Blocks":
      "The number of blocks from tables/indexes that were modified by the operation.\nThis\nincludes\nvalues for child operations and is a\ntotal\nvalue (i.e. not per-loop).\nInterestingly, a SELECT query can report shared dirtied blocks when setting hint bits on recently-committed rows, or pruning old row versions. While somewhat surprising, both of these are perfectly normal and healthy.",
    "Shared Written Blocks":
      "The number of blocks from tables/indexes that were evicted from the cache.\nThis\nincludes\nvalues for child operations and is a\ntotal\nvalue (i.e. not a per-loop average).",
    "Local Hit Blocks":
      "The number of blocks from temporary tables and indexes that were found in the cache.\nThis\nincludes\nvalues for child operations and is a\ntotal\nvalue (not a per-loop average).",
    "Local Read Blocks":
      "The number of blocks read from\ntemporary tables and indexes that were not found in the Postgres cache (read from disk or the OS cache).\nThis\nincludes\nvalues for child operations and is a\ntotal\nvalue (not a per-loop average).",
    "Local Dirtied Blocks":
      "The number of blocks from\ntemporary tables and indexes that have been modified by the operation.\nThis\nincludes\nvalues for child operations and is a\ntotal\nvalue (i.e. not a per-loop average).",
    "Local Written Blocks":
      "The number of blocks from\ntemporary tables and indexes that were evicted from the cache.\nThis\nincludes\nvalues for child operations and is a\ntotal\nvalue (i.e. not a per-loop average).",
    "Temp Read Blocks":
      "The number of blocks read from short-term data used to calculate hashes, sorts, Materialize operations, and similar.\nThis\nincludes\nvalues for child operations and is a\ntotal\nvalue (i.e. not a per-loop average).\nYour settings of\nwork_mem\nand\nhash_mem_multiplier\ndetermine how much memory is available to Postgres per operation.",
    "Temp Written Blocks":
      "The number of blocks from short-term data (used to calculate operations like hashes, sorts, and materializes) that were evicted from the cache.\nThis\nincludes\nvalues for child operations and is a\ntotal\nvalue (i.e. not a per-loop average).\nYour settings of\nwork_mem\nand\nhash_mem_multiplier\ndetermine how much memory is available to Postgres per operation.",
    "Shared I/O Read Time":
      "The time spent reading data from tables and indexes, in\nmilliseconds\n.\nThis\nincludes\nvalues for child operations and is a total value (not a per-loop average).\nRequires\ntrack_io_timing\nand\nBUFFERS\nto be on.\nIn the latest version, the text format of explain displays this as\nI/O Timings: shared read\nIn PostgreSQL 15 and 16 it shows as a combined metric\nI/O Timings: shared/local read\nGetting timing information has an overhead, due to checking the system clock. You can use\npg_test_timing\nto measure this for your system.",
    "Shared I/O Write Time":
      "The time spent writing data for tables and indexes, in\nmilliseconds\n.\nThis\nincludes\nvalues for child operations and is a total value (not a per-loop average).\nRequires\ntrack_io_timing\nand\nBUFFERS\nto be on.\nIn the latest version, the text format of explain displays this as\nI/O Timings: shared write\nIn PostgreSQL 15 and 16 it shows as a combined metric\nI/O Timings: shared/local write\nGetting timing information has an overhead, due to checking the system clock. You can use\npg_test_timing\nto measure this for your system.",
    "Local I/O Read Time":
      "The time spent reading local data (e.g. from temporary tables and indexes), in\nmilliseconds\n.\nThis\nincludes\nvalues for child operations and is a total value (i.e. not a per-loop average).\nThis was added as a separate field in PostgreSQL 17, and requires both\ntrack_io_timing\nand\nBUFFERS\n.\nIn the default text format, this will show as\nI/O Timings: local read\nIn versions 15 and 16 it is available as a combined metric as\nshared/local\nGetting timing information has an overhead, due to checking the system clock. You can use\npg_test_timing\nto measure this for your system.",
    "Local I/O Write Time":
      "The time spent writing local data (e.g. for temporary tables and indexes), in\nmilliseconds\n.\nThis\nincludes\nvalues for child operations and is a total value (i.e. not a per-loop average).\nThis was added as a separate field in PostgreSQL 17, and requires both\ntrack_io_timing\nand\nBUFFERS\n.\nIn the default text format, this will show as\nI/O Timings: local write\nIn versions 15 and 16 it is available as a combined metric as\nshared/local\nGetting timing information has an overhead, due to checking the system clock. You can use\npg_test_timing\nto measure this for your system.",
    "Temp I/O Read Time":
      "The time spent reading short-term data, in\nmilliseconds\n(for example during sort and hash operations that were not done in memory).\nThis\nincludes\nvalues for child operations and is a total value (i.e. not a per-loop average).\nThis was added in PostgreSQL 15, and requires both\ntrack_io_timing\nand\nBUFFERS\n.\nIn the text format of explain, this shows as\nI/O Timings: temp read\nGetting timing information has an overhead, due to checking the system clock. You can use\npg_test_timing\nto measure this for your system.",
    "Temp I/O Write Time":
      "The time spent writing short-term data, in\nmilliseconds\n(for example during sort and hash operations that were not done in memory).\nThis\nincludes\nvalues for child operations and is a total value (i.e. not a per-loop average).\nThis was added in PostgreSQL 15, and requires both\ntrack_io_timing\nand\nBUFFERS\n.\nIn the text format of explain, this shows as\nI/O Timings: temp write\nGetting timing information has an overhead, due to checking the system clock. You can use\npg_test_timing\nto measure this for your system.",
  },
  "Index-Only Scan": {
    "Parent Relationship":
      "A guide as to why this operation needs to be run in order to facilitate the parent operation. There are six different possibilities:\nOuter\n: The value you’ll see most often. It means “take in the rows from this operation as input, process them and pass them on”.\nInner\n: Only ever seen on the second child of join operations, and is always seen there. This is the “inner” part of the loop — for each outer row, we look up its match using this operation.\nMember\n: Used for all children of Append and ModifyTable nodes, and on bitmap processing nodes like BitmapAnd and BitmapOr operations.\nInitPlan\n: Used for calculations performed before the query can start, eg a constant referred to in the query or the result of a CTE scan.\nSubquery\n: The child is a subquery of the parent operation. Since Postgres always uses subquery scans to feed subquery data to parent queries, only ever appears on the children of subquery scans.\nSubPlan\n: Like a Subquery, represents a new query, but used when a subquery scan is not necessary.",
    "Parallel Aware":
      "Whether or not the operation will be run in a special mode to support parallelism. Some operations need to be aware that they are running in parallel, for example sequential scans need to know they only need to scan a smaller proportion of the table. Other operations can be run on several threads without each one having any knowledge of the others.",
    "Scan Direction":
      "Postgres is able to do a\nforward\nor\nbackward\nscan of a (b-tree) index to get data in sorted order. In the default (text) format, the direction is forward unless stated otherwise.\nYou may also see scan direction of “NoMovement” in scans of other index types.",
    "Index Name":
      "Unsurprisingly, this is the name of the index being scanned.",
    "Relation Name":
      "The data source being read/written from. Normally a table name (including when the data is accessed via an index), but can also be a materialised view or foreign data source.",
    Schema:
      "The schema of the “Relation Name” object.\nThis is only shown when VERBOSE is on.",
    Alias: "The alias used to refer to the Relation Name object.",
    "Startup Cost":
      "The estimated cost of returning the first row.\nThis is in an arbitrary unit, with the aim of being correlated to the startup time.",
    "Total Cost":
      "The estimated cost of returning all rows. This is in an arbitrary unit, with the aim of being correlated to the total time.\nThe Postgres query planner often has several ways it could resolve the same query. It calculates costs — which are hopefully correlated with the time it would take — for potential plans, and then picks the one with the lowest cost. It’s worth bearing in mind that the costs are unit-free — they’re not designed to convert into time, or disk reads. They’re just supposed to be bigger for slower operations, and smaller for faster ones.\nIf the planner thinks it can finish early due to a parent Limit operation, the total cost of the Limit operation will reflect this, but the total cost of its child operations will not.",
    "Plan Rows":
      "The number of rows,\nper-loop\n, that the planner expects to be returned by the operation.\nPoor row estimates can lead to suboptimal query planning. They can often be improved by running\nANALYZE\n(not the EXPLAIN parameter), by increasing statistics, or by allowing Postgres to understand correlation between columns using multivariate statistics.\nIf the planner thinks it can finish early due to a Limit operation, the plan rows of the Limit operation will reflect this, but the plan rows of its child operations will not.",
    "Plan Width":
      "The\nestimated\naverage size of the rows produced by the operation, in\nbytes\n.",
    "Actual Startup Time":
      "The amount of time, in\nmilliseconds\n, it takes to get the first row out of the operation.\nSometimes, this is very close to the setup time — for example on a sequential scan which returns all the rows in a table.\nOther times, though, it’s more or less the total time. For example, in order to return the first row of a sort, you have to sort all of the rows to work out which one comes first.",
    "Actual Total Time":
      "The actual amount of time in milliseconds spent on this operation\nand all of its children\n. It’s a\nper-loop average\n, rounded to the nearest thousandth of a millisecond.\nWorking out individual operation timings, especially where CTEs and SubPlans are concerned, can be tricky. This is one of the main reasons we decided to build\npgMustard\n.",
    "Actual Rows":
      "The number of rows returned by the operation\nper loop\n.\nThe important thing to notice about this is that it’s an average of all the loops executed, rounded to the nearest integer. This means that while “Actual Loops” multiplied by “Actual Rows” is a pretty good approximation for total number of rows returned most of the time, it can be off by as much as half of the number of loops. Usually it’s just slightly confusing as you see a row or two appear or disappear between operations, but on operations with lots of loops there is potential for serious miscalculation.\nPoor row estimates, where Actual Rows differs substantially from Plan Rows, can lead to suboptimal query planning. Estimates can often be improved by running\nANALYZE\n(not the EXPLAIN parameter), by increasing statistics, or by allowing Postgres to understand correlation between columns using multivariate statistics.",
    "Actual Loops":
      "The number of times the operation is executed. For a lot of operations it will have a value of one, but when it is not, there are three different cases:\nSome operations can be executed more than once. For example, “Nested Loops” run their “Inner” child once for every row returned by their “Outer” child.\nWhen an operation that would normally only consist of one loop is split across multiple threads, each partial operation is counted as a Loop.\nThe number of loops can be zero when an operation doesn’t need to be executed at all. For example if a table read is planned to provide candidates for an inner join, but there turns out to be no rows on the other side of the join, the operation can be effectively eliminated.",
    Output:
      "A list of the columns returned by the operation.\nThis is only shown when VERBOSE is on.",
    "Index Cond":
      "The condition(s) used to find the locations of rows from the index.\nPostgres uses the structured nature of the index to jump to the rows it's looking for. Different index types use different strategies.\nUnfortunately, Postgres doesn’t yet distinguish between conditions used to access and conditions used to filter rows as part of the Index Cond. As such, you need to compare the index definition and query conditions to work it out, and can compare the\nCOSTS\nor\nBUFFERS\nbetween query plans as a check.\nAny conditions that could not be used to search the index will be added as a\nFilter\n, which later discards any rows necessary based on their values. This is naturally less efficient.",
    "Rows Removed by Index Recheck":
      "The number of rows returned by the index scan that do not meet the condition and are subsequently removed.\nThis will either be the result of a lossy bitmap scan, or an index type that doesn't guarantee that a row matches the condition.",
    Filter:
      "When present, this is a filter used to remove rows.\nThe important thing to note is that this is a filter in the traditional sense: these rows are read in (either from a data source or another operation in the plan), inspected, and then approved or removed based on the filter.\nIf a high proportion of rows are being removed by the Filter, you may want to investigate whether a (more) selective index could help.\nIf you notice a lot of rows being filtered late in a query plan, this might be due to an operation (like a GROUP BY or SORT) using more columns than are necessary, requiring joins to take place before rows can be discarded. It is also sometimes a result of unnecessary or ill-advised uses of DISTINCT.",
    "Rows Removed by Filter":
      "The number of rows removed by the\nFilter\n. This is a\nper-loop average\n, rounded to the nearest integer.\nIf a high proportion of rows are being removed, you may want to investigate whether a (more) selective index could help.",
    "Heap Fetches":
      "The number of rows Postgres had to look up in the table, rather than the index, during an index-only scan. It is a\ntotal\nvalue (not a per-loop average).\nPostgres still needs to be sure that the row is visible before it can return it, and that information is on the heap, not in the index. It can get around going to the heap for a particular row by checking the visibility map, which records whether or not each page has been changed recently.\nIf the page has changed, then that means a trip to the heap, the same as if we were doing a normal index scan — in fact it’s slightly worse than an index scan, because we’ve added in an extra check of the visibility map.\nHeap fetches can often be reduced by vacuum, or adjusting autovacuum settings, to keep the visibility map more up to date.",
    "Shared Hit Blocks":
      "The number of blocks from indexes/tables that were found in the Postgres buffer cache.\nThis\nincludes\nvalues for child operations and is a\ntotal\nvalue (i.e. not a per-loop average).\nOnce you have subtracted child operation values, the proportion of shared hit to shared read blocks is an interesting measure of cache performance.\nThe ratio of shared blocks (hit plus read) to rows processed (including any filtered out) is also interesting: a high ratio means Postgres is reading a lot of data for what it is doing, which can be a sign of bloat.",
    "Shared Read Blocks":
      "The number of blocks from tables/indexes that were read from disk (or the OS cache).\nThis\nincludes\nvalues for child operations and is a\ntotal\nvalue (i.e. not per-loop).\nOnce you have subtracted child operation values, the proportion of shared hit to shared read blocks is an interesting measure of cache performance.\nThe ratio of shared blocks (hit plus read) to rows processed (including any filtered out) is also interesting: a high ratio means Postgres is reading a lot of data for what it is doing, which can be a sign of bloat.",
    "Shared Dirtied Blocks":
      "The number of blocks from tables/indexes that were modified by the operation.\nThis\nincludes\nvalues for child operations and is a\ntotal\nvalue (i.e. not per-loop).\nInterestingly, a SELECT query can report shared dirtied blocks when setting hint bits on recently-committed rows, or pruning old row versions. While somewhat surprising, both of these are perfectly normal and healthy.",
    "Shared Written Blocks":
      "The number of blocks from tables/indexes that were evicted from the cache.\nThis\nincludes\nvalues for child operations and is a\ntotal\nvalue (i.e. not a per-loop average).",
    "Local Hit Blocks":
      "The number of blocks from temporary tables and indexes that were found in the cache.\nThis\nincludes\nvalues for child operations and is a\ntotal\nvalue (not a per-loop average).",
    "Local Read Blocks":
      "The number of blocks read from\ntemporary tables and indexes that were not found in the Postgres cache (read from disk or the OS cache).\nThis\nincludes\nvalues for child operations and is a\ntotal\nvalue (not a per-loop average).",
    "Local Dirtied Blocks":
      "The number of blocks from\ntemporary tables and indexes that have been modified by the operation.\nThis\nincludes\nvalues for child operations and is a\ntotal\nvalue (i.e. not a per-loop average).",
    "Local Written Blocks":
      "The number of blocks from\ntemporary tables and indexes that were evicted from the cache.\nThis\nincludes\nvalues for child operations and is a\ntotal\nvalue (i.e. not a per-loop average).",
    "Temp Read Blocks":
      "The number of blocks read from short-term data used to calculate hashes, sorts, Materialize operations, and similar.\nThis\nincludes\nvalues for child operations and is a\ntotal\nvalue (i.e. not a per-loop average).\nYour settings of\nwork_mem\nand\nhash_mem_multiplier\ndetermine how much memory is available to Postgres per operation.",
    "Temp Written Blocks":
      "The number of blocks from short-term data (used to calculate operations like hashes, sorts, and materializes) that were evicted from the cache.\nThis\nincludes\nvalues for child operations and is a\ntotal\nvalue (i.e. not a per-loop average).\nYour settings of\nwork_mem\nand\nhash_mem_multiplier\ndetermine how much memory is available to Postgres per operation.",
    "Shared I/O Read Time":
      "The time spent reading data from tables and indexes, in\nmilliseconds\n.\nThis\nincludes\nvalues for child operations and is a total value (not a per-loop average).\nRequires\ntrack_io_timing\nand\nBUFFERS\nto be on.\nIn the latest version, the text format of explain displays this as\nI/O Timings: shared read\nIn PostgreSQL 15 and 16 it shows as a combined metric\nI/O Timings: shared/local read\nGetting timing information has an overhead, due to checking the system clock. You can use\npg_test_timing\nto measure this for your system.",
    "Shared I/O Write Time":
      "The time spent writing data for tables and indexes, in\nmilliseconds\n.\nThis\nincludes\nvalues for child operations and is a total value (not a per-loop average).\nRequires\ntrack_io_timing\nand\nBUFFERS\nto be on.\nIn the latest version, the text format of explain displays this as\nI/O Timings: shared write\nIn PostgreSQL 15 and 16 it shows as a combined metric\nI/O Timings: shared/local write\nGetting timing information has an overhead, due to checking the system clock. You can use\npg_test_timing\nto measure this for your system.",
    "Local I/O Read Time":
      "The time spent reading local data (e.g. from temporary tables and indexes), in\nmilliseconds\n.\nThis\nincludes\nvalues for child operations and is a total value (i.e. not a per-loop average).\nThis was added as a separate field in PostgreSQL 17, and requires both\ntrack_io_timing\nand\nBUFFERS\n.\nIn the default text format, this will show as\nI/O Timings: local read\nIn versions 15 and 16 it is available as a combined metric as\nshared/local\nGetting timing information has an overhead, due to checking the system clock. You can use\npg_test_timing\nto measure this for your system.",
    "Local I/O Write Time":
      "The time spent writing local data (e.g. for temporary tables and indexes), in\nmilliseconds\n.\nThis\nincludes\nvalues for child operations and is a total value (i.e. not a per-loop average).\nThis was added as a separate field in PostgreSQL 17, and requires both\ntrack_io_timing\nand\nBUFFERS\n.\nIn the default text format, this will show as\nI/O Timings: local write\nIn versions 15 and 16 it is available as a combined metric as\nshared/local\nGetting timing information has an overhead, due to checking the system clock. You can use\npg_test_timing\nto measure this for your system.",
    "Temp I/O Read Time":
      "The time spent reading short-term data, in\nmilliseconds\n(for example during sort and hash operations that were not done in memory).\nThis\nincludes\nvalues for child operations and is a total value (i.e. not a per-loop average).\nThis was added in PostgreSQL 15, and requires both\ntrack_io_timing\nand\nBUFFERS\n.\nIn the text format of explain, this shows as\nI/O Timings: temp read\nGetting timing information has an overhead, due to checking the system clock. You can use\npg_test_timing\nto measure this for your system.",
    "Temp I/O Write Time":
      "The time spent writing short-term data, in\nmilliseconds\n(for example during sort and hash operations that were not done in memory).\nThis\nincludes\nvalues for child operations and is a total value (i.e. not a per-loop average).\nThis was added in PostgreSQL 15, and requires both\ntrack_io_timing\nand\nBUFFERS\n.\nIn the text format of explain, this shows as\nI/O Timings: temp write\nGetting timing information has an overhead, due to checking the system clock. You can use\npg_test_timing\nto measure this for your system.",
  },
  "Nested Loop": {
    "Parent Relationship":
      "A guide as to why this operation needs to be run in order to facilitate the parent operation. There are six different possibilities:\nOuter\n: The value you’ll see most often. It means “take in the rows from this operation as input, process them and pass them on”.\nInner\n: Only ever seen on the second child of join operations, and is always seen there. This is the “inner” part of the loop — for each outer row, we look up its match using this operation.\nMember\n: Used for all children of Append and ModifyTable nodes, and on bitmap processing nodes like BitmapAnd and BitmapOr operations.\nInitPlan\n: Used for calculations performed before the query can start, eg a constant referred to in the query or the result of a CTE scan.\nSubquery\n: The child is a subquery of the parent operation. Since Postgres always uses subquery scans to feed subquery data to parent queries, only ever appears on the children of subquery scans.\nSubPlan\n: Like a Subquery, represents a new query, but used when a subquery scan is not necessary.",
    "Parallel Aware":
      "Whether or not the operation will be run in a special mode to support parallelism. Some operations need to be aware that they are running in parallel, for example sequential scans need to know they only need to scan a smaller proportion of the table. Other operations can be run on several threads without each one having any knowledge of the others.",
    "Join Type":
      "Which type of join was performed: Inner, Full, Left, Right, Semi, or Anti.\nIn text format plans, you can assume it is an inner join unless stated otherwise.",
    "Startup Cost":
      "The estimated cost of returning the first row.\nThis is in an arbitrary unit, with the aim of being correlated to the startup time.",
    "Total Cost":
      "The estimated cost of returning all rows. This is in an arbitrary unit, with the aim of being correlated to the total time.\nThe Postgres query planner often has several ways it could resolve the same query. It calculates costs — which are hopefully correlated with the time it would take — for potential plans, and then picks the one with the lowest cost. It’s worth bearing in mind that the costs are unit-free — they’re not designed to convert into time, or disk reads. They’re just supposed to be bigger for slower operations, and smaller for faster ones.\nIf the planner thinks it can finish early due to a parent Limit operation, the total cost of the Limit operation will reflect this, but the total cost of its child operations will not.",
    "Plan Rows":
      "The number of rows,\nper-loop\n, that the planner expects to be returned by the operation.\nPoor row estimates can lead to suboptimal query planning. They can often be improved by running\nANALYZE\n(not the EXPLAIN parameter), by increasing statistics, or by allowing Postgres to understand correlation between columns using multivariate statistics.\nIf the planner thinks it can finish early due to a Limit operation, the plan rows of the Limit operation will reflect this, but the plan rows of its child operations will not.",
    "Plan Width":
      "The\nestimated\naverage size of the rows produced by the operation, in\nbytes\n.",
    "Actual Startup Time":
      "The amount of time, in\nmilliseconds\n, it takes to get the first row out of the operation.\nSometimes, this is very close to the setup time — for example on a sequential scan which returns all the rows in a table.\nOther times, though, it’s more or less the total time. For example, in order to return the first row of a sort, you have to sort all of the rows to work out which one comes first.",
    "Actual Total Time":
      "The actual amount of time in milliseconds spent on this operation\nand all of its children\n. It’s a\nper-loop average\n, rounded to the nearest thousandth of a millisecond.\nWorking out individual operation timings, especially where CTEs and SubPlans are concerned, can be tricky. This is one of the main reasons we decided to build\npgMustard\n.",
    "Actual Rows":
      "The number of rows returned by the operation\nper loop\n.\nThe important thing to notice about this is that it’s an average of all the loops executed, rounded to the nearest integer. This means that while “Actual Loops” multiplied by “Actual Rows” is a pretty good approximation for total number of rows returned most of the time, it can be off by as much as half of the number of loops. Usually it’s just slightly confusing as you see a row or two appear or disappear between operations, but on operations with lots of loops there is potential for serious miscalculation.\nPoor row estimates, where Actual Rows differs substantially from Plan Rows, can lead to suboptimal query planning. Estimates can often be improved by running\nANALYZE\n(not the EXPLAIN parameter), by increasing statistics, or by allowing Postgres to understand correlation between columns using multivariate statistics.",
    "Actual Loops":
      "The number of times the operation is executed. For a lot of operations it will have a value of one, but when it is not, there are three different cases:\nSome operations can be executed more than once. For example, “Nested Loops” run their “Inner” child once for every row returned by their “Outer” child.\nWhen an operation that would normally only consist of one loop is split across multiple threads, each partial operation is counted as a Loop.\nThe number of loops can be zero when an operation doesn’t need to be executed at all. For example if a table read is planned to provide candidates for an inner join, but there turns out to be no rows on the other side of the join, the operation can be effectively eliminated.",
    Output:
      "A list of the columns returned by the operation.\nThis is only shown when VERBOSE is on.",
    "Inner Unique":
      "This is\ntrue\nif\nno more than one inner row could match any given outer row. This allows the executor to skip searching for additional matches.",
    "Join Filter":
      "A filter that can happen before the join, allowing Postgres to avoid looking up the rows and filtering them out afterwards.",
    "Rows Removed by Join Filter":
      "The number of rows removed by the join filter.\nIf a high proportion of rows are being removed, you may want to investigate whether a (more) selective index could help.",
    Filter:
      "When present, this is a filter used to remove rows.\nThe important thing to note is that this is a filter in the traditional sense: these rows are read in (either from a data source or another operation in the plan), inspected, and then approved or removed based on the filter.\nIf a high proportion of rows are being removed by the Filter, you may want to investigate whether a (more) selective index could help.\nIf you notice a lot of rows being filtered late in a query plan, this might be due to an operation (like a GROUP BY or SORT) using more columns than are necessary, requiring joins to take place before rows can be discarded. It is also sometimes a result of unnecessary or ill-advised uses of DISTINCT.",
    "Rows Removed by Filter":
      "The number of rows removed by the\nFilter\n. This is a\nper-loop average\n, rounded to the nearest integer.\nIf a high proportion of rows are being removed, you may want to investigate whether a (more) selective index could help.",
    "Shared Hit Blocks":
      "The number of blocks from indexes/tables that were found in the Postgres buffer cache.\nThis\nincludes\nvalues for child operations and is a\ntotal\nvalue (i.e. not a per-loop average).\nOnce you have subtracted child operation values, the proportion of shared hit to shared read blocks is an interesting measure of cache performance.\nThe ratio of shared blocks (hit plus read) to rows processed (including any filtered out) is also interesting: a high ratio means Postgres is reading a lot of data for what it is doing, which can be a sign of bloat.",
    "Shared Read Blocks":
      "The number of blocks from tables/indexes that were read from disk (or the OS cache).\nThis\nincludes\nvalues for child operations and is a\ntotal\nvalue (i.e. not per-loop).\nOnce you have subtracted child operation values, the proportion of shared hit to shared read blocks is an interesting measure of cache performance.\nThe ratio of shared blocks (hit plus read) to rows processed (including any filtered out) is also interesting: a high ratio means Postgres is reading a lot of data for what it is doing, which can be a sign of bloat.",
    "Shared Dirtied Blocks":
      "The number of blocks from tables/indexes that were modified by the operation.\nThis\nincludes\nvalues for child operations and is a\ntotal\nvalue (i.e. not per-loop).\nInterestingly, a SELECT query can report shared dirtied blocks when setting hint bits on recently-committed rows, or pruning old row versions. While somewhat surprising, both of these are perfectly normal and healthy.",
    "Shared Written Blocks":
      "The number of blocks from tables/indexes that were evicted from the cache.\nThis\nincludes\nvalues for child operations and is a\ntotal\nvalue (i.e. not a per-loop average).",
    "Local Hit Blocks":
      "The number of blocks from temporary tables and indexes that were found in the cache.\nThis\nincludes\nvalues for child operations and is a\ntotal\nvalue (not a per-loop average).",
    "Local Read Blocks":
      "The number of blocks read from\ntemporary tables and indexes that were not found in the Postgres cache (read from disk or the OS cache).\nThis\nincludes\nvalues for child operations and is a\ntotal\nvalue (not a per-loop average).",
    "Local Dirtied Blocks":
      "The number of blocks from\ntemporary tables and indexes that have been modified by the operation.\nThis\nincludes\nvalues for child operations and is a\ntotal\nvalue (i.e. not a per-loop average).",
    "Local Written Blocks":
      "The number of blocks from\ntemporary tables and indexes that were evicted from the cache.\nThis\nincludes\nvalues for child operations and is a\ntotal\nvalue (i.e. not a per-loop average).",
    "Temp Read Blocks":
      "The number of blocks read from short-term data used to calculate hashes, sorts, Materialize operations, and similar.\nThis\nincludes\nvalues for child operations and is a\ntotal\nvalue (i.e. not a per-loop average).\nYour settings of\nwork_mem\nand\nhash_mem_multiplier\ndetermine how much memory is available to Postgres per operation.",
    "Temp Written Blocks":
      "The number of blocks from short-term data (used to calculate operations like hashes, sorts, and materializes) that were evicted from the cache.\nThis\nincludes\nvalues for child operations and is a\ntotal\nvalue (i.e. not a per-loop average).\nYour settings of\nwork_mem\nand\nhash_mem_multiplier\ndetermine how much memory is available to Postgres per operation.",
    "Shared I/O Read Time":
      "The time spent reading data from tables and indexes, in\nmilliseconds\n.\nThis\nincludes\nvalues for child operations and is a total value (not a per-loop average).\nRequires\ntrack_io_timing\nand\nBUFFERS\nto be on.\nIn the latest version, the text format of explain displays this as\nI/O Timings: shared read\nIn PostgreSQL 15 and 16 it shows as a combined metric\nI/O Timings: shared/local read\nGetting timing information has an overhead, due to checking the system clock. You can use\npg_test_timing\nto measure this for your system.",
    "Shared I/O Write Time":
      "The time spent writing data for tables and indexes, in\nmilliseconds\n.\nThis\nincludes\nvalues for child operations and is a total value (not a per-loop average).\nRequires\ntrack_io_timing\nand\nBUFFERS\nto be on.\nIn the latest version, the text format of explain displays this as\nI/O Timings: shared write\nIn PostgreSQL 15 and 16 it shows as a combined metric\nI/O Timings: shared/local write\nGetting timing information has an overhead, due to checking the system clock. You can use\npg_test_timing\nto measure this for your system.",
    "Local I/O Read Time":
      "The time spent reading local data (e.g. from temporary tables and indexes), in\nmilliseconds\n.\nThis\nincludes\nvalues for child operations and is a total value (i.e. not a per-loop average).\nThis was added as a separate field in PostgreSQL 17, and requires both\ntrack_io_timing\nand\nBUFFERS\n.\nIn the default text format, this will show as\nI/O Timings: local read\nIn versions 15 and 16 it is available as a combined metric as\nshared/local\nGetting timing information has an overhead, due to checking the system clock. You can use\npg_test_timing\nto measure this for your system.",
    "Local I/O Write Time":
      "The time spent writing local data (e.g. for temporary tables and indexes), in\nmilliseconds\n.\nThis\nincludes\nvalues for child operations and is a total value (i.e. not a per-loop average).\nThis was added as a separate field in PostgreSQL 17, and requires both\ntrack_io_timing\nand\nBUFFERS\n.\nIn the default text format, this will show as\nI/O Timings: local write\nIn versions 15 and 16 it is available as a combined metric as\nshared/local\nGetting timing information has an overhead, due to checking the system clock. You can use\npg_test_timing\nto measure this for your system.",
    "Temp I/O Read Time":
      "The time spent reading short-term data, in\nmilliseconds\n(for example during sort and hash operations that were not done in memory).\nThis\nincludes\nvalues for child operations and is a total value (i.e. not a per-loop average).\nThis was added in PostgreSQL 15, and requires both\ntrack_io_timing\nand\nBUFFERS\n.\nIn the text format of explain, this shows as\nI/O Timings: temp read\nGetting timing information has an overhead, due to checking the system clock. You can use\npg_test_timing\nto measure this for your system.",
    "Temp I/O Write Time":
      "The time spent writing short-term data, in\nmilliseconds\n(for example during sort and hash operations that were not done in memory).\nThis\nincludes\nvalues for child operations and is a total value (i.e. not a per-loop average).\nThis was added in PostgreSQL 15, and requires both\ntrack_io_timing\nand\nBUFFERS\n.\nIn the text format of explain, this shows as\nI/O Timings: temp write\nGetting timing information has an overhead, due to checking the system clock. You can use\npg_test_timing\nto measure this for your system.",
  },
  "Hash Join": {
    "Parent Relationship":
      "A guide as to why this operation needs to be run in order to facilitate the parent operation. There are six different possibilities:\nOuter\n: The value you’ll see most often. It means “take in the rows from this operation as input, process them and pass them on”.\nInner\n: Only ever seen on the second child of join operations, and is always seen there. This is the “inner” part of the loop — for each outer row, we look up its match using this operation.\nMember\n: Used for all children of Append and ModifyTable nodes, and on bitmap processing nodes like BitmapAnd and BitmapOr operations.\nInitPlan\n: Used for calculations performed before the query can start, eg a constant referred to in the query or the result of a CTE scan.\nSubquery\n: The child is a subquery of the parent operation. Since Postgres always uses subquery scans to feed subquery data to parent queries, only ever appears on the children of subquery scans.\nSubPlan\n: Like a Subquery, represents a new query, but used when a subquery scan is not necessary.",
    "Parallel Aware":
      "Whether or not the operation will be run in a special mode to support parallelism. Some operations need to be aware that they are running in parallel, for example sequential scans need to know they only need to scan a smaller proportion of the table. Other operations can be run on several threads without each one having any knowledge of the others.",
    "Join Type":
      "Which type of join was performed: Inner, Full, Left, Right, Semi, or Anti.\nIn text format plans, you can assume it is an inner join unless stated otherwise.",
    "Startup Cost":
      "The estimated cost of returning the first row.\nThis is in an arbitrary unit, with the aim of being correlated to the startup time.",
    "Total Cost":
      "The estimated cost of returning all rows. This is in an arbitrary unit, with the aim of being correlated to the total time.\nThe Postgres query planner often has several ways it could resolve the same query. It calculates costs — which are hopefully correlated with the time it would take — for potential plans, and then picks the one with the lowest cost. It’s worth bearing in mind that the costs are unit-free — they’re not designed to convert into time, or disk reads. They’re just supposed to be bigger for slower operations, and smaller for faster ones.\nIf the planner thinks it can finish early due to a parent Limit operation, the total cost of the Limit operation will reflect this, but the total cost of its child operations will not.",
    "Plan Rows":
      "The number of rows,\nper-loop\n, that the planner expects to be returned by the operation.\nPoor row estimates can lead to suboptimal query planning. They can often be improved by running\nANALYZE\n(not the EXPLAIN parameter), by increasing statistics, or by allowing Postgres to understand correlation between columns using multivariate statistics.\nIf the planner thinks it can finish early due to a Limit operation, the plan rows of the Limit operation will reflect this, but the plan rows of its child operations will not.",
    "Plan Width":
      "The\nestimated\naverage size of the rows produced by the operation, in\nbytes\n.",
    "Actual Startup Time":
      "The amount of time, in\nmilliseconds\n, it takes to get the first row out of the operation.\nSometimes, this is very close to the setup time — for example on a sequential scan which returns all the rows in a table.\nOther times, though, it’s more or less the total time. For example, in order to return the first row of a sort, you have to sort all of the rows to work out which one comes first.",
    "Actual Total Time":
      "The actual amount of time in milliseconds spent on this operation\nand all of its children\n. It’s a\nper-loop average\n, rounded to the nearest thousandth of a millisecond.\nWorking out individual operation timings, especially where CTEs and SubPlans are concerned, can be tricky. This is one of the main reasons we decided to build\npgMustard\n.",
    "Actual Rows":
      "The number of rows returned by the operation\nper loop\n.\nThe important thing to notice about this is that it’s an average of all the loops executed, rounded to the nearest integer. This means that while “Actual Loops” multiplied by “Actual Rows” is a pretty good approximation for total number of rows returned most of the time, it can be off by as much as half of the number of loops. Usually it’s just slightly confusing as you see a row or two appear or disappear between operations, but on operations with lots of loops there is potential for serious miscalculation.\nPoor row estimates, where Actual Rows differs substantially from Plan Rows, can lead to suboptimal query planning. Estimates can often be improved by running\nANALYZE\n(not the EXPLAIN parameter), by increasing statistics, or by allowing Postgres to understand correlation between columns using multivariate statistics.",
    "Actual Loops":
      "The number of times the operation is executed. For a lot of operations it will have a value of one, but when it is not, there are three different cases:\nSome operations can be executed more than once. For example, “Nested Loops” run their “Inner” child once for every row returned by their “Outer” child.\nWhen an operation that would normally only consist of one loop is split across multiple threads, each partial operation is counted as a Loop.\nThe number of loops can be zero when an operation doesn’t need to be executed at all. For example if a table read is planned to provide candidates for an inner join, but there turns out to be no rows on the other side of the join, the operation can be effectively eliminated.",
    Output:
      "A list of the columns returned by the operation.\nThis is only shown when VERBOSE is on.",
    "Inner Unique":
      "This is\ntrue\nif\nno more than one inner row could match any given outer row. This allows the executor to skip searching for additional matches.",
    "Hash Cond":
      "The condition used to match rows from the outer plan to the inner plan in a Hash Join.",
    "Join Filter":
      "A filter that can happen before the join, allowing Postgres to avoid looking up the rows and filtering them out afterwards.",
    "Rows Removed by Join Filter":
      "The number of rows removed by the join filter.\nIf a high proportion of rows are being removed, you may want to investigate whether a (more) selective index could help.",
    Filter:
      "When present, this is a filter used to remove rows.\nThe important thing to note is that this is a filter in the traditional sense: these rows are read in (either from a data source or another operation in the plan), inspected, and then approved or removed based on the filter.\nIf a high proportion of rows are being removed by the Filter, you may want to investigate whether a (more) selective index could help.\nIf you notice a lot of rows being filtered late in a query plan, this might be due to an operation (like a GROUP BY or SORT) using more columns than are necessary, requiring joins to take place before rows can be discarded. It is also sometimes a result of unnecessary or ill-advised uses of DISTINCT.",
    "Rows Removed by Filter":
      "The number of rows removed by the\nFilter\n. This is a\nper-loop average\n, rounded to the nearest integer.\nIf a high proportion of rows are being removed, you may want to investigate whether a (more) selective index could help.",
    "Shared Hit Blocks":
      "The number of blocks from indexes/tables that were found in the Postgres buffer cache.\nThis\nincludes\nvalues for child operations and is a\ntotal\nvalue (i.e. not a per-loop average).\nOnce you have subtracted child operation values, the proportion of shared hit to shared read blocks is an interesting measure of cache performance.\nThe ratio of shared blocks (hit plus read) to rows processed (including any filtered out) is also interesting: a high ratio means Postgres is reading a lot of data for what it is doing, which can be a sign of bloat.",
    "Shared Read Blocks":
      "The number of blocks from tables/indexes that were read from disk (or the OS cache).\nThis\nincludes\nvalues for child operations and is a\ntotal\nvalue (i.e. not per-loop).\nOnce you have subtracted child operation values, the proportion of shared hit to shared read blocks is an interesting measure of cache performance.\nThe ratio of shared blocks (hit plus read) to rows processed (including any filtered out) is also interesting: a high ratio means Postgres is reading a lot of data for what it is doing, which can be a sign of bloat.",
    "Shared Dirtied Blocks":
      "The number of blocks from tables/indexes that were modified by the operation.\nThis\nincludes\nvalues for child operations and is a\ntotal\nvalue (i.e. not per-loop).\nInterestingly, a SELECT query can report shared dirtied blocks when setting hint bits on recently-committed rows, or pruning old row versions. While somewhat surprising, both of these are perfectly normal and healthy.",
    "Shared Written Blocks":
      "The number of blocks from tables/indexes that were evicted from the cache.\nThis\nincludes\nvalues for child operations and is a\ntotal\nvalue (i.e. not a per-loop average).",
    "Local Hit Blocks":
      "The number of blocks from temporary tables and indexes that were found in the cache.\nThis\nincludes\nvalues for child operations and is a\ntotal\nvalue (not a per-loop average).",
    "Local Read Blocks":
      "The number of blocks read from\ntemporary tables and indexes that were not found in the Postgres cache (read from disk or the OS cache).\nThis\nincludes\nvalues for child operations and is a\ntotal\nvalue (not a per-loop average).",
    "Local Dirtied Blocks":
      "The number of blocks from\ntemporary tables and indexes that have been modified by the operation.\nThis\nincludes\nvalues for child operations and is a\ntotal\nvalue (i.e. not a per-loop average).",
    "Local Written Blocks":
      "The number of blocks from\ntemporary tables and indexes that were evicted from the cache.\nThis\nincludes\nvalues for child operations and is a\ntotal\nvalue (i.e. not a per-loop average).",
    "Temp Read Blocks":
      "The number of blocks read from short-term data used to calculate hashes, sorts, Materialize operations, and similar.\nThis\nincludes\nvalues for child operations and is a\ntotal\nvalue (i.e. not a per-loop average).\nYour settings of\nwork_mem\nand\nhash_mem_multiplier\ndetermine how much memory is available to Postgres per operation.",
    "Temp Written Blocks":
      "The number of blocks from short-term data (used to calculate operations like hashes, sorts, and materializes) that were evicted from the cache.\nThis\nincludes\nvalues for child operations and is a\ntotal\nvalue (i.e. not a per-loop average).\nYour settings of\nwork_mem\nand\nhash_mem_multiplier\ndetermine how much memory is available to Postgres per operation.",
    "Shared I/O Read Time":
      "The time spent reading data from tables and indexes, in\nmilliseconds\n.\nThis\nincludes\nvalues for child operations and is a total value (not a per-loop average).\nRequires\ntrack_io_timing\nand\nBUFFERS\nto be on.\nIn the latest version, the text format of explain displays this as\nI/O Timings: shared read\nIn PostgreSQL 15 and 16 it shows as a combined metric\nI/O Timings: shared/local read\nGetting timing information has an overhead, due to checking the system clock. You can use\npg_test_timing\nto measure this for your system.",
    "Shared I/O Write Time":
      "The time spent writing data for tables and indexes, in\nmilliseconds\n.\nThis\nincludes\nvalues for child operations and is a total value (not a per-loop average).\nRequires\ntrack_io_timing\nand\nBUFFERS\nto be on.\nIn the latest version, the text format of explain displays this as\nI/O Timings: shared write\nIn PostgreSQL 15 and 16 it shows as a combined metric\nI/O Timings: shared/local write\nGetting timing information has an overhead, due to checking the system clock. You can use\npg_test_timing\nto measure this for your system.",
    "Local I/O Read Time":
      "The time spent reading local data (e.g. from temporary tables and indexes), in\nmilliseconds\n.\nThis\nincludes\nvalues for child operations and is a total value (i.e. not a per-loop average).\nThis was added as a separate field in PostgreSQL 17, and requires both\ntrack_io_timing\nand\nBUFFERS\n.\nIn the default text format, this will show as\nI/O Timings: local read\nIn versions 15 and 16 it is available as a combined metric as\nshared/local\nGetting timing information has an overhead, due to checking the system clock. You can use\npg_test_timing\nto measure this for your system.",
    "Local I/O Write Time":
      "The time spent writing local data (e.g. for temporary tables and indexes), in\nmilliseconds\n.\nThis\nincludes\nvalues for child operations and is a total value (i.e. not a per-loop average).\nThis was added as a separate field in PostgreSQL 17, and requires both\ntrack_io_timing\nand\nBUFFERS\n.\nIn the default text format, this will show as\nI/O Timings: local write\nIn versions 15 and 16 it is available as a combined metric as\nshared/local\nGetting timing information has an overhead, due to checking the system clock. You can use\npg_test_timing\nto measure this for your system.",
    "Temp I/O Read Time":
      "The time spent reading short-term data, in\nmilliseconds\n(for example during sort and hash operations that were not done in memory).\nThis\nincludes\nvalues for child operations and is a total value (i.e. not a per-loop average).\nThis was added in PostgreSQL 15, and requires both\ntrack_io_timing\nand\nBUFFERS\n.\nIn the text format of explain, this shows as\nI/O Timings: temp read\nGetting timing information has an overhead, due to checking the system clock. You can use\npg_test_timing\nto measure this for your system.",
    "Temp I/O Write Time":
      "The time spent writing short-term data, in\nmilliseconds\n(for example during sort and hash operations that were not done in memory).\nThis\nincludes\nvalues for child operations and is a total value (i.e. not a per-loop average).\nThis was added in PostgreSQL 15, and requires both\ntrack_io_timing\nand\nBUFFERS\n.\nIn the text format of explain, this shows as\nI/O Timings: temp write\nGetting timing information has an overhead, due to checking the system clock. You can use\npg_test_timing\nto measure this for your system.",
  },
  "Merge Join": {
    "Parent Relationship":
      "A guide as to why this operation needs to be run in order to facilitate the parent operation. There are six different possibilities:\nOuter\n: The value you’ll see most often. It means “take in the rows from this operation as input, process them and pass them on”.\nInner\n: Only ever seen on the second child of join operations, and is always seen there. This is the “inner” part of the loop — for each outer row, we look up its match using this operation.\nMember\n: Used for all children of Append and ModifyTable nodes, and on bitmap processing nodes like BitmapAnd and BitmapOr operations.\nInitPlan\n: Used for calculations performed before the query can start, eg a constant referred to in the query or the result of a CTE scan.\nSubquery\n: The child is a subquery of the parent operation. Since Postgres always uses subquery scans to feed subquery data to parent queries, only ever appears on the children of subquery scans.\nSubPlan\n: Like a Subquery, represents a new query, but used when a subquery scan is not necessary.",
    "Parallel Aware":
      "Whether or not the operation will be run in a special mode to support parallelism. Some operations need to be aware that they are running in parallel, for example sequential scans need to know they only need to scan a smaller proportion of the table. Other operations can be run on several threads without each one having any knowledge of the others.",
    "Join Type":
      "Which type of join was performed: Inner, Full, Left, Right, Semi, or Anti.\nIn text format plans, you can assume it is an inner join unless stated otherwise.",
    "Startup Cost":
      "The estimated cost of returning the first row.\nThis is in an arbitrary unit, with the aim of being correlated to the startup time.",
    "Total Cost":
      "The estimated cost of returning all rows. This is in an arbitrary unit, with the aim of being correlated to the total time.\nThe Postgres query planner often has several ways it could resolve the same query. It calculates costs — which are hopefully correlated with the time it would take — for potential plans, and then picks the one with the lowest cost. It’s worth bearing in mind that the costs are unit-free — they’re not designed to convert into time, or disk reads. They’re just supposed to be bigger for slower operations, and smaller for faster ones.\nIf the planner thinks it can finish early due to a parent Limit operation, the total cost of the Limit operation will reflect this, but the total cost of its child operations will not.",
    "Plan Rows":
      "The number of rows,\nper-loop\n, that the planner expects to be returned by the operation.\nPoor row estimates can lead to suboptimal query planning. They can often be improved by running\nANALYZE\n(not the EXPLAIN parameter), by increasing statistics, or by allowing Postgres to understand correlation between columns using multivariate statistics.\nIf the planner thinks it can finish early due to a Limit operation, the plan rows of the Limit operation will reflect this, but the plan rows of its child operations will not.",
    "Plan Width":
      "The\nestimated\naverage size of the rows produced by the operation, in\nbytes\n.",
    "Actual Startup Time":
      "The amount of time, in\nmilliseconds\n, it takes to get the first row out of the operation.\nSometimes, this is very close to the setup time — for example on a sequential scan which returns all the rows in a table.\nOther times, though, it’s more or less the total time. For example, in order to return the first row of a sort, you have to sort all of the rows to work out which one comes first.",
    "Actual Total Time":
      "The actual amount of time in milliseconds spent on this operation\nand all of its children\n. It’s a\nper-loop average\n, rounded to the nearest thousandth of a millisecond.\nWorking out individual operation timings, especially where CTEs and SubPlans are concerned, can be tricky. This is one of the main reasons we decided to build\npgMustard\n.",
    "Actual Rows":
      "The number of rows returned by the operation\nper loop\n.\nThe important thing to notice about this is that it’s an average of all the loops executed, rounded to the nearest integer. This means that while “Actual Loops” multiplied by “Actual Rows” is a pretty good approximation for total number of rows returned most of the time, it can be off by as much as half of the number of loops. Usually it’s just slightly confusing as you see a row or two appear or disappear between operations, but on operations with lots of loops there is potential for serious miscalculation.\nPoor row estimates, where Actual Rows differs substantially from Plan Rows, can lead to suboptimal query planning. Estimates can often be improved by running\nANALYZE\n(not the EXPLAIN parameter), by increasing statistics, or by allowing Postgres to understand correlation between columns using multivariate statistics.",
    "Actual Loops":
      "The number of times the operation is executed. For a lot of operations it will have a value of one, but when it is not, there are three different cases:\nSome operations can be executed more than once. For example, “Nested Loops” run their “Inner” child once for every row returned by their “Outer” child.\nWhen an operation that would normally only consist of one loop is split across multiple threads, each partial operation is counted as a Loop.\nThe number of loops can be zero when an operation doesn’t need to be executed at all. For example if a table read is planned to provide candidates for an inner join, but there turns out to be no rows on the other side of the join, the operation can be effectively eliminated.",
    Output:
      "A list of the columns returned by the operation.\nThis is only shown when VERBOSE is on.",
    "Inner Unique":
      "This is\ntrue\nif\nno more than one inner row could match any given outer row. This allows the executor to skip searching for additional matches.",
    "Merge Cond":
      "The condition used to match rows from the outer plan to the inner plan in a Merge Join.",
    "Join Filter":
      "A filter that can happen before the join, allowing Postgres to avoid looking up the rows and filtering them out afterwards.",
    "Rows Removed by Join Filter":
      "The number of rows removed by the join filter.\nIf a high proportion of rows are being removed, you may want to investigate whether a (more) selective index could help.",
    Filter:
      "When present, this is a filter used to remove rows.\nThe important thing to note is that this is a filter in the traditional sense: these rows are read in (either from a data source or another operation in the plan), inspected, and then approved or removed based on the filter.\nIf a high proportion of rows are being removed by the Filter, you may want to investigate whether a (more) selective index could help.\nIf you notice a lot of rows being filtered late in a query plan, this might be due to an operation (like a GROUP BY or SORT) using more columns than are necessary, requiring joins to take place before rows can be discarded. It is also sometimes a result of unnecessary or ill-advised uses of DISTINCT.",
    "Rows Removed by Filter":
      "The number of rows removed by the\nFilter\n. This is a\nper-loop average\n, rounded to the nearest integer.\nIf a high proportion of rows are being removed, you may want to investigate whether a (more) selective index could help.",
    "Shared Hit Blocks":
      "The number of blocks from indexes/tables that were found in the Postgres buffer cache.\nThis\nincludes\nvalues for child operations and is a\ntotal\nvalue (i.e. not a per-loop average).\nOnce you have subtracted child operation values, the proportion of shared hit to shared read blocks is an interesting measure of cache performance.\nThe ratio of shared blocks (hit plus read) to rows processed (including any filtered out) is also interesting: a high ratio means Postgres is reading a lot of data for what it is doing, which can be a sign of bloat.",
    "Shared Read Blocks":
      "The number of blocks from tables/indexes that were read from disk (or the OS cache).\nThis\nincludes\nvalues for child operations and is a\ntotal\nvalue (i.e. not per-loop).\nOnce you have subtracted child operation values, the proportion of shared hit to shared read blocks is an interesting measure of cache performance.\nThe ratio of shared blocks (hit plus read) to rows processed (including any filtered out) is also interesting: a high ratio means Postgres is reading a lot of data for what it is doing, which can be a sign of bloat.",
    "Shared Dirtied Blocks":
      "The number of blocks from tables/indexes that were modified by the operation.\nThis\nincludes\nvalues for child operations and is a\ntotal\nvalue (i.e. not per-loop).\nInterestingly, a SELECT query can report shared dirtied blocks when setting hint bits on recently-committed rows, or pruning old row versions. While somewhat surprising, both of these are perfectly normal and healthy.",
    "Shared Written Blocks":
      "The number of blocks from tables/indexes that were evicted from the cache.\nThis\nincludes\nvalues for child operations and is a\ntotal\nvalue (i.e. not a per-loop average).",
    "Local Hit Blocks":
      "The number of blocks from temporary tables and indexes that were found in the cache.\nThis\nincludes\nvalues for child operations and is a\ntotal\nvalue (not a per-loop average).",
    "Local Read Blocks":
      "The number of blocks read from\ntemporary tables and indexes that were not found in the Postgres cache (read from disk or the OS cache).\nThis\nincludes\nvalues for child operations and is a\ntotal\nvalue (not a per-loop average).",
    "Local Dirtied Blocks":
      "The number of blocks from\ntemporary tables and indexes that have been modified by the operation.\nThis\nincludes\nvalues for child operations and is a\ntotal\nvalue (i.e. not a per-loop average).",
    "Local Written Blocks":
      "The number of blocks from\ntemporary tables and indexes that were evicted from the cache.\nThis\nincludes\nvalues for child operations and is a\ntotal\nvalue (i.e. not a per-loop average).",
    "Temp Read Blocks":
      "The number of blocks read from short-term data used to calculate hashes, sorts, Materialize operations, and similar.\nThis\nincludes\nvalues for child operations and is a\ntotal\nvalue (i.e. not a per-loop average).\nYour settings of\nwork_mem\nand\nhash_mem_multiplier\ndetermine how much memory is available to Postgres per operation.",
    "Temp Written Blocks":
      "The number of blocks from short-term data (used to calculate operations like hashes, sorts, and materializes) that were evicted from the cache.\nThis\nincludes\nvalues for child operations and is a\ntotal\nvalue (i.e. not a per-loop average).\nYour settings of\nwork_mem\nand\nhash_mem_multiplier\ndetermine how much memory is available to Postgres per operation.",
    "Shared I/O Read Time":
      "The time spent reading data from tables and indexes, in\nmilliseconds\n.\nThis\nincludes\nvalues for child operations and is a total value (not a per-loop average).\nRequires\ntrack_io_timing\nand\nBUFFERS\nto be on.\nIn the latest version, the text format of explain displays this as\nI/O Timings: shared read\nIn PostgreSQL 15 and 16 it shows as a combined metric\nI/O Timings: shared/local read\nGetting timing information has an overhead, due to checking the system clock. You can use\npg_test_timing\nto measure this for your system.",
    "Shared I/O Write Time":
      "The time spent writing data for tables and indexes, in\nmilliseconds\n.\nThis\nincludes\nvalues for child operations and is a total value (not a per-loop average).\nRequires\ntrack_io_timing\nand\nBUFFERS\nto be on.\nIn the latest version, the text format of explain displays this as\nI/O Timings: shared write\nIn PostgreSQL 15 and 16 it shows as a combined metric\nI/O Timings: shared/local write\nGetting timing information has an overhead, due to checking the system clock. You can use\npg_test_timing\nto measure this for your system.",
    "Local I/O Read Time":
      "The time spent reading local data (e.g. from temporary tables and indexes), in\nmilliseconds\n.\nThis\nincludes\nvalues for child operations and is a total value (i.e. not a per-loop average).\nThis was added as a separate field in PostgreSQL 17, and requires both\ntrack_io_timing\nand\nBUFFERS\n.\nIn the default text format, this will show as\nI/O Timings: local read\nIn versions 15 and 16 it is available as a combined metric as\nshared/local\nGetting timing information has an overhead, due to checking the system clock. You can use\npg_test_timing\nto measure this for your system.",
    "Local I/O Write Time":
      "The time spent writing local data (e.g. for temporary tables and indexes), in\nmilliseconds\n.\nThis\nincludes\nvalues for child operations and is a total value (i.e. not a per-loop average).\nThis was added as a separate field in PostgreSQL 17, and requires both\ntrack_io_timing\nand\nBUFFERS\n.\nIn the default text format, this will show as\nI/O Timings: local write\nIn versions 15 and 16 it is available as a combined metric as\nshared/local\nGetting timing information has an overhead, due to checking the system clock. You can use\npg_test_timing\nto measure this for your system.",
    "Temp I/O Read Time":
      "The time spent reading short-term data, in\nmilliseconds\n(for example during sort and hash operations that were not done in memory).\nThis\nincludes\nvalues for child operations and is a total value (i.e. not a per-loop average).\nThis was added in PostgreSQL 15, and requires both\ntrack_io_timing\nand\nBUFFERS\n.\nIn the text format of explain, this shows as\nI/O Timings: temp read\nGetting timing information has an overhead, due to checking the system clock. You can use\npg_test_timing\nto measure this for your system.",
    "Temp I/O Write Time":
      "The time spent writing short-term data, in\nmilliseconds\n(for example during sort and hash operations that were not done in memory).\nThis\nincludes\nvalues for child operations and is a total value (i.e. not a per-loop average).\nThis was added in PostgreSQL 15, and requires both\ntrack_io_timing\nand\nBUFFERS\n.\nIn the text format of explain, this shows as\nI/O Timings: temp write\nGetting timing information has an overhead, due to checking the system clock. You can use\npg_test_timing\nto measure this for your system.",
  },
  Aggregate: {
    Strategy:
      "Which strategy of aggregation was performed: Plain, Hashed, Sorted, or Mixed.\nIn non-text format query plans, this lets you see whether Postgres is doing a HashAggregate (Hashed), a GroupAggregate (Sorted), or a MixedAggregate (Mixed).",
    "Partial Mode":
      "If this is\nSimple\n, the operation happens in one step.\nOtherwise,\nPartial\noperations do chunks of the operation in parallel, and a separate\nFinalize\noperation joins the different parts together.\nFrom the docs: “Aggregate functions which support Partial Mode are eligible to participate in various optimizations, such as parallel aggregation.”\n[source]",
    "Parent Relationship":
      "A guide as to why this operation needs to be run in order to facilitate the parent operation. There are six different possibilities:\nOuter\n: The value you’ll see most often. It means “take in the rows from this operation as input, process them and pass them on”.\nInner\n: Only ever seen on the second child of join operations, and is always seen there. This is the “inner” part of the loop — for each outer row, we look up its match using this operation.\nMember\n: Used for all children of Append and ModifyTable nodes, and on bitmap processing nodes like BitmapAnd and BitmapOr operations.\nInitPlan\n: Used for calculations performed before the query can start, eg a constant referred to in the query or the result of a CTE scan.\nSubquery\n: The child is a subquery of the parent operation. Since Postgres always uses subquery scans to feed subquery data to parent queries, only ever appears on the children of subquery scans.\nSubPlan\n: Like a Subquery, represents a new query, but used when a subquery scan is not necessary.",
    "Parallel Aware":
      "Whether or not the operation will be run in a special mode to support parallelism. Some operations need to be aware that they are running in parallel, for example sequential scans need to know they only need to scan a smaller proportion of the table. Other operations can be run on several threads without each one having any knowledge of the others.",
    "Startup Cost":
      "The estimated cost of returning the first row.\nThis is in an arbitrary unit, with the aim of being correlated to the startup time.",
    "Total Cost":
      "The estimated cost of returning all rows. This is in an arbitrary unit, with the aim of being correlated to the total time.\nThe Postgres query planner often has several ways it could resolve the same query. It calculates costs — which are hopefully correlated with the time it would take — for potential plans, and then picks the one with the lowest cost. It’s worth bearing in mind that the costs are unit-free — they’re not designed to convert into time, or disk reads. They’re just supposed to be bigger for slower operations, and smaller for faster ones.\nIf the planner thinks it can finish early due to a parent Limit operation, the total cost of the Limit operation will reflect this, but the total cost of its child operations will not.",
    "Plan Rows":
      "The number of rows,\nper-loop\n, that the planner expects to be returned by the operation.\nPoor row estimates can lead to suboptimal query planning. They can often be improved by running\nANALYZE\n(not the EXPLAIN parameter), by increasing statistics, or by allowing Postgres to understand correlation between columns using multivariate statistics.\nIf the planner thinks it can finish early due to a Limit operation, the plan rows of the Limit operation will reflect this, but the plan rows of its child operations will not.",
    "Plan Width":
      "The\nestimated\naverage size of the rows produced by the operation, in\nbytes\n.",
    "Actual Startup Time":
      "The amount of time, in\nmilliseconds\n, it takes to get the first row out of the operation.\nSometimes, this is very close to the setup time — for example on a sequential scan which returns all the rows in a table.\nOther times, though, it’s more or less the total time. For example, in order to return the first row of a sort, you have to sort all of the rows to work out which one comes first.",
    "Actual Total Time":
      "The actual amount of time in milliseconds spent on this operation\nand all of its children\n. It’s a\nper-loop average\n, rounded to the nearest thousandth of a millisecond.\nWorking out individual operation timings, especially where CTEs and SubPlans are concerned, can be tricky. This is one of the main reasons we decided to build\npgMustard\n.",
    "Actual Rows":
      "The number of rows returned by the operation\nper loop\n.\nThe important thing to notice about this is that it’s an average of all the loops executed, rounded to the nearest integer. This means that while “Actual Loops” multiplied by “Actual Rows” is a pretty good approximation for total number of rows returned most of the time, it can be off by as much as half of the number of loops. Usually it’s just slightly confusing as you see a row or two appear or disappear between operations, but on operations with lots of loops there is potential for serious miscalculation.\nPoor row estimates, where Actual Rows differs substantially from Plan Rows, can lead to suboptimal query planning. Estimates can often be improved by running\nANALYZE\n(not the EXPLAIN parameter), by increasing statistics, or by allowing Postgres to understand correlation between columns using multivariate statistics.",
    "Actual Loops":
      "The number of times the operation is executed. For a lot of operations it will have a value of one, but when it is not, there are three different cases:\nSome operations can be executed more than once. For example, “Nested Loops” run their “Inner” child once for every row returned by their “Outer” child.\nWhen an operation that would normally only consist of one loop is split across multiple threads, each partial operation is counted as a Loop.\nThe number of loops can be zero when an operation doesn’t need to be executed at all. For example if a table read is planned to provide candidates for an inner join, but there turns out to be no rows on the other side of the join, the operation can be effectively eliminated.",
    Output:
      "A list of the columns returned by the operation.\nThis is only shown when VERBOSE is on.",
    "Shared Hit Blocks":
      "The number of blocks from indexes/tables that were found in the Postgres buffer cache.\nThis\nincludes\nvalues for child operations and is a\ntotal\nvalue (i.e. not a per-loop average).\nOnce you have subtracted child operation values, the proportion of shared hit to shared read blocks is an interesting measure of cache performance.\nThe ratio of shared blocks (hit plus read) to rows processed (including any filtered out) is also interesting: a high ratio means Postgres is reading a lot of data for what it is doing, which can be a sign of bloat.",
    "Shared Read Blocks":
      "The number of blocks from tables/indexes that were read from disk (or the OS cache).\nThis\nincludes\nvalues for child operations and is a\ntotal\nvalue (i.e. not per-loop).\nOnce you have subtracted child operation values, the proportion of shared hit to shared read blocks is an interesting measure of cache performance.\nThe ratio of shared blocks (hit plus read) to rows processed (including any filtered out) is also interesting: a high ratio means Postgres is reading a lot of data for what it is doing, which can be a sign of bloat.",
    "Shared Dirtied Blocks":
      "The number of blocks from tables/indexes that were modified by the operation.\nThis\nincludes\nvalues for child operations and is a\ntotal\nvalue (i.e. not per-loop).\nInterestingly, a SELECT query can report shared dirtied blocks when setting hint bits on recently-committed rows, or pruning old row versions. While somewhat surprising, both of these are perfectly normal and healthy.",
    "Shared Written Blocks":
      "The number of blocks from tables/indexes that were evicted from the cache.\nThis\nincludes\nvalues for child operations and is a\ntotal\nvalue (i.e. not a per-loop average).",
    "Local Hit Blocks":
      "The number of blocks from temporary tables and indexes that were found in the cache.\nThis\nincludes\nvalues for child operations and is a\ntotal\nvalue (not a per-loop average).",
    "Local Read Blocks":
      "The number of blocks read from\ntemporary tables and indexes that were not found in the Postgres cache (read from disk or the OS cache).\nThis\nincludes\nvalues for child operations and is a\ntotal\nvalue (not a per-loop average).",
    "Local Dirtied Blocks":
      "The number of blocks from\ntemporary tables and indexes that have been modified by the operation.\nThis\nincludes\nvalues for child operations and is a\ntotal\nvalue (i.e. not a per-loop average).",
    "Local Written Blocks":
      "The number of blocks from\ntemporary tables and indexes that were evicted from the cache.\nThis\nincludes\nvalues for child operations and is a\ntotal\nvalue (i.e. not a per-loop average).",
    "Temp Read Blocks":
      "The number of blocks read from short-term data used to calculate hashes, sorts, Materialize operations, and similar.\nThis\nincludes\nvalues for child operations and is a\ntotal\nvalue (i.e. not a per-loop average).\nYour settings of\nwork_mem\nand\nhash_mem_multiplier\ndetermine how much memory is available to Postgres per operation.",
    "Temp Written Blocks":
      "The number of blocks from short-term data (used to calculate operations like hashes, sorts, and materializes) that were evicted from the cache.\nThis\nincludes\nvalues for child operations and is a\ntotal\nvalue (i.e. not a per-loop average).\nYour settings of\nwork_mem\nand\nhash_mem_multiplier\ndetermine how much memory is available to Postgres per operation.",
    "Shared I/O Read Time":
      "The time spent reading data from tables and indexes, in\nmilliseconds\n.\nThis\nincludes\nvalues for child operations and is a total value (not a per-loop average).\nRequires\ntrack_io_timing\nand\nBUFFERS\nto be on.\nIn the latest version, the text format of explain displays this as\nI/O Timings: shared read\nIn PostgreSQL 15 and 16 it shows as a combined metric\nI/O Timings: shared/local read\nGetting timing information has an overhead, due to checking the system clock. You can use\npg_test_timing\nto measure this for your system.",
    "Shared I/O Write Time":
      "The time spent writing data for tables and indexes, in\nmilliseconds\n.\nThis\nincludes\nvalues for child operations and is a total value (not a per-loop average).\nRequires\ntrack_io_timing\nand\nBUFFERS\nto be on.\nIn the latest version, the text format of explain displays this as\nI/O Timings: shared write\nIn PostgreSQL 15 and 16 it shows as a combined metric\nI/O Timings: shared/local write\nGetting timing information has an overhead, due to checking the system clock. You can use\npg_test_timing\nto measure this for your system.",
    "Local I/O Read Time":
      "The time spent reading local data (e.g. from temporary tables and indexes), in\nmilliseconds\n.\nThis\nincludes\nvalues for child operations and is a total value (i.e. not a per-loop average).\nThis was added as a separate field in PostgreSQL 17, and requires both\ntrack_io_timing\nand\nBUFFERS\n.\nIn the default text format, this will show as\nI/O Timings: local read\nIn versions 15 and 16 it is available as a combined metric as\nshared/local\nGetting timing information has an overhead, due to checking the system clock. You can use\npg_test_timing\nto measure this for your system.",
    "Local I/O Write Time":
      "The time spent writing local data (e.g. for temporary tables and indexes), in\nmilliseconds\n.\nThis\nincludes\nvalues for child operations and is a total value (i.e. not a per-loop average).\nThis was added as a separate field in PostgreSQL 17, and requires both\ntrack_io_timing\nand\nBUFFERS\n.\nIn the default text format, this will show as\nI/O Timings: local write\nIn versions 15 and 16 it is available as a combined metric as\nshared/local\nGetting timing information has an overhead, due to checking the system clock. You can use\npg_test_timing\nto measure this for your system.",
    "Temp I/O Read Time":
      "The time spent reading short-term data, in\nmilliseconds\n(for example during sort and hash operations that were not done in memory).\nThis\nincludes\nvalues for child operations and is a total value (i.e. not a per-loop average).\nThis was added in PostgreSQL 15, and requires both\ntrack_io_timing\nand\nBUFFERS\n.\nIn the text format of explain, this shows as\nI/O Timings: temp read\nGetting timing information has an overhead, due to checking the system clock. You can use\npg_test_timing\nto measure this for your system.",
    "Temp I/O Write Time":
      "The time spent writing short-term data, in\nmilliseconds\n(for example during sort and hash operations that were not done in memory).\nThis\nincludes\nvalues for child operations and is a total value (i.e. not a per-loop average).\nThis was added in PostgreSQL 15, and requires both\ntrack_io_timing\nand\nBUFFERS\n.\nIn the text format of explain, this shows as\nI/O Timings: temp write\nGetting timing information has an overhead, due to checking the system clock. You can use\npg_test_timing\nto measure this for your system.",
    Workers:
      "A summary of the operation detail broken down by thread.\nThese entries\ndon’t\ninclude the main (or leader) thread.\nYou can work out the values for the main thread by subtracting the worker statistics from the total.\nThis information is only shown when VERBOSE is on.",
  },
  Append: {
    "Parent Relationship":
      "A guide as to why this operation needs to be run in order to facilitate the parent operation. There are six different possibilities:\nOuter\n: The value you’ll see most often. It means “take in the rows from this operation as input, process them and pass them on”.\nInner\n: Only ever seen on the second child of join operations, and is always seen there. This is the “inner” part of the loop — for each outer row, we look up its match using this operation.\nMember\n: Used for all children of Append and ModifyTable nodes, and on bitmap processing nodes like BitmapAnd and BitmapOr operations.\nInitPlan\n: Used for calculations performed before the query can start, eg a constant referred to in the query or the result of a CTE scan.\nSubquery\n: The child is a subquery of the parent operation. Since Postgres always uses subquery scans to feed subquery data to parent queries, only ever appears on the children of subquery scans.\nSubPlan\n: Like a Subquery, represents a new query, but used when a subquery scan is not necessary.",
    "Parallel Aware":
      "Whether or not the operation will be run in a special mode to support parallelism. Some operations need to be aware that they are running in parallel, for example sequential scans need to know they only need to scan a smaller proportion of the table. Other operations can be run on several threads without each one having any knowledge of the others.",
    "Startup Cost":
      "The estimated cost of returning the first row.\nThis is in an arbitrary unit, with the aim of being correlated to the startup time.",
    "Total Cost":
      "The estimated cost of returning all rows. This is in an arbitrary unit, with the aim of being correlated to the total time.\nThe Postgres query planner often has several ways it could resolve the same query. It calculates costs — which are hopefully correlated with the time it would take — for potential plans, and then picks the one with the lowest cost. It’s worth bearing in mind that the costs are unit-free — they’re not designed to convert into time, or disk reads. They’re just supposed to be bigger for slower operations, and smaller for faster ones.\nIf the planner thinks it can finish early due to a parent Limit operation, the total cost of the Limit operation will reflect this, but the total cost of its child operations will not.",
    "Plan Rows":
      "The number of rows,\nper-loop\n, that the planner expects to be returned by the operation.\nPoor row estimates can lead to suboptimal query planning. They can often be improved by running\nANALYZE\n(not the EXPLAIN parameter), by increasing statistics, or by allowing Postgres to understand correlation between columns using multivariate statistics.\nIf the planner thinks it can finish early due to a Limit operation, the plan rows of the Limit operation will reflect this, but the plan rows of its child operations will not.",
    "Plan Width":
      "The\nestimated\naverage size of the rows produced by the operation, in\nbytes\n.",
    "Actual Startup Time":
      "The amount of time, in\nmilliseconds\n, it takes to get the first row out of the operation.\nSometimes, this is very close to the setup time — for example on a sequential scan which returns all the rows in a table.\nOther times, though, it’s more or less the total time. For example, in order to return the first row of a sort, you have to sort all of the rows to work out which one comes first.",
    "Actual Total Time":
      "The actual amount of time in milliseconds spent on this operation\nand all of its children\n. It’s a\nper-loop average\n, rounded to the nearest thousandth of a millisecond.\nWorking out individual operation timings, especially where CTEs and SubPlans are concerned, can be tricky. This is one of the main reasons we decided to build\npgMustard\n.",
    "Actual Rows":
      "The number of rows returned by the operation\nper loop\n.\nThe important thing to notice about this is that it’s an average of all the loops executed, rounded to the nearest integer. This means that while “Actual Loops” multiplied by “Actual Rows” is a pretty good approximation for total number of rows returned most of the time, it can be off by as much as half of the number of loops. Usually it’s just slightly confusing as you see a row or two appear or disappear between operations, but on operations with lots of loops there is potential for serious miscalculation.\nPoor row estimates, where Actual Rows differs substantially from Plan Rows, can lead to suboptimal query planning. Estimates can often be improved by running\nANALYZE\n(not the EXPLAIN parameter), by increasing statistics, or by allowing Postgres to understand correlation between columns using multivariate statistics.",
    "Actual Loops":
      "The number of times the operation is executed. For a lot of operations it will have a value of one, but when it is not, there are three different cases:\nSome operations can be executed more than once. For example, “Nested Loops” run their “Inner” child once for every row returned by their “Outer” child.\nWhen an operation that would normally only consist of one loop is split across multiple threads, each partial operation is counted as a Loop.\nThe number of loops can be zero when an operation doesn’t need to be executed at all. For example if a table read is planned to provide candidates for an inner join, but there turns out to be no rows on the other side of the join, the operation can be effectively eliminated.",
    "Subplans Removed":
      "The number of subplans Postgres determines do not need to be examined for a partitioned table. This is also known as partition pruning.\nIf you see “never executed” it means all subplans were removed.",
    "Shared Hit Blocks":
      "The number of blocks from indexes/tables that were found in the Postgres buffer cache.\nThis\nincludes\nvalues for child operations and is a\ntotal\nvalue (i.e. not a per-loop average).\nOnce you have subtracted child operation values, the proportion of shared hit to shared read blocks is an interesting measure of cache performance.\nThe ratio of shared blocks (hit plus read) to rows processed (including any filtered out) is also interesting: a high ratio means Postgres is reading a lot of data for what it is doing, which can be a sign of bloat.",
    "Shared Read Blocks":
      "The number of blocks from tables/indexes that were read from disk (or the OS cache).\nThis\nincludes\nvalues for child operations and is a\ntotal\nvalue (i.e. not per-loop).\nOnce you have subtracted child operation values, the proportion of shared hit to shared read blocks is an interesting measure of cache performance.\nThe ratio of shared blocks (hit plus read) to rows processed (including any filtered out) is also interesting: a high ratio means Postgres is reading a lot of data for what it is doing, which can be a sign of bloat.",
    "Shared Dirtied Blocks":
      "The number of blocks from tables/indexes that were modified by the operation.\nThis\nincludes\nvalues for child operations and is a\ntotal\nvalue (i.e. not per-loop).\nInterestingly, a SELECT query can report shared dirtied blocks when setting hint bits on recently-committed rows, or pruning old row versions. While somewhat surprising, both of these are perfectly normal and healthy.",
    "Shared Written Blocks":
      "The number of blocks from tables/indexes that were evicted from the cache.\nThis\nincludes\nvalues for child operations and is a\ntotal\nvalue (i.e. not a per-loop average).",
    "Local Hit Blocks":
      "The number of blocks from temporary tables and indexes that were found in the cache.\nThis\nincludes\nvalues for child operations and is a\ntotal\nvalue (not a per-loop average).",
    "Local Read Blocks":
      "The number of blocks read from\ntemporary tables and indexes that were not found in the Postgres cache (read from disk or the OS cache).\nThis\nincludes\nvalues for child operations and is a\ntotal\nvalue (not a per-loop average).",
    "Local Dirtied Blocks":
      "The number of blocks from\ntemporary tables and indexes that have been modified by the operation.\nThis\nincludes\nvalues for child operations and is a\ntotal\nvalue (i.e. not a per-loop average).",
    "Local Written Blocks":
      "The number of blocks from\ntemporary tables and indexes that were evicted from the cache.\nThis\nincludes\nvalues for child operations and is a\ntotal\nvalue (i.e. not a per-loop average).",
    "Temp Read Blocks":
      "The number of blocks read from short-term data used to calculate hashes, sorts, Materialize operations, and similar.\nThis\nincludes\nvalues for child operations and is a\ntotal\nvalue (i.e. not a per-loop average).\nYour settings of\nwork_mem\nand\nhash_mem_multiplier\ndetermine how much memory is available to Postgres per operation.",
    "Temp Written Blocks":
      "The number of blocks from short-term data (used to calculate operations like hashes, sorts, and materializes) that were evicted from the cache.\nThis\nincludes\nvalues for child operations and is a\ntotal\nvalue (i.e. not a per-loop average).\nYour settings of\nwork_mem\nand\nhash_mem_multiplier\ndetermine how much memory is available to Postgres per operation.",
    "Shared I/O Read Time":
      "The time spent reading data from tables and indexes, in\nmilliseconds\n.\nThis\nincludes\nvalues for child operations and is a total value (not a per-loop average).\nRequires\ntrack_io_timing\nand\nBUFFERS\nto be on.\nIn the latest version, the text format of explain displays this as\nI/O Timings: shared read\nIn PostgreSQL 15 and 16 it shows as a combined metric\nI/O Timings: shared/local read\nGetting timing information has an overhead, due to checking the system clock. You can use\npg_test_timing\nto measure this for your system.",
    "Shared I/O Write Time":
      "The time spent writing data for tables and indexes, in\nmilliseconds\n.\nThis\nincludes\nvalues for child operations and is a total value (not a per-loop average).\nRequires\ntrack_io_timing\nand\nBUFFERS\nto be on.\nIn the latest version, the text format of explain displays this as\nI/O Timings: shared write\nIn PostgreSQL 15 and 16 it shows as a combined metric\nI/O Timings: shared/local write\nGetting timing information has an overhead, due to checking the system clock. You can use\npg_test_timing\nto measure this for your system.",
    "Local I/O Read Time":
      "The time spent reading local data (e.g. from temporary tables and indexes), in\nmilliseconds\n.\nThis\nincludes\nvalues for child operations and is a total value (i.e. not a per-loop average).\nThis was added as a separate field in PostgreSQL 17, and requires both\ntrack_io_timing\nand\nBUFFERS\n.\nIn the default text format, this will show as\nI/O Timings: local read\nIn versions 15 and 16 it is available as a combined metric as\nshared/local\nGetting timing information has an overhead, due to checking the system clock. You can use\npg_test_timing\nto measure this for your system.",
    "Local I/O Write Time":
      "The time spent writing local data (e.g. for temporary tables and indexes), in\nmilliseconds\n.\nThis\nincludes\nvalues for child operations and is a total value (i.e. not a per-loop average).\nThis was added as a separate field in PostgreSQL 17, and requires both\ntrack_io_timing\nand\nBUFFERS\n.\nIn the default text format, this will show as\nI/O Timings: local write\nIn versions 15 and 16 it is available as a combined metric as\nshared/local\nGetting timing information has an overhead, due to checking the system clock. You can use\npg_test_timing\nto measure this for your system.",
    "Temp I/O Read Time":
      "The time spent reading short-term data, in\nmilliseconds\n(for example during sort and hash operations that were not done in memory).\nThis\nincludes\nvalues for child operations and is a total value (i.e. not a per-loop average).\nThis was added in PostgreSQL 15, and requires both\ntrack_io_timing\nand\nBUFFERS\n.\nIn the text format of explain, this shows as\nI/O Timings: temp read\nGetting timing information has an overhead, due to checking the system clock. You can use\npg_test_timing\nto measure this for your system.",
    "Temp I/O Write Time":
      "The time spent writing short-term data, in\nmilliseconds\n(for example during sort and hash operations that were not done in memory).\nThis\nincludes\nvalues for child operations and is a total value (i.e. not a per-loop average).\nThis was added in PostgreSQL 15, and requires both\ntrack_io_timing\nand\nBUFFERS\n.\nIn the text format of explain, this shows as\nI/O Timings: temp write\nGetting timing information has an overhead, due to checking the system clock. You can use\npg_test_timing\nto measure this for your system.",
  },
  "Bitmap Heap Scan": {
    "Parent Relationship":
      "A guide as to why this operation needs to be run in order to facilitate the parent operation. There are six different possibilities:\nOuter\n: The value you’ll see most often. It means “take in the rows from this operation as input, process them and pass them on”.\nInner\n: Only ever seen on the second child of join operations, and is always seen there. This is the “inner” part of the loop — for each outer row, we look up its match using this operation.\nMember\n: Used for all children of Append and ModifyTable nodes, and on bitmap processing nodes like BitmapAnd and BitmapOr operations.\nInitPlan\n: Used for calculations performed before the query can start, eg a constant referred to in the query or the result of a CTE scan.\nSubquery\n: The child is a subquery of the parent operation. Since Postgres always uses subquery scans to feed subquery data to parent queries, only ever appears on the children of subquery scans.\nSubPlan\n: Like a Subquery, represents a new query, but used when a subquery scan is not necessary.",
    "Parallel Aware":
      "Whether or not the operation will be run in a special mode to support parallelism. Some operations need to be aware that they are running in parallel, for example sequential scans need to know they only need to scan a smaller proportion of the table. Other operations can be run on several threads without each one having any knowledge of the others.",
    "Relation Name":
      "The data source being read/written from. Normally a table name (including when the data is accessed via an index), but can also be a materialised view or foreign data source.",
    Schema:
      "The schema of the “Relation Name” object.\nThis is only shown when VERBOSE is on.",
    Alias: "The alias used to refer to the Relation Name object.",
    "Startup Cost":
      "The estimated cost of returning the first row.\nThis is in an arbitrary unit, with the aim of being correlated to the startup time.",
    "Total Cost":
      "The estimated cost of returning all rows. This is in an arbitrary unit, with the aim of being correlated to the total time.\nThe Postgres query planner often has several ways it could resolve the same query. It calculates costs — which are hopefully correlated with the time it would take — for potential plans, and then picks the one with the lowest cost. It’s worth bearing in mind that the costs are unit-free — they’re not designed to convert into time, or disk reads. They’re just supposed to be bigger for slower operations, and smaller for faster ones.\nIf the planner thinks it can finish early due to a parent Limit operation, the total cost of the Limit operation will reflect this, but the total cost of its child operations will not.",
    "Plan Rows":
      "The number of rows,\nper-loop\n, that the planner expects to be returned by the operation.\nPoor row estimates can lead to suboptimal query planning. They can often be improved by running\nANALYZE\n(not the EXPLAIN parameter), by increasing statistics, or by allowing Postgres to understand correlation between columns using multivariate statistics.\nIf the planner thinks it can finish early due to a Limit operation, the plan rows of the Limit operation will reflect this, but the plan rows of its child operations will not.",
    "Plan Width":
      "The\nestimated\naverage size of the rows produced by the operation, in\nbytes\n.",
    "Actual Startup Time":
      "The amount of time, in\nmilliseconds\n, it takes to get the first row out of the operation.\nSometimes, this is very close to the setup time — for example on a sequential scan which returns all the rows in a table.\nOther times, though, it’s more or less the total time. For example, in order to return the first row of a sort, you have to sort all of the rows to work out which one comes first.",
    "Actual Total Time":
      "The actual amount of time in milliseconds spent on this operation\nand all of its children\n. It’s a\nper-loop average\n, rounded to the nearest thousandth of a millisecond.\nWorking out individual operation timings, especially where CTEs and SubPlans are concerned, can be tricky. This is one of the main reasons we decided to build\npgMustard\n.",
    "Actual Rows":
      "The number of rows returned by the operation\nper loop\n.\nThe important thing to notice about this is that it’s an average of all the loops executed, rounded to the nearest integer. This means that while “Actual Loops” multiplied by “Actual Rows” is a pretty good approximation for total number of rows returned most of the time, it can be off by as much as half of the number of loops. Usually it’s just slightly confusing as you see a row or two appear or disappear between operations, but on operations with lots of loops there is potential for serious miscalculation.\nPoor row estimates, where Actual Rows differs substantially from Plan Rows, can lead to suboptimal query planning. Estimates can often be improved by running\nANALYZE\n(not the EXPLAIN parameter), by increasing statistics, or by allowing Postgres to understand correlation between columns using multivariate statistics.",
    "Actual Loops":
      "The number of times the operation is executed. For a lot of operations it will have a value of one, but when it is not, there are three different cases:\nSome operations can be executed more than once. For example, “Nested Loops” run their “Inner” child once for every row returned by their “Outer” child.\nWhen an operation that would normally only consist of one loop is split across multiple threads, each partial operation is counted as a Loop.\nThe number of loops can be zero when an operation doesn’t need to be executed at all. For example if a table read is planned to provide candidates for an inner join, but there turns out to be no rows on the other side of the join, the operation can be effectively eliminated.",
    Output:
      "A list of the columns returned by the operation.\nThis is only shown when VERBOSE is on.",
    "Recheck Cond":
      "The Recheck Cond is the condition a bitmap scan\nmight\nuse to filter rows out after fetching them.\nIt is only needed if the bitmap scan is lossy, or if it has used any lossy index types that do not guarantee that rows match the condition (e.g. a BRIN index).\nFor more info on whether a recheck was actually needed, look out for non-zero\nLossy Heap Blocks\nand non-zero\nRows Removed by Index Recheck\n.",
    "Rows Removed by Index Recheck":
      "The number of rows returned by the index scan that do not meet the condition and are subsequently removed.\nThis will either be the result of a lossy bitmap scan, or an index type that doesn't guarantee that a row matches the condition.",
    Filter:
      "When present, this is a filter used to remove rows.\nThe important thing to note is that this is a filter in the traditional sense: these rows are read in (either from a data source or another operation in the plan), inspected, and then approved or removed based on the filter.\nIf a high proportion of rows are being removed by the Filter, you may want to investigate whether a (more) selective index could help.\nIf you notice a lot of rows being filtered late in a query plan, this might be due to an operation (like a GROUP BY or SORT) using more columns than are necessary, requiring joins to take place before rows can be discarded. It is also sometimes a result of unnecessary or ill-advised uses of DISTINCT.",
    "Rows Removed by Filter":
      "The number of rows removed by the\nFilter\n. This is a\nper-loop average\n, rounded to the nearest integer.\nIf a high proportion of rows are being removed, you may want to investigate whether a (more) selective index could help.",
    "Exact Heap Blocks":
      'The number of\nnon\n-lossy blocks a bitmap heap scan visited.\nIf a row bitmap is too big to fit into working memory (\nwork_mem\n), some parts of it are made "lossy" – i.e. they refer to whole pages rather than specific rows.\nIf you see only Exact heap blocks, then your bitmap scan was not lossy.',
    "Lossy Heap Blocks":
      'The number of lossy blocks a bitmap heap scan visited.\nIf a row bitmap is too big to fit into working memory (\nwork_mem\n), some parts of it are made "lossy" – i.e. they refer to whole pages rather than specific rows.',
    "Shared Hit Blocks":
      "The number of blocks from indexes/tables that were found in the Postgres buffer cache.\nThis\nincludes\nvalues for child operations and is a\ntotal\nvalue (i.e. not a per-loop average).\nOnce you have subtracted child operation values, the proportion of shared hit to shared read blocks is an interesting measure of cache performance.\nThe ratio of shared blocks (hit plus read) to rows processed (including any filtered out) is also interesting: a high ratio means Postgres is reading a lot of data for what it is doing, which can be a sign of bloat.",
    "Shared Read Blocks":
      "The number of blocks from tables/indexes that were read from disk (or the OS cache).\nThis\nincludes\nvalues for child operations and is a\ntotal\nvalue (i.e. not per-loop).\nOnce you have subtracted child operation values, the proportion of shared hit to shared read blocks is an interesting measure of cache performance.\nThe ratio of shared blocks (hit plus read) to rows processed (including any filtered out) is also interesting: a high ratio means Postgres is reading a lot of data for what it is doing, which can be a sign of bloat.",
    "Shared Dirtied Blocks":
      "The number of blocks from tables/indexes that were modified by the operation.\nThis\nincludes\nvalues for child operations and is a\ntotal\nvalue (i.e. not per-loop).\nInterestingly, a SELECT query can report shared dirtied blocks when setting hint bits on recently-committed rows, or pruning old row versions. While somewhat surprising, both of these are perfectly normal and healthy.",
    "Shared Written Blocks":
      "The number of blocks from tables/indexes that were evicted from the cache.\nThis\nincludes\nvalues for child operations and is a\ntotal\nvalue (i.e. not a per-loop average).",
    "Local Hit Blocks":
      "The number of blocks from temporary tables and indexes that were found in the cache.\nThis\nincludes\nvalues for child operations and is a\ntotal\nvalue (not a per-loop average).",
    "Local Read Blocks":
      "The number of blocks read from\ntemporary tables and indexes that were not found in the Postgres cache (read from disk or the OS cache).\nThis\nincludes\nvalues for child operations and is a\ntotal\nvalue (not a per-loop average).",
    "Local Dirtied Blocks":
      "The number of blocks from\ntemporary tables and indexes that have been modified by the operation.\nThis\nincludes\nvalues for child operations and is a\ntotal\nvalue (i.e. not a per-loop average).",
    "Local Written Blocks":
      "The number of blocks from\ntemporary tables and indexes that were evicted from the cache.\nThis\nincludes\nvalues for child operations and is a\ntotal\nvalue (i.e. not a per-loop average).",
    "Temp Read Blocks":
      "The number of blocks read from short-term data used to calculate hashes, sorts, Materialize operations, and similar.\nThis\nincludes\nvalues for child operations and is a\ntotal\nvalue (i.e. not a per-loop average).\nYour settings of\nwork_mem\nand\nhash_mem_multiplier\ndetermine how much memory is available to Postgres per operation.",
    "Temp Written Blocks":
      "The number of blocks from short-term data (used to calculate operations like hashes, sorts, and materializes) that were evicted from the cache.\nThis\nincludes\nvalues for child operations and is a\ntotal\nvalue (i.e. not a per-loop average).\nYour settings of\nwork_mem\nand\nhash_mem_multiplier\ndetermine how much memory is available to Postgres per operation.",
    "Shared I/O Read Time":
      "The time spent reading data from tables and indexes, in\nmilliseconds\n.\nThis\nincludes\nvalues for child operations and is a total value (not a per-loop average).\nRequires\ntrack_io_timing\nand\nBUFFERS\nto be on.\nIn the latest version, the text format of explain displays this as\nI/O Timings: shared read\nIn PostgreSQL 15 and 16 it shows as a combined metric\nI/O Timings: shared/local read\nGetting timing information has an overhead, due to checking the system clock. You can use\npg_test_timing\nto measure this for your system.",
    "Shared I/O Write Time":
      "The time spent writing data for tables and indexes, in\nmilliseconds\n.\nThis\nincludes\nvalues for child operations and is a total value (not a per-loop average).\nRequires\ntrack_io_timing\nand\nBUFFERS\nto be on.\nIn the latest version, the text format of explain displays this as\nI/O Timings: shared write\nIn PostgreSQL 15 and 16 it shows as a combined metric\nI/O Timings: shared/local write\nGetting timing information has an overhead, due to checking the system clock. You can use\npg_test_timing\nto measure this for your system.",
    "Local I/O Read Time":
      "The time spent reading local data (e.g. from temporary tables and indexes), in\nmilliseconds\n.\nThis\nincludes\nvalues for child operations and is a total value (i.e. not a per-loop average).\nThis was added as a separate field in PostgreSQL 17, and requires both\ntrack_io_timing\nand\nBUFFERS\n.\nIn the default text format, this will show as\nI/O Timings: local read\nIn versions 15 and 16 it is available as a combined metric as\nshared/local\nGetting timing information has an overhead, due to checking the system clock. You can use\npg_test_timing\nto measure this for your system.",
    "Local I/O Write Time":
      "The time spent writing local data (e.g. for temporary tables and indexes), in\nmilliseconds\n.\nThis\nincludes\nvalues for child operations and is a total value (i.e. not a per-loop average).\nThis was added as a separate field in PostgreSQL 17, and requires both\ntrack_io_timing\nand\nBUFFERS\n.\nIn the default text format, this will show as\nI/O Timings: local write\nIn versions 15 and 16 it is available as a combined metric as\nshared/local\nGetting timing information has an overhead, due to checking the system clock. You can use\npg_test_timing\nto measure this for your system.",
    "Temp I/O Read Time":
      "The time spent reading short-term data, in\nmilliseconds\n(for example during sort and hash operations that were not done in memory).\nThis\nincludes\nvalues for child operations and is a total value (i.e. not a per-loop average).\nThis was added in PostgreSQL 15, and requires both\ntrack_io_timing\nand\nBUFFERS\n.\nIn the text format of explain, this shows as\nI/O Timings: temp read\nGetting timing information has an overhead, due to checking the system clock. You can use\npg_test_timing\nto measure this for your system.",
    "Temp I/O Write Time":
      "The time spent writing short-term data, in\nmilliseconds\n(for example during sort and hash operations that were not done in memory).\nThis\nincludes\nvalues for child operations and is a total value (i.e. not a per-loop average).\nThis was added in PostgreSQL 15, and requires both\ntrack_io_timing\nand\nBUFFERS\n.\nIn the text format of explain, this shows as\nI/O Timings: temp write\nGetting timing information has an overhead, due to checking the system clock. You can use\npg_test_timing\nto measure this for your system.",
  },
  "Bitmap Index Scan": {
    "Parent Relationship":
      "A guide as to why this operation needs to be run in order to facilitate the parent operation. There are six different possibilities:\nOuter\n: The value you’ll see most often. It means “take in the rows from this operation as input, process them and pass them on”.\nInner\n: Only ever seen on the second child of join operations, and is always seen there. This is the “inner” part of the loop — for each outer row, we look up its match using this operation.\nMember\n: Used for all children of Append and ModifyTable nodes, and on bitmap processing nodes like BitmapAnd and BitmapOr operations.\nInitPlan\n: Used for calculations performed before the query can start, eg a constant referred to in the query or the result of a CTE scan.\nSubquery\n: The child is a subquery of the parent operation. Since Postgres always uses subquery scans to feed subquery data to parent queries, only ever appears on the children of subquery scans.\nSubPlan\n: Like a Subquery, represents a new query, but used when a subquery scan is not necessary.",
    "Parallel Aware":
      "Whether or not the operation will be run in a special mode to support parallelism. Some operations need to be aware that they are running in parallel, for example sequential scans need to know they only need to scan a smaller proportion of the table. Other operations can be run on several threads without each one having any knowledge of the others.",
    "Index Name":
      "Unsurprisingly, this is the name of the index being scanned.",
    "Startup Cost":
      "The estimated cost of returning the first row.\nThis is in an arbitrary unit, with the aim of being correlated to the startup time.",
    "Total Cost":
      "The estimated cost of returning all rows. This is in an arbitrary unit, with the aim of being correlated to the total time.\nThe Postgres query planner often has several ways it could resolve the same query. It calculates costs — which are hopefully correlated with the time it would take — for potential plans, and then picks the one with the lowest cost. It’s worth bearing in mind that the costs are unit-free — they’re not designed to convert into time, or disk reads. They’re just supposed to be bigger for slower operations, and smaller for faster ones.\nIf the planner thinks it can finish early due to a parent Limit operation, the total cost of the Limit operation will reflect this, but the total cost of its child operations will not.",
    "Plan Rows":
      "The number of rows,\nper-loop\n, that the planner expects to be returned by the operation.\nPoor row estimates can lead to suboptimal query planning. They can often be improved by running\nANALYZE\n(not the EXPLAIN parameter), by increasing statistics, or by allowing Postgres to understand correlation between columns using multivariate statistics.\nIf the planner thinks it can finish early due to a Limit operation, the plan rows of the Limit operation will reflect this, but the plan rows of its child operations will not.",
    "Plan Width":
      "The\nestimated\naverage size of the rows produced by the operation, in\nbytes\n.",
    "Actual Startup Time":
      "The amount of time, in\nmilliseconds\n, it takes to get the first row out of the operation.\nSometimes, this is very close to the setup time — for example on a sequential scan which returns all the rows in a table.\nOther times, though, it’s more or less the total time. For example, in order to return the first row of a sort, you have to sort all of the rows to work out which one comes first.",
    "Actual Total Time":
      "The actual amount of time in milliseconds spent on this operation\nand all of its children\n. It’s a\nper-loop average\n, rounded to the nearest thousandth of a millisecond.\nWorking out individual operation timings, especially where CTEs and SubPlans are concerned, can be tricky. This is one of the main reasons we decided to build\npgMustard\n.",
    "Actual Rows":
      "The number of rows returned by the operation\nper loop\n.\nThe important thing to notice about this is that it’s an average of all the loops executed, rounded to the nearest integer. This means that while “Actual Loops” multiplied by “Actual Rows” is a pretty good approximation for total number of rows returned most of the time, it can be off by as much as half of the number of loops. Usually it’s just slightly confusing as you see a row or two appear or disappear between operations, but on operations with lots of loops there is potential for serious miscalculation.\nPoor row estimates, where Actual Rows differs substantially from Plan Rows, can lead to suboptimal query planning. Estimates can often be improved by running\nANALYZE\n(not the EXPLAIN parameter), by increasing statistics, or by allowing Postgres to understand correlation between columns using multivariate statistics.",
    "Actual Loops":
      "The number of times the operation is executed. For a lot of operations it will have a value of one, but when it is not, there are three different cases:\nSome operations can be executed more than once. For example, “Nested Loops” run their “Inner” child once for every row returned by their “Outer” child.\nWhen an operation that would normally only consist of one loop is split across multiple threads, each partial operation is counted as a Loop.\nThe number of loops can be zero when an operation doesn’t need to be executed at all. For example if a table read is planned to provide candidates for an inner join, but there turns out to be no rows on the other side of the join, the operation can be effectively eliminated.",
    "Index Cond":
      "The condition(s) used to find the locations of rows from the index.\nPostgres uses the structured nature of the index to jump to the rows it's looking for. Different index types use different strategies.\nUnfortunately, Postgres doesn’t yet distinguish between conditions used to access and conditions used to filter rows as part of the Index Cond. As such, you need to compare the index definition and query conditions to work it out, and can compare the\nCOSTS\nor\nBUFFERS\nbetween query plans as a check.\nAny conditions that could not be used to search the index will be added as a\nFilter\n, which later discards any rows necessary based on their values. This is naturally less efficient.",
    "Shared Hit Blocks":
      "The number of blocks from indexes/tables that were found in the Postgres buffer cache.\nThis\nincludes\nvalues for child operations and is a\ntotal\nvalue (i.e. not a per-loop average).\nOnce you have subtracted child operation values, the proportion of shared hit to shared read blocks is an interesting measure of cache performance.\nThe ratio of shared blocks (hit plus read) to rows processed (including any filtered out) is also interesting: a high ratio means Postgres is reading a lot of data for what it is doing, which can be a sign of bloat.",
    "Shared Read Blocks":
      "The number of blocks from tables/indexes that were read from disk (or the OS cache).\nThis\nincludes\nvalues for child operations and is a\ntotal\nvalue (i.e. not per-loop).\nOnce you have subtracted child operation values, the proportion of shared hit to shared read blocks is an interesting measure of cache performance.\nThe ratio of shared blocks (hit plus read) to rows processed (including any filtered out) is also interesting: a high ratio means Postgres is reading a lot of data for what it is doing, which can be a sign of bloat.",
    "Shared Dirtied Blocks":
      "The number of blocks from tables/indexes that were modified by the operation.\nThis\nincludes\nvalues for child operations and is a\ntotal\nvalue (i.e. not per-loop).\nInterestingly, a SELECT query can report shared dirtied blocks when setting hint bits on recently-committed rows, or pruning old row versions. While somewhat surprising, both of these are perfectly normal and healthy.",
    "Shared Written Blocks":
      "The number of blocks from tables/indexes that were evicted from the cache.\nThis\nincludes\nvalues for child operations and is a\ntotal\nvalue (i.e. not a per-loop average).",
    "Local Hit Blocks":
      "The number of blocks from temporary tables and indexes that were found in the cache.\nThis\nincludes\nvalues for child operations and is a\ntotal\nvalue (not a per-loop average).",
    "Local Read Blocks":
      "The number of blocks read from\ntemporary tables and indexes that were not found in the Postgres cache (read from disk or the OS cache).\nThis\nincludes\nvalues for child operations and is a\ntotal\nvalue (not a per-loop average).",
    "Local Dirtied Blocks":
      "The number of blocks from\ntemporary tables and indexes that have been modified by the operation.\nThis\nincludes\nvalues for child operations and is a\ntotal\nvalue (i.e. not a per-loop average).",
    "Local Written Blocks":
      "The number of blocks from\ntemporary tables and indexes that were evicted from the cache.\nThis\nincludes\nvalues for child operations and is a\ntotal\nvalue (i.e. not a per-loop average).",
    "Temp Read Blocks":
      "The number of blocks read from short-term data used to calculate hashes, sorts, Materialize operations, and similar.\nThis\nincludes\nvalues for child operations and is a\ntotal\nvalue (i.e. not a per-loop average).\nYour settings of\nwork_mem\nand\nhash_mem_multiplier\ndetermine how much memory is available to Postgres per operation.",
    "Temp Written Blocks":
      "The number of blocks from short-term data (used to calculate operations like hashes, sorts, and materializes) that were evicted from the cache.\nThis\nincludes\nvalues for child operations and is a\ntotal\nvalue (i.e. not a per-loop average).\nYour settings of\nwork_mem\nand\nhash_mem_multiplier\ndetermine how much memory is available to Postgres per operation.",
    "Shared I/O Read Time":
      "The time spent reading data from tables and indexes, in\nmilliseconds\n.\nThis\nincludes\nvalues for child operations and is a total value (not a per-loop average).\nRequires\ntrack_io_timing\nand\nBUFFERS\nto be on.\nIn the latest version, the text format of explain displays this as\nI/O Timings: shared read\nIn PostgreSQL 15 and 16 it shows as a combined metric\nI/O Timings: shared/local read\nGetting timing information has an overhead, due to checking the system clock. You can use\npg_test_timing\nto measure this for your system.",
    "Shared I/O Write Time":
      "The time spent writing data for tables and indexes, in\nmilliseconds\n.\nThis\nincludes\nvalues for child operations and is a total value (not a per-loop average).\nRequires\ntrack_io_timing\nand\nBUFFERS\nto be on.\nIn the latest version, the text format of explain displays this as\nI/O Timings: shared write\nIn PostgreSQL 15 and 16 it shows as a combined metric\nI/O Timings: shared/local write\nGetting timing information has an overhead, due to checking the system clock. You can use\npg_test_timing\nto measure this for your system.",
    "Local I/O Read Time":
      "The time spent reading local data (e.g. from temporary tables and indexes), in\nmilliseconds\n.\nThis\nincludes\nvalues for child operations and is a total value (i.e. not a per-loop average).\nThis was added as a separate field in PostgreSQL 17, and requires both\ntrack_io_timing\nand\nBUFFERS\n.\nIn the default text format, this will show as\nI/O Timings: local read\nIn versions 15 and 16 it is available as a combined metric as\nshared/local\nGetting timing information has an overhead, due to checking the system clock. You can use\npg_test_timing\nto measure this for your system.",
    "Local I/O Write Time":
      "The time spent writing local data (e.g. for temporary tables and indexes), in\nmilliseconds\n.\nThis\nincludes\nvalues for child operations and is a total value (i.e. not a per-loop average).\nThis was added as a separate field in PostgreSQL 17, and requires both\ntrack_io_timing\nand\nBUFFERS\n.\nIn the default text format, this will show as\nI/O Timings: local write\nIn versions 15 and 16 it is available as a combined metric as\nshared/local\nGetting timing information has an overhead, due to checking the system clock. You can use\npg_test_timing\nto measure this for your system.",
    "Temp I/O Read Time":
      "The time spent reading short-term data, in\nmilliseconds\n(for example during sort and hash operations that were not done in memory).\nThis\nincludes\nvalues for child operations and is a total value (i.e. not a per-loop average).\nThis was added in PostgreSQL 15, and requires both\ntrack_io_timing\nand\nBUFFERS\n.\nIn the text format of explain, this shows as\nI/O Timings: temp read\nGetting timing information has an overhead, due to checking the system clock. You can use\npg_test_timing\nto measure this for your system.",
    "Temp I/O Write Time":
      "The time spent writing short-term data, in\nmilliseconds\n(for example during sort and hash operations that were not done in memory).\nThis\nincludes\nvalues for child operations and is a total value (i.e. not a per-loop average).\nThis was added in PostgreSQL 15, and requires both\ntrack_io_timing\nand\nBUFFERS\n.\nIn the text format of explain, this shows as\nI/O Timings: temp write\nGetting timing information has an overhead, due to checking the system clock. You can use\npg_test_timing\nto measure this for your system.",
  },
  BitmapAnd: {
    "Parent Relationship":
      "A guide as to why this operation needs to be run in order to facilitate the parent operation. There are six different possibilities:\nOuter\n: The value you’ll see most often. It means “take in the rows from this operation as input, process them and pass them on”.\nInner\n: Only ever seen on the second child of join operations, and is always seen there. This is the “inner” part of the loop — for each outer row, we look up its match using this operation.\nMember\n: Used for all children of Append and ModifyTable nodes, and on bitmap processing nodes like BitmapAnd and BitmapOr operations.\nInitPlan\n: Used for calculations performed before the query can start, eg a constant referred to in the query or the result of a CTE scan.\nSubquery\n: The child is a subquery of the parent operation. Since Postgres always uses subquery scans to feed subquery data to parent queries, only ever appears on the children of subquery scans.\nSubPlan\n: Like a Subquery, represents a new query, but used when a subquery scan is not necessary.",
    "Parallel Aware":
      "Whether or not the operation will be run in a special mode to support parallelism. Some operations need to be aware that they are running in parallel, for example sequential scans need to know they only need to scan a smaller proportion of the table. Other operations can be run on several threads without each one having any knowledge of the others.",
    "Startup Cost":
      "The estimated cost of returning the first row.\nThis is in an arbitrary unit, with the aim of being correlated to the startup time.",
    "Total Cost":
      "The estimated cost of returning all rows. This is in an arbitrary unit, with the aim of being correlated to the total time.\nThe Postgres query planner often has several ways it could resolve the same query. It calculates costs — which are hopefully correlated with the time it would take — for potential plans, and then picks the one with the lowest cost. It’s worth bearing in mind that the costs are unit-free — they’re not designed to convert into time, or disk reads. They’re just supposed to be bigger for slower operations, and smaller for faster ones.\nIf the planner thinks it can finish early due to a parent Limit operation, the total cost of the Limit operation will reflect this, but the total cost of its child operations will not.",
    "Plan Rows":
      "The number of rows,\nper-loop\n, that the planner expects to be returned by the operation.\nPoor row estimates can lead to suboptimal query planning. They can often be improved by running\nANALYZE\n(not the EXPLAIN parameter), by increasing statistics, or by allowing Postgres to understand correlation between columns using multivariate statistics.\nIf the planner thinks it can finish early due to a Limit operation, the plan rows of the Limit operation will reflect this, but the plan rows of its child operations will not.",
    "Plan Width":
      "The\nestimated\naverage size of the rows produced by the operation, in\nbytes\n.",
    "Actual Startup Time":
      "The amount of time, in\nmilliseconds\n, it takes to get the first row out of the operation.\nSometimes, this is very close to the setup time — for example on a sequential scan which returns all the rows in a table.\nOther times, though, it’s more or less the total time. For example, in order to return the first row of a sort, you have to sort all of the rows to work out which one comes first.",
    "Actual Total Time":
      "The actual amount of time in milliseconds spent on this operation\nand all of its children\n. It’s a\nper-loop average\n, rounded to the nearest thousandth of a millisecond.\nWorking out individual operation timings, especially where CTEs and SubPlans are concerned, can be tricky. This is one of the main reasons we decided to build\npgMustard\n.",
    "Actual Rows":
      "The number of rows returned by the operation\nper loop\n.\nThe important thing to notice about this is that it’s an average of all the loops executed, rounded to the nearest integer. This means that while “Actual Loops” multiplied by “Actual Rows” is a pretty good approximation for total number of rows returned most of the time, it can be off by as much as half of the number of loops. Usually it’s just slightly confusing as you see a row or two appear or disappear between operations, but on operations with lots of loops there is potential for serious miscalculation.\nPoor row estimates, where Actual Rows differs substantially from Plan Rows, can lead to suboptimal query planning. Estimates can often be improved by running\nANALYZE\n(not the EXPLAIN parameter), by increasing statistics, or by allowing Postgres to understand correlation between columns using multivariate statistics.",
    "Actual Loops":
      "The number of times the operation is executed. For a lot of operations it will have a value of one, but when it is not, there are three different cases:\nSome operations can be executed more than once. For example, “Nested Loops” run their “Inner” child once for every row returned by their “Outer” child.\nWhen an operation that would normally only consist of one loop is split across multiple threads, each partial operation is counted as a Loop.\nThe number of loops can be zero when an operation doesn’t need to be executed at all. For example if a table read is planned to provide candidates for an inner join, but there turns out to be no rows on the other side of the join, the operation can be effectively eliminated.",
    "Shared Hit Blocks":
      "The number of blocks from indexes/tables that were found in the Postgres buffer cache.\nThis\nincludes\nvalues for child operations and is a\ntotal\nvalue (i.e. not a per-loop average).\nOnce you have subtracted child operation values, the proportion of shared hit to shared read blocks is an interesting measure of cache performance.\nThe ratio of shared blocks (hit plus read) to rows processed (including any filtered out) is also interesting: a high ratio means Postgres is reading a lot of data for what it is doing, which can be a sign of bloat.",
    "Shared Read Blocks":
      "The number of blocks from tables/indexes that were read from disk (or the OS cache).\nThis\nincludes\nvalues for child operations and is a\ntotal\nvalue (i.e. not per-loop).\nOnce you have subtracted child operation values, the proportion of shared hit to shared read blocks is an interesting measure of cache performance.\nThe ratio of shared blocks (hit plus read) to rows processed (including any filtered out) is also interesting: a high ratio means Postgres is reading a lot of data for what it is doing, which can be a sign of bloat.",
    "Shared Dirtied Blocks":
      "The number of blocks from tables/indexes that were modified by the operation.\nThis\nincludes\nvalues for child operations and is a\ntotal\nvalue (i.e. not per-loop).\nInterestingly, a SELECT query can report shared dirtied blocks when setting hint bits on recently-committed rows, or pruning old row versions. While somewhat surprising, both of these are perfectly normal and healthy.",
    "Shared Written Blocks":
      "The number of blocks from tables/indexes that were evicted from the cache.\nThis\nincludes\nvalues for child operations and is a\ntotal\nvalue (i.e. not a per-loop average).",
    "Local Hit Blocks":
      "The number of blocks from temporary tables and indexes that were found in the cache.\nThis\nincludes\nvalues for child operations and is a\ntotal\nvalue (not a per-loop average).",
    "Local Read Blocks":
      "The number of blocks read from\ntemporary tables and indexes that were not found in the Postgres cache (read from disk or the OS cache).\nThis\nincludes\nvalues for child operations and is a\ntotal\nvalue (not a per-loop average).",
    "Local Dirtied Blocks":
      "The number of blocks from\ntemporary tables and indexes that have been modified by the operation.\nThis\nincludes\nvalues for child operations and is a\ntotal\nvalue (i.e. not a per-loop average).",
    "Local Written Blocks":
      "The number of blocks from\ntemporary tables and indexes that were evicted from the cache.\nThis\nincludes\nvalues for child operations and is a\ntotal\nvalue (i.e. not a per-loop average).",
    "Temp Read Blocks":
      "The number of blocks read from short-term data used to calculate hashes, sorts, Materialize operations, and similar.\nThis\nincludes\nvalues for child operations and is a\ntotal\nvalue (i.e. not a per-loop average).\nYour settings of\nwork_mem\nand\nhash_mem_multiplier\ndetermine how much memory is available to Postgres per operation.",
    "Temp Written Blocks":
      "The number of blocks from short-term data (used to calculate operations like hashes, sorts, and materializes) that were evicted from the cache.\nThis\nincludes\nvalues for child operations and is a\ntotal\nvalue (i.e. not a per-loop average).\nYour settings of\nwork_mem\nand\nhash_mem_multiplier\ndetermine how much memory is available to Postgres per operation.",
    "Shared I/O Read Time":
      "The time spent reading data from tables and indexes, in\nmilliseconds\n.\nThis\nincludes\nvalues for child operations and is a total value (not a per-loop average).\nRequires\ntrack_io_timing\nand\nBUFFERS\nto be on.\nIn the latest version, the text format of explain displays this as\nI/O Timings: shared read\nIn PostgreSQL 15 and 16 it shows as a combined metric\nI/O Timings: shared/local read\nGetting timing information has an overhead, due to checking the system clock. You can use\npg_test_timing\nto measure this for your system.",
    "Shared I/O Write Time":
      "The time spent writing data for tables and indexes, in\nmilliseconds\n.\nThis\nincludes\nvalues for child operations and is a total value (not a per-loop average).\nRequires\ntrack_io_timing\nand\nBUFFERS\nto be on.\nIn the latest version, the text format of explain displays this as\nI/O Timings: shared write\nIn PostgreSQL 15 and 16 it shows as a combined metric\nI/O Timings: shared/local write\nGetting timing information has an overhead, due to checking the system clock. You can use\npg_test_timing\nto measure this for your system.",
    "Local I/O Read Time":
      "The time spent reading local data (e.g. from temporary tables and indexes), in\nmilliseconds\n.\nThis\nincludes\nvalues for child operations and is a total value (i.e. not a per-loop average).\nThis was added as a separate field in PostgreSQL 17, and requires both\ntrack_io_timing\nand\nBUFFERS\n.\nIn the default text format, this will show as\nI/O Timings: local read\nIn versions 15 and 16 it is available as a combined metric as\nshared/local\nGetting timing information has an overhead, due to checking the system clock. You can use\npg_test_timing\nto measure this for your system.",
    "Local I/O Write Time":
      "The time spent writing local data (e.g. for temporary tables and indexes), in\nmilliseconds\n.\nThis\nincludes\nvalues for child operations and is a total value (i.e. not a per-loop average).\nThis was added as a separate field in PostgreSQL 17, and requires both\ntrack_io_timing\nand\nBUFFERS\n.\nIn the default text format, this will show as\nI/O Timings: local write\nIn versions 15 and 16 it is available as a combined metric as\nshared/local\nGetting timing information has an overhead, due to checking the system clock. You can use\npg_test_timing\nto measure this for your system.",
    "Temp I/O Read Time":
      "The time spent reading short-term data, in\nmilliseconds\n(for example during sort and hash operations that were not done in memory).\nThis\nincludes\nvalues for child operations and is a total value (i.e. not a per-loop average).\nThis was added in PostgreSQL 15, and requires both\ntrack_io_timing\nand\nBUFFERS\n.\nIn the text format of explain, this shows as\nI/O Timings: temp read\nGetting timing information has an overhead, due to checking the system clock. You can use\npg_test_timing\nto measure this for your system.",
    "Temp I/O Write Time":
      "The time spent writing short-term data, in\nmilliseconds\n(for example during sort and hash operations that were not done in memory).\nThis\nincludes\nvalues for child operations and is a total value (i.e. not a per-loop average).\nThis was added in PostgreSQL 15, and requires both\ntrack_io_timing\nand\nBUFFERS\n.\nIn the text format of explain, this shows as\nI/O Timings: temp write\nGetting timing information has an overhead, due to checking the system clock. You can use\npg_test_timing\nto measure this for your system.",
  },
  BitmapOr: {
    "Parent Relationship":
      "A guide as to why this operation needs to be run in order to facilitate the parent operation. There are six different possibilities:\nOuter\n: The value you’ll see most often. It means “take in the rows from this operation as input, process them and pass them on”.\nInner\n: Only ever seen on the second child of join operations, and is always seen there. This is the “inner” part of the loop — for each outer row, we look up its match using this operation.\nMember\n: Used for all children of Append and ModifyTable nodes, and on bitmap processing nodes like BitmapAnd and BitmapOr operations.\nInitPlan\n: Used for calculations performed before the query can start, eg a constant referred to in the query or the result of a CTE scan.\nSubquery\n: The child is a subquery of the parent operation. Since Postgres always uses subquery scans to feed subquery data to parent queries, only ever appears on the children of subquery scans.\nSubPlan\n: Like a Subquery, represents a new query, but used when a subquery scan is not necessary.",
    "Parallel Aware":
      "Whether or not the operation will be run in a special mode to support parallelism. Some operations need to be aware that they are running in parallel, for example sequential scans need to know they only need to scan a smaller proportion of the table. Other operations can be run on several threads without each one having any knowledge of the others.",
    "Startup Cost":
      "The estimated cost of returning the first row.\nThis is in an arbitrary unit, with the aim of being correlated to the startup time.",
    "Total Cost":
      "The estimated cost of returning all rows. This is in an arbitrary unit, with the aim of being correlated to the total time.\nThe Postgres query planner often has several ways it could resolve the same query. It calculates costs — which are hopefully correlated with the time it would take — for potential plans, and then picks the one with the lowest cost. It’s worth bearing in mind that the costs are unit-free — they’re not designed to convert into time, or disk reads. They’re just supposed to be bigger for slower operations, and smaller for faster ones.\nIf the planner thinks it can finish early due to a parent Limit operation, the total cost of the Limit operation will reflect this, but the total cost of its child operations will not.",
    "Plan Rows":
      "The number of rows,\nper-loop\n, that the planner expects to be returned by the operation.\nPoor row estimates can lead to suboptimal query planning. They can often be improved by running\nANALYZE\n(not the EXPLAIN parameter), by increasing statistics, or by allowing Postgres to understand correlation between columns using multivariate statistics.\nIf the planner thinks it can finish early due to a Limit operation, the plan rows of the Limit operation will reflect this, but the plan rows of its child operations will not.",
    "Plan Width":
      "The\nestimated\naverage size of the rows produced by the operation, in\nbytes\n.",
    "Actual Startup Time":
      "The amount of time, in\nmilliseconds\n, it takes to get the first row out of the operation.\nSometimes, this is very close to the setup time — for example on a sequential scan which returns all the rows in a table.\nOther times, though, it’s more or less the total time. For example, in order to return the first row of a sort, you have to sort all of the rows to work out which one comes first.",
    "Actual Total Time":
      "The actual amount of time in milliseconds spent on this operation\nand all of its children\n. It’s a\nper-loop average\n, rounded to the nearest thousandth of a millisecond.\nWorking out individual operation timings, especially where CTEs and SubPlans are concerned, can be tricky. This is one of the main reasons we decided to build\npgMustard\n.",
    "Actual Rows":
      "The number of rows returned by the operation\nper loop\n.\nThe important thing to notice about this is that it’s an average of all the loops executed, rounded to the nearest integer. This means that while “Actual Loops” multiplied by “Actual Rows” is a pretty good approximation for total number of rows returned most of the time, it can be off by as much as half of the number of loops. Usually it’s just slightly confusing as you see a row or two appear or disappear between operations, but on operations with lots of loops there is potential for serious miscalculation.\nPoor row estimates, where Actual Rows differs substantially from Plan Rows, can lead to suboptimal query planning. Estimates can often be improved by running\nANALYZE\n(not the EXPLAIN parameter), by increasing statistics, or by allowing Postgres to understand correlation between columns using multivariate statistics.",
    "Actual Loops":
      "The number of times the operation is executed. For a lot of operations it will have a value of one, but when it is not, there are three different cases:\nSome operations can be executed more than once. For example, “Nested Loops” run their “Inner” child once for every row returned by their “Outer” child.\nWhen an operation that would normally only consist of one loop is split across multiple threads, each partial operation is counted as a Loop.\nThe number of loops can be zero when an operation doesn’t need to be executed at all. For example if a table read is planned to provide candidates for an inner join, but there turns out to be no rows on the other side of the join, the operation can be effectively eliminated.",
    "Shared Hit Blocks":
      "The number of blocks from indexes/tables that were found in the Postgres buffer cache.\nThis\nincludes\nvalues for child operations and is a\ntotal\nvalue (i.e. not a per-loop average).\nOnce you have subtracted child operation values, the proportion of shared hit to shared read blocks is an interesting measure of cache performance.\nThe ratio of shared blocks (hit plus read) to rows processed (including any filtered out) is also interesting: a high ratio means Postgres is reading a lot of data for what it is doing, which can be a sign of bloat.",
    "Shared Read Blocks":
      "The number of blocks from tables/indexes that were read from disk (or the OS cache).\nThis\nincludes\nvalues for child operations and is a\ntotal\nvalue (i.e. not per-loop).\nOnce you have subtracted child operation values, the proportion of shared hit to shared read blocks is an interesting measure of cache performance.\nThe ratio of shared blocks (hit plus read) to rows processed (including any filtered out) is also interesting: a high ratio means Postgres is reading a lot of data for what it is doing, which can be a sign of bloat.",
    "Shared Dirtied Blocks":
      "The number of blocks from tables/indexes that were modified by the operation.\nThis\nincludes\nvalues for child operations and is a\ntotal\nvalue (i.e. not per-loop).\nInterestingly, a SELECT query can report shared dirtied blocks when setting hint bits on recently-committed rows, or pruning old row versions. While somewhat surprising, both of these are perfectly normal and healthy.",
    "Shared Written Blocks":
      "The number of blocks from tables/indexes that were evicted from the cache.\nThis\nincludes\nvalues for child operations and is a\ntotal\nvalue (i.e. not a per-loop average).",
    "Local Hit Blocks":
      "The number of blocks from temporary tables and indexes that were found in the cache.\nThis\nincludes\nvalues for child operations and is a\ntotal\nvalue (not a per-loop average).",
    "Local Read Blocks":
      "The number of blocks read from\ntemporary tables and indexes that were not found in the Postgres cache (read from disk or the OS cache).\nThis\nincludes\nvalues for child operations and is a\ntotal\nvalue (not a per-loop average).",
    "Local Dirtied Blocks":
      "The number of blocks from\ntemporary tables and indexes that have been modified by the operation.\nThis\nincludes\nvalues for child operations and is a\ntotal\nvalue (i.e. not a per-loop average).",
    "Local Written Blocks":
      "The number of blocks from\ntemporary tables and indexes that were evicted from the cache.\nThis\nincludes\nvalues for child operations and is a\ntotal\nvalue (i.e. not a per-loop average).",
    "Temp Read Blocks":
      "The number of blocks read from short-term data used to calculate hashes, sorts, Materialize operations, and similar.\nThis\nincludes\nvalues for child operations and is a\ntotal\nvalue (i.e. not a per-loop average).\nYour settings of\nwork_mem\nand\nhash_mem_multiplier\ndetermine how much memory is available to Postgres per operation.",
    "Temp Written Blocks":
      "The number of blocks from short-term data (used to calculate operations like hashes, sorts, and materializes) that were evicted from the cache.\nThis\nincludes\nvalues for child operations and is a\ntotal\nvalue (i.e. not a per-loop average).\nYour settings of\nwork_mem\nand\nhash_mem_multiplier\ndetermine how much memory is available to Postgres per operation.",
    "Shared I/O Read Time":
      "The time spent reading data from tables and indexes, in\nmilliseconds\n.\nThis\nincludes\nvalues for child operations and is a total value (not a per-loop average).\nRequires\ntrack_io_timing\nand\nBUFFERS\nto be on.\nIn the latest version, the text format of explain displays this as\nI/O Timings: shared read\nIn PostgreSQL 15 and 16 it shows as a combined metric\nI/O Timings: shared/local read\nGetting timing information has an overhead, due to checking the system clock. You can use\npg_test_timing\nto measure this for your system.",
    "Shared I/O Write Time":
      "The time spent writing data for tables and indexes, in\nmilliseconds\n.\nThis\nincludes\nvalues for child operations and is a total value (not a per-loop average).\nRequires\ntrack_io_timing\nand\nBUFFERS\nto be on.\nIn the latest version, the text format of explain displays this as\nI/O Timings: shared write\nIn PostgreSQL 15 and 16 it shows as a combined metric\nI/O Timings: shared/local write\nGetting timing information has an overhead, due to checking the system clock. You can use\npg_test_timing\nto measure this for your system.",
    "Local I/O Read Time":
      "The time spent reading local data (e.g. from temporary tables and indexes), in\nmilliseconds\n.\nThis\nincludes\nvalues for child operations and is a total value (i.e. not a per-loop average).\nThis was added as a separate field in PostgreSQL 17, and requires both\ntrack_io_timing\nand\nBUFFERS\n.\nIn the default text format, this will show as\nI/O Timings: local read\nIn versions 15 and 16 it is available as a combined metric as\nshared/local\nGetting timing information has an overhead, due to checking the system clock. You can use\npg_test_timing\nto measure this for your system.",
    "Local I/O Write Time":
      "The time spent writing local data (e.g. for temporary tables and indexes), in\nmilliseconds\n.\nThis\nincludes\nvalues for child operations and is a total value (i.e. not a per-loop average).\nThis was added as a separate field in PostgreSQL 17, and requires both\ntrack_io_timing\nand\nBUFFERS\n.\nIn the default text format, this will show as\nI/O Timings: local write\nIn versions 15 and 16 it is available as a combined metric as\nshared/local\nGetting timing information has an overhead, due to checking the system clock. You can use\npg_test_timing\nto measure this for your system.",
    "Temp I/O Read Time":
      "The time spent reading short-term data, in\nmilliseconds\n(for example during sort and hash operations that were not done in memory).\nThis\nincludes\nvalues for child operations and is a total value (i.e. not a per-loop average).\nThis was added in PostgreSQL 15, and requires both\ntrack_io_timing\nand\nBUFFERS\n.\nIn the text format of explain, this shows as\nI/O Timings: temp read\nGetting timing information has an overhead, due to checking the system clock. You can use\npg_test_timing\nto measure this for your system.",
    "Temp I/O Write Time":
      "The time spent writing short-term data, in\nmilliseconds\n(for example during sort and hash operations that were not done in memory).\nThis\nincludes\nvalues for child operations and is a total value (i.e. not a per-loop average).\nThis was added in PostgreSQL 15, and requires both\ntrack_io_timing\nand\nBUFFERS\n.\nIn the text format of explain, this shows as\nI/O Timings: temp write\nGetting timing information has an overhead, due to checking the system clock. You can use\npg_test_timing\nto measure this for your system.",
  },
  "Custom Scan": {
    "Parent Relationship":
      "A guide as to why this operation needs to be run in order to facilitate the parent operation. There are six different possibilities:\nOuter\n: The value you’ll see most often. It means “take in the rows from this operation as input, process them and pass them on”.\nInner\n: Only ever seen on the second child of join operations, and is always seen there. This is the “inner” part of the loop — for each outer row, we look up its match using this operation.\nMember\n: Used for all children of Append and ModifyTable nodes, and on bitmap processing nodes like BitmapAnd and BitmapOr operations.\nInitPlan\n: Used for calculations performed before the query can start, eg a constant referred to in the query or the result of a CTE scan.\nSubquery\n: The child is a subquery of the parent operation. Since Postgres always uses subquery scans to feed subquery data to parent queries, only ever appears on the children of subquery scans.\nSubPlan\n: Like a Subquery, represents a new query, but used when a subquery scan is not necessary.",
    "Parallel Aware":
      "Whether or not the operation will be run in a special mode to support parallelism. Some operations need to be aware that they are running in parallel, for example sequential scans need to know they only need to scan a smaller proportion of the table. Other operations can be run on several threads without each one having any knowledge of the others.",
    "Relation Name":
      "The data source being read/written from. Normally a table name (including when the data is accessed via an index), but can also be a materialised view or foreign data source.",
    Schema:
      "The schema of the “Relation Name” object.\nThis is only shown when VERBOSE is on.",
    Alias: "The alias used to refer to the Relation Name object.",
    "Startup Cost":
      "The estimated cost of returning the first row.\nThis is in an arbitrary unit, with the aim of being correlated to the startup time.",
    "Total Cost":
      "The estimated cost of returning all rows. This is in an arbitrary unit, with the aim of being correlated to the total time.\nThe Postgres query planner often has several ways it could resolve the same query. It calculates costs — which are hopefully correlated with the time it would take — for potential plans, and then picks the one with the lowest cost. It’s worth bearing in mind that the costs are unit-free — they’re not designed to convert into time, or disk reads. They’re just supposed to be bigger for slower operations, and smaller for faster ones.\nIf the planner thinks it can finish early due to a parent Limit operation, the total cost of the Limit operation will reflect this, but the total cost of its child operations will not.",
    "Plan Rows":
      "The number of rows,\nper-loop\n, that the planner expects to be returned by the operation.\nPoor row estimates can lead to suboptimal query planning. They can often be improved by running\nANALYZE\n(not the EXPLAIN parameter), by increasing statistics, or by allowing Postgres to understand correlation between columns using multivariate statistics.\nIf the planner thinks it can finish early due to a Limit operation, the plan rows of the Limit operation will reflect this, but the plan rows of its child operations will not.",
    "Plan Width":
      "The\nestimated\naverage size of the rows produced by the operation, in\nbytes\n.",
    "Actual Startup Time":
      "The amount of time, in\nmilliseconds\n, it takes to get the first row out of the operation.\nSometimes, this is very close to the setup time — for example on a sequential scan which returns all the rows in a table.\nOther times, though, it’s more or less the total time. For example, in order to return the first row of a sort, you have to sort all of the rows to work out which one comes first.",
    "Actual Total Time":
      "The actual amount of time in milliseconds spent on this operation\nand all of its children\n. It’s a\nper-loop average\n, rounded to the nearest thousandth of a millisecond.\nWorking out individual operation timings, especially where CTEs and SubPlans are concerned, can be tricky. This is one of the main reasons we decided to build\npgMustard\n.",
    "Actual Rows":
      "The number of rows returned by the operation\nper loop\n.\nThe important thing to notice about this is that it’s an average of all the loops executed, rounded to the nearest integer. This means that while “Actual Loops” multiplied by “Actual Rows” is a pretty good approximation for total number of rows returned most of the time, it can be off by as much as half of the number of loops. Usually it’s just slightly confusing as you see a row or two appear or disappear between operations, but on operations with lots of loops there is potential for serious miscalculation.\nPoor row estimates, where Actual Rows differs substantially from Plan Rows, can lead to suboptimal query planning. Estimates can often be improved by running\nANALYZE\n(not the EXPLAIN parameter), by increasing statistics, or by allowing Postgres to understand correlation between columns using multivariate statistics.",
    "Actual Loops":
      "The number of times the operation is executed. For a lot of operations it will have a value of one, but when it is not, there are three different cases:\nSome operations can be executed more than once. For example, “Nested Loops” run their “Inner” child once for every row returned by their “Outer” child.\nWhen an operation that would normally only consist of one loop is split across multiple threads, each partial operation is counted as a Loop.\nThe number of loops can be zero when an operation doesn’t need to be executed at all. For example if a table read is planned to provide candidates for an inner join, but there turns out to be no rows on the other side of the join, the operation can be effectively eliminated.",
    Output:
      "A list of the columns returned by the operation.\nThis is only shown when VERBOSE is on.",
    "Shared Hit Blocks":
      "The number of blocks from indexes/tables that were found in the Postgres buffer cache.\nThis\nincludes\nvalues for child operations and is a\ntotal\nvalue (i.e. not a per-loop average).\nOnce you have subtracted child operation values, the proportion of shared hit to shared read blocks is an interesting measure of cache performance.\nThe ratio of shared blocks (hit plus read) to rows processed (including any filtered out) is also interesting: a high ratio means Postgres is reading a lot of data for what it is doing, which can be a sign of bloat.",
    "Shared Read Blocks":
      "The number of blocks from tables/indexes that were read from disk (or the OS cache).\nThis\nincludes\nvalues for child operations and is a\ntotal\nvalue (i.e. not per-loop).\nOnce you have subtracted child operation values, the proportion of shared hit to shared read blocks is an interesting measure of cache performance.\nThe ratio of shared blocks (hit plus read) to rows processed (including any filtered out) is also interesting: a high ratio means Postgres is reading a lot of data for what it is doing, which can be a sign of bloat.",
    "Shared Dirtied Blocks":
      "The number of blocks from tables/indexes that were modified by the operation.\nThis\nincludes\nvalues for child operations and is a\ntotal\nvalue (i.e. not per-loop).\nInterestingly, a SELECT query can report shared dirtied blocks when setting hint bits on recently-committed rows, or pruning old row versions. While somewhat surprising, both of these are perfectly normal and healthy.",
    "Shared Written Blocks":
      "The number of blocks from tables/indexes that were evicted from the cache.\nThis\nincludes\nvalues for child operations and is a\ntotal\nvalue (i.e. not a per-loop average).",
    "Local Hit Blocks":
      "The number of blocks from temporary tables and indexes that were found in the cache.\nThis\nincludes\nvalues for child operations and is a\ntotal\nvalue (not a per-loop average).",
    "Local Read Blocks":
      "The number of blocks read from\ntemporary tables and indexes that were not found in the Postgres cache (read from disk or the OS cache).\nThis\nincludes\nvalues for child operations and is a\ntotal\nvalue (not a per-loop average).",
    "Local Dirtied Blocks":
      "The number of blocks from\ntemporary tables and indexes that have been modified by the operation.\nThis\nincludes\nvalues for child operations and is a\ntotal\nvalue (i.e. not a per-loop average).",
    "Local Written Blocks":
      "The number of blocks from\ntemporary tables and indexes that were evicted from the cache.\nThis\nincludes\nvalues for child operations and is a\ntotal\nvalue (i.e. not a per-loop average).",
    "Temp Read Blocks":
      "The number of blocks read from short-term data used to calculate hashes, sorts, Materialize operations, and similar.\nThis\nincludes\nvalues for child operations and is a\ntotal\nvalue (i.e. not a per-loop average).\nYour settings of\nwork_mem\nand\nhash_mem_multiplier\ndetermine how much memory is available to Postgres per operation.",
    "Temp Written Blocks":
      "The number of blocks from short-term data (used to calculate operations like hashes, sorts, and materializes) that were evicted from the cache.\nThis\nincludes\nvalues for child operations and is a\ntotal\nvalue (i.e. not a per-loop average).\nYour settings of\nwork_mem\nand\nhash_mem_multiplier\ndetermine how much memory is available to Postgres per operation.",
    "Shared I/O Read Time":
      "The time spent reading data from tables and indexes, in\nmilliseconds\n.\nThis\nincludes\nvalues for child operations and is a total value (not a per-loop average).\nRequires\ntrack_io_timing\nand\nBUFFERS\nto be on.\nIn the latest version, the text format of explain displays this as\nI/O Timings: shared read\nIn PostgreSQL 15 and 16 it shows as a combined metric\nI/O Timings: shared/local read\nGetting timing information has an overhead, due to checking the system clock. You can use\npg_test_timing\nto measure this for your system.",
    "Shared I/O Write Time":
      "The time spent writing data for tables and indexes, in\nmilliseconds\n.\nThis\nincludes\nvalues for child operations and is a total value (not a per-loop average).\nRequires\ntrack_io_timing\nand\nBUFFERS\nto be on.\nIn the latest version, the text format of explain displays this as\nI/O Timings: shared write\nIn PostgreSQL 15 and 16 it shows as a combined metric\nI/O Timings: shared/local write\nGetting timing information has an overhead, due to checking the system clock. You can use\npg_test_timing\nto measure this for your system.",
    "Local I/O Read Time":
      "The time spent reading local data (e.g. from temporary tables and indexes), in\nmilliseconds\n.\nThis\nincludes\nvalues for child operations and is a total value (i.e. not a per-loop average).\nThis was added as a separate field in PostgreSQL 17, and requires both\ntrack_io_timing\nand\nBUFFERS\n.\nIn the default text format, this will show as\nI/O Timings: local read\nIn versions 15 and 16 it is available as a combined metric as\nshared/local\nGetting timing information has an overhead, due to checking the system clock. You can use\npg_test_timing\nto measure this for your system.",
    "Local I/O Write Time":
      "The time spent writing local data (e.g. for temporary tables and indexes), in\nmilliseconds\n.\nThis\nincludes\nvalues for child operations and is a total value (i.e. not a per-loop average).\nThis was added as a separate field in PostgreSQL 17, and requires both\ntrack_io_timing\nand\nBUFFERS\n.\nIn the default text format, this will show as\nI/O Timings: local write\nIn versions 15 and 16 it is available as a combined metric as\nshared/local\nGetting timing information has an overhead, due to checking the system clock. You can use\npg_test_timing\nto measure this for your system.",
    "Temp I/O Read Time":
      "The time spent reading short-term data, in\nmilliseconds\n(for example during sort and hash operations that were not done in memory).\nThis\nincludes\nvalues for child operations and is a total value (i.e. not a per-loop average).\nThis was added in PostgreSQL 15, and requires both\ntrack_io_timing\nand\nBUFFERS\n.\nIn the text format of explain, this shows as\nI/O Timings: temp read\nGetting timing information has an overhead, due to checking the system clock. You can use\npg_test_timing\nto measure this for your system.",
    "Temp I/O Write Time":
      "The time spent writing short-term data, in\nmilliseconds\n(for example during sort and hash operations that were not done in memory).\nThis\nincludes\nvalues for child operations and is a total value (i.e. not a per-loop average).\nThis was added in PostgreSQL 15, and requires both\ntrack_io_timing\nand\nBUFFERS\n.\nIn the text format of explain, this shows as\nI/O Timings: temp write\nGetting timing information has an overhead, due to checking the system clock. You can use\npg_test_timing\nto measure this for your system.",
  },
  "CTE Scan": {
    "Parent Relationship":
      "A guide as to why this operation needs to be run in order to facilitate the parent operation. There are six different possibilities:\nOuter\n: The value you’ll see most often. It means “take in the rows from this operation as input, process them and pass them on”.\nInner\n: Only ever seen on the second child of join operations, and is always seen there. This is the “inner” part of the loop — for each outer row, we look up its match using this operation.\nMember\n: Used for all children of Append and ModifyTable nodes, and on bitmap processing nodes like BitmapAnd and BitmapOr operations.\nInitPlan\n: Used for calculations performed before the query can start, eg a constant referred to in the query or the result of a CTE scan.\nSubquery\n: The child is a subquery of the parent operation. Since Postgres always uses subquery scans to feed subquery data to parent queries, only ever appears on the children of subquery scans.\nSubPlan\n: Like a Subquery, represents a new query, but used when a subquery scan is not necessary.",
    "Parallel Aware":
      "Whether or not the operation will be run in a special mode to support parallelism. Some operations need to be aware that they are running in parallel, for example sequential scans need to know they only need to scan a smaller proportion of the table. Other operations can be run on several threads without each one having any knowledge of the others.",
    Alias: "The alias used to refer to the Relation Name object.",
    "Startup Cost":
      "The estimated cost of returning the first row.\nThis is in an arbitrary unit, with the aim of being correlated to the startup time.",
    "Total Cost":
      "The estimated cost of returning all rows. This is in an arbitrary unit, with the aim of being correlated to the total time.\nThe Postgres query planner often has several ways it could resolve the same query. It calculates costs — which are hopefully correlated with the time it would take — for potential plans, and then picks the one with the lowest cost. It’s worth bearing in mind that the costs are unit-free — they’re not designed to convert into time, or disk reads. They’re just supposed to be bigger for slower operations, and smaller for faster ones.\nIf the planner thinks it can finish early due to a parent Limit operation, the total cost of the Limit operation will reflect this, but the total cost of its child operations will not.",
    "Plan Rows":
      "The number of rows,\nper-loop\n, that the planner expects to be returned by the operation.\nPoor row estimates can lead to suboptimal query planning. They can often be improved by running\nANALYZE\n(not the EXPLAIN parameter), by increasing statistics, or by allowing Postgres to understand correlation between columns using multivariate statistics.\nIf the planner thinks it can finish early due to a Limit operation, the plan rows of the Limit operation will reflect this, but the plan rows of its child operations will not.",
    "Plan Width":
      "The\nestimated\naverage size of the rows produced by the operation, in\nbytes\n.",
    "Actual Startup Time":
      "The amount of time, in\nmilliseconds\n, it takes to get the first row out of the operation.\nSometimes, this is very close to the setup time — for example on a sequential scan which returns all the rows in a table.\nOther times, though, it’s more or less the total time. For example, in order to return the first row of a sort, you have to sort all of the rows to work out which one comes first.",
    "Actual Total Time":
      "The actual amount of time in milliseconds spent on this operation\nand all of its children\n. It’s a\nper-loop average\n, rounded to the nearest thousandth of a millisecond.\nWorking out individual operation timings, especially where CTEs and SubPlans are concerned, can be tricky. This is one of the main reasons we decided to build\npgMustard\n.",
    "Actual Rows":
      "The number of rows returned by the operation\nper loop\n.\nThe important thing to notice about this is that it’s an average of all the loops executed, rounded to the nearest integer. This means that while “Actual Loops” multiplied by “Actual Rows” is a pretty good approximation for total number of rows returned most of the time, it can be off by as much as half of the number of loops. Usually it’s just slightly confusing as you see a row or two appear or disappear between operations, but on operations with lots of loops there is potential for serious miscalculation.\nPoor row estimates, where Actual Rows differs substantially from Plan Rows, can lead to suboptimal query planning. Estimates can often be improved by running\nANALYZE\n(not the EXPLAIN parameter), by increasing statistics, or by allowing Postgres to understand correlation between columns using multivariate statistics.",
    "Actual Loops":
      "The number of times the operation is executed. For a lot of operations it will have a value of one, but when it is not, there are three different cases:\nSome operations can be executed more than once. For example, “Nested Loops” run their “Inner” child once for every row returned by their “Outer” child.\nWhen an operation that would normally only consist of one loop is split across multiple threads, each partial operation is counted as a Loop.\nThe number of loops can be zero when an operation doesn’t need to be executed at all. For example if a table read is planned to provide candidates for an inner join, but there turns out to be no rows on the other side of the join, the operation can be effectively eliminated.",
    Output:
      "A list of the columns returned by the operation.\nThis is only shown when VERBOSE is on.",
    Filter:
      "When present, this is a filter used to remove rows.\nThe important thing to note is that this is a filter in the traditional sense: these rows are read in (either from a data source or another operation in the plan), inspected, and then approved or removed based on the filter.\nIf a high proportion of rows are being removed by the Filter, you may want to investigate whether a (more) selective index could help.\nIf you notice a lot of rows being filtered late in a query plan, this might be due to an operation (like a GROUP BY or SORT) using more columns than are necessary, requiring joins to take place before rows can be discarded. It is also sometimes a result of unnecessary or ill-advised uses of DISTINCT.",
    "Rows Removed by Filter":
      "The number of rows removed by the\nFilter\n. This is a\nper-loop average\n, rounded to the nearest integer.\nIf a high proportion of rows are being removed, you may want to investigate whether a (more) selective index could help.",
    "Shared Hit Blocks":
      "The number of blocks from indexes/tables that were found in the Postgres buffer cache.\nThis\nincludes\nvalues for child operations and is a\ntotal\nvalue (i.e. not a per-loop average).\nOnce you have subtracted child operation values, the proportion of shared hit to shared read blocks is an interesting measure of cache performance.\nThe ratio of shared blocks (hit plus read) to rows processed (including any filtered out) is also interesting: a high ratio means Postgres is reading a lot of data for what it is doing, which can be a sign of bloat.",
    "Shared Read Blocks":
      "The number of blocks from tables/indexes that were read from disk (or the OS cache).\nThis\nincludes\nvalues for child operations and is a\ntotal\nvalue (i.e. not per-loop).\nOnce you have subtracted child operation values, the proportion of shared hit to shared read blocks is an interesting measure of cache performance.\nThe ratio of shared blocks (hit plus read) to rows processed (including any filtered out) is also interesting: a high ratio means Postgres is reading a lot of data for what it is doing, which can be a sign of bloat.",
    "Shared Dirtied Blocks":
      "The number of blocks from tables/indexes that were modified by the operation.\nThis\nincludes\nvalues for child operations and is a\ntotal\nvalue (i.e. not per-loop).\nInterestingly, a SELECT query can report shared dirtied blocks when setting hint bits on recently-committed rows, or pruning old row versions. While somewhat surprising, both of these are perfectly normal and healthy.",
    "Shared Written Blocks":
      "The number of blocks from tables/indexes that were evicted from the cache.\nThis\nincludes\nvalues for child operations and is a\ntotal\nvalue (i.e. not a per-loop average).",
    "Local Hit Blocks":
      "The number of blocks from temporary tables and indexes that were found in the cache.\nThis\nincludes\nvalues for child operations and is a\ntotal\nvalue (not a per-loop average).",
    "Local Read Blocks":
      "The number of blocks read from\ntemporary tables and indexes that were not found in the Postgres cache (read from disk or the OS cache).\nThis\nincludes\nvalues for child operations and is a\ntotal\nvalue (not a per-loop average).",
    "Local Dirtied Blocks":
      "The number of blocks from\ntemporary tables and indexes that have been modified by the operation.\nThis\nincludes\nvalues for child operations and is a\ntotal\nvalue (i.e. not a per-loop average).",
    "Local Written Blocks":
      "The number of blocks from\ntemporary tables and indexes that were evicted from the cache.\nThis\nincludes\nvalues for child operations and is a\ntotal\nvalue (i.e. not a per-loop average).",
    "Temp Read Blocks":
      "The number of blocks read from short-term data used to calculate hashes, sorts, Materialize operations, and similar.\nThis\nincludes\nvalues for child operations and is a\ntotal\nvalue (i.e. not a per-loop average).\nYour settings of\nwork_mem\nand\nhash_mem_multiplier\ndetermine how much memory is available to Postgres per operation.",
    "Temp Written Blocks":
      "The number of blocks from short-term data (used to calculate operations like hashes, sorts, and materializes) that were evicted from the cache.\nThis\nincludes\nvalues for child operations and is a\ntotal\nvalue (i.e. not a per-loop average).\nYour settings of\nwork_mem\nand\nhash_mem_multiplier\ndetermine how much memory is available to Postgres per operation.",
    "Shared I/O Read Time":
      "The time spent reading data from tables and indexes, in\nmilliseconds\n.\nThis\nincludes\nvalues for child operations and is a total value (not a per-loop average).\nRequires\ntrack_io_timing\nand\nBUFFERS\nto be on.\nIn the latest version, the text format of explain displays this as\nI/O Timings: shared read\nIn PostgreSQL 15 and 16 it shows as a combined metric\nI/O Timings: shared/local read\nGetting timing information has an overhead, due to checking the system clock. You can use\npg_test_timing\nto measure this for your system.",
    "Shared I/O Write Time":
      "The time spent writing data for tables and indexes, in\nmilliseconds\n.\nThis\nincludes\nvalues for child operations and is a total value (not a per-loop average).\nRequires\ntrack_io_timing\nand\nBUFFERS\nto be on.\nIn the latest version, the text format of explain displays this as\nI/O Timings: shared write\nIn PostgreSQL 15 and 16 it shows as a combined metric\nI/O Timings: shared/local write\nGetting timing information has an overhead, due to checking the system clock. You can use\npg_test_timing\nto measure this for your system.",
    "Local I/O Read Time":
      "The time spent reading local data (e.g. from temporary tables and indexes), in\nmilliseconds\n.\nThis\nincludes\nvalues for child operations and is a total value (i.e. not a per-loop average).\nThis was added as a separate field in PostgreSQL 17, and requires both\ntrack_io_timing\nand\nBUFFERS\n.\nIn the default text format, this will show as\nI/O Timings: local read\nIn versions 15 and 16 it is available as a combined metric as\nshared/local\nGetting timing information has an overhead, due to checking the system clock. You can use\npg_test_timing\nto measure this for your system.",
    "Local I/O Write Time":
      "The time spent writing local data (e.g. for temporary tables and indexes), in\nmilliseconds\n.\nThis\nincludes\nvalues for child operations and is a total value (i.e. not a per-loop average).\nThis was added as a separate field in PostgreSQL 17, and requires both\ntrack_io_timing\nand\nBUFFERS\n.\nIn the default text format, this will show as\nI/O Timings: local write\nIn versions 15 and 16 it is available as a combined metric as\nshared/local\nGetting timing information has an overhead, due to checking the system clock. You can use\npg_test_timing\nto measure this for your system.",
    "Temp I/O Read Time":
      "The time spent reading short-term data, in\nmilliseconds\n(for example during sort and hash operations that were not done in memory).\nThis\nincludes\nvalues for child operations and is a total value (i.e. not a per-loop average).\nThis was added in PostgreSQL 15, and requires both\ntrack_io_timing\nand\nBUFFERS\n.\nIn the text format of explain, this shows as\nI/O Timings: temp read\nGetting timing information has an overhead, due to checking the system clock. You can use\npg_test_timing\nto measure this for your system.",
    "Temp I/O Write Time":
      "The time spent writing short-term data, in\nmilliseconds\n(for example during sort and hash operations that were not done in memory).\nThis\nincludes\nvalues for child operations and is a total value (i.e. not a per-loop average).\nThis was added in PostgreSQL 15, and requires both\ntrack_io_timing\nand\nBUFFERS\n.\nIn the text format of explain, this shows as\nI/O Timings: temp write\nGetting timing information has an overhead, due to checking the system clock. You can use\npg_test_timing\nto measure this for your system.",
  },
  "Foreign Scan": {
    "Parent Relationship":
      "A guide as to why this operation needs to be run in order to facilitate the parent operation. There are six different possibilities:\nOuter\n: The value you’ll see most often. It means “take in the rows from this operation as input, process them and pass them on”.\nInner\n: Only ever seen on the second child of join operations, and is always seen there. This is the “inner” part of the loop — for each outer row, we look up its match using this operation.\nMember\n: Used for all children of Append and ModifyTable nodes, and on bitmap processing nodes like BitmapAnd and BitmapOr operations.\nInitPlan\n: Used for calculations performed before the query can start, eg a constant referred to in the query or the result of a CTE scan.\nSubquery\n: The child is a subquery of the parent operation. Since Postgres always uses subquery scans to feed subquery data to parent queries, only ever appears on the children of subquery scans.\nSubPlan\n: Like a Subquery, represents a new query, but used when a subquery scan is not necessary.",
    Operation:
      "The operation on the table — SELECT, INSERT, UPDATE, DELETE, or MERGE.",
    "Parallel Aware":
      "Whether or not the operation will be run in a special mode to support parallelism. Some operations need to be aware that they are running in parallel, for example sequential scans need to know they only need to scan a smaller proportion of the table. Other operations can be run on several threads without each one having any knowledge of the others.",
    "Async Capable":
      "As of PostgreSQL 14, queries referencing multiple foreign tables can now perform foreign table scans in parallel.\nThis happens if an Append node requests a tuple from an “async-capable”\nForeign Scan\nnode.",
    "Relation Name":
      "The data source being read/written from. Normally a table name (including when the data is accessed via an index), but can also be a materialised view or foreign data source.",
    Schema:
      "The schema of the “Relation Name” object.\nThis is only shown when VERBOSE is on.",
    Alias: "The alias used to refer to the Relation Name object.",
    "Startup Cost":
      "The estimated cost of returning the first row.\nThis is in an arbitrary unit, with the aim of being correlated to the startup time.",
    "Total Cost":
      "The estimated cost of returning all rows. This is in an arbitrary unit, with the aim of being correlated to the total time.\nThe Postgres query planner often has several ways it could resolve the same query. It calculates costs — which are hopefully correlated with the time it would take — for potential plans, and then picks the one with the lowest cost. It’s worth bearing in mind that the costs are unit-free — they’re not designed to convert into time, or disk reads. They’re just supposed to be bigger for slower operations, and smaller for faster ones.\nIf the planner thinks it can finish early due to a parent Limit operation, the total cost of the Limit operation will reflect this, but the total cost of its child operations will not.",
    "Plan Rows":
      "The number of rows,\nper-loop\n, that the planner expects to be returned by the operation.\nPoor row estimates can lead to suboptimal query planning. They can often be improved by running\nANALYZE\n(not the EXPLAIN parameter), by increasing statistics, or by allowing Postgres to understand correlation between columns using multivariate statistics.\nIf the planner thinks it can finish early due to a Limit operation, the plan rows of the Limit operation will reflect this, but the plan rows of its child operations will not.",
    "Plan Width":
      "The\nestimated\naverage size of the rows produced by the operation, in\nbytes\n.",
    "Actual Startup Time":
      "The amount of time, in\nmilliseconds\n, it takes to get the first row out of the operation.\nSometimes, this is very close to the setup time — for example on a sequential scan which returns all the rows in a table.\nOther times, though, it’s more or less the total time. For example, in order to return the first row of a sort, you have to sort all of the rows to work out which one comes first.",
    "Actual Total Time":
      "The actual amount of time in milliseconds spent on this operation\nand all of its children\n. It’s a\nper-loop average\n, rounded to the nearest thousandth of a millisecond.\nWorking out individual operation timings, especially where CTEs and SubPlans are concerned, can be tricky. This is one of the main reasons we decided to build\npgMustard\n.",
    "Actual Rows":
      "The number of rows returned by the operation\nper loop\n.\nThe important thing to notice about this is that it’s an average of all the loops executed, rounded to the nearest integer. This means that while “Actual Loops” multiplied by “Actual Rows” is a pretty good approximation for total number of rows returned most of the time, it can be off by as much as half of the number of loops. Usually it’s just slightly confusing as you see a row or two appear or disappear between operations, but on operations with lots of loops there is potential for serious miscalculation.\nPoor row estimates, where Actual Rows differs substantially from Plan Rows, can lead to suboptimal query planning. Estimates can often be improved by running\nANALYZE\n(not the EXPLAIN parameter), by increasing statistics, or by allowing Postgres to understand correlation between columns using multivariate statistics.",
    "Actual Loops":
      "The number of times the operation is executed. For a lot of operations it will have a value of one, but when it is not, there are three different cases:\nSome operations can be executed more than once. For example, “Nested Loops” run their “Inner” child once for every row returned by their “Outer” child.\nWhen an operation that would normally only consist of one loop is split across multiple threads, each partial operation is counted as a Loop.\nThe number of loops can be zero when an operation doesn’t need to be executed at all. For example if a table read is planned to provide candidates for an inner join, but there turns out to be no rows on the other side of the join, the operation can be effectively eliminated.",
    Filter:
      "When present, this is a filter used to remove rows.\nThe important thing to note is that this is a filter in the traditional sense: these rows are read in (either from a data source or another operation in the plan), inspected, and then approved or removed based on the filter.\nIf a high proportion of rows are being removed by the Filter, you may want to investigate whether a (more) selective index could help.\nIf you notice a lot of rows being filtered late in a query plan, this might be due to an operation (like a GROUP BY or SORT) using more columns than are necessary, requiring joins to take place before rows can be discarded. It is also sometimes a result of unnecessary or ill-advised uses of DISTINCT.",
    "Rows Removed by Filter":
      "The number of rows removed by the\nFilter\n. This is a\nper-loop average\n, rounded to the nearest integer.\nIf a high proportion of rows are being removed, you may want to investigate whether a (more) selective index could help.",
    "Remote SQL":
      "Remote SQL is the query run on the foreign table in a foreign scan operation.",
    "Shared Hit Blocks":
      "The number of blocks from indexes/tables that were found in the Postgres buffer cache.\nThis\nincludes\nvalues for child operations and is a\ntotal\nvalue (i.e. not a per-loop average).\nOnce you have subtracted child operation values, the proportion of shared hit to shared read blocks is an interesting measure of cache performance.\nThe ratio of shared blocks (hit plus read) to rows processed (including any filtered out) is also interesting: a high ratio means Postgres is reading a lot of data for what it is doing, which can be a sign of bloat.",
    "Shared Read Blocks":
      "The number of blocks from tables/indexes that were read from disk (or the OS cache).\nThis\nincludes\nvalues for child operations and is a\ntotal\nvalue (i.e. not per-loop).\nOnce you have subtracted child operation values, the proportion of shared hit to shared read blocks is an interesting measure of cache performance.\nThe ratio of shared blocks (hit plus read) to rows processed (including any filtered out) is also interesting: a high ratio means Postgres is reading a lot of data for what it is doing, which can be a sign of bloat.",
    "Shared Dirtied Blocks":
      "The number of blocks from tables/indexes that were modified by the operation.\nThis\nincludes\nvalues for child operations and is a\ntotal\nvalue (i.e. not per-loop).\nInterestingly, a SELECT query can report shared dirtied blocks when setting hint bits on recently-committed rows, or pruning old row versions. While somewhat surprising, both of these are perfectly normal and healthy.",
    "Shared Written Blocks":
      "The number of blocks from tables/indexes that were evicted from the cache.\nThis\nincludes\nvalues for child operations and is a\ntotal\nvalue (i.e. not a per-loop average).",
    "Local Hit Blocks":
      "The number of blocks from temporary tables and indexes that were found in the cache.\nThis\nincludes\nvalues for child operations and is a\ntotal\nvalue (not a per-loop average).",
    "Local Read Blocks":
      "The number of blocks read from\ntemporary tables and indexes that were not found in the Postgres cache (read from disk or the OS cache).\nThis\nincludes\nvalues for child operations and is a\ntotal\nvalue (not a per-loop average).",
    "Local Dirtied Blocks":
      "The number of blocks from\ntemporary tables and indexes that have been modified by the operation.\nThis\nincludes\nvalues for child operations and is a\ntotal\nvalue (i.e. not a per-loop average).",
    "Local Written Blocks":
      "The number of blocks from\ntemporary tables and indexes that were evicted from the cache.\nThis\nincludes\nvalues for child operations and is a\ntotal\nvalue (i.e. not a per-loop average).",
    "Temp Read Blocks":
      "The number of blocks read from short-term data used to calculate hashes, sorts, Materialize operations, and similar.\nThis\nincludes\nvalues for child operations and is a\ntotal\nvalue (i.e. not a per-loop average).\nYour settings of\nwork_mem\nand\nhash_mem_multiplier\ndetermine how much memory is available to Postgres per operation.",
    "Temp Written Blocks":
      "The number of blocks from short-term data (used to calculate operations like hashes, sorts, and materializes) that were evicted from the cache.\nThis\nincludes\nvalues for child operations and is a\ntotal\nvalue (i.e. not a per-loop average).\nYour settings of\nwork_mem\nand\nhash_mem_multiplier\ndetermine how much memory is available to Postgres per operation.",
    "Shared I/O Read Time":
      "The time spent reading data from tables and indexes, in\nmilliseconds\n.\nThis\nincludes\nvalues for child operations and is a total value (not a per-loop average).\nRequires\ntrack_io_timing\nand\nBUFFERS\nto be on.\nIn the latest version, the text format of explain displays this as\nI/O Timings: shared read\nIn PostgreSQL 15 and 16 it shows as a combined metric\nI/O Timings: shared/local read\nGetting timing information has an overhead, due to checking the system clock. You can use\npg_test_timing\nto measure this for your system.",
    "Shared I/O Write Time":
      "The time spent writing data for tables and indexes, in\nmilliseconds\n.\nThis\nincludes\nvalues for child operations and is a total value (not a per-loop average).\nRequires\ntrack_io_timing\nand\nBUFFERS\nto be on.\nIn the latest version, the text format of explain displays this as\nI/O Timings: shared write\nIn PostgreSQL 15 and 16 it shows as a combined metric\nI/O Timings: shared/local write\nGetting timing information has an overhead, due to checking the system clock. You can use\npg_test_timing\nto measure this for your system.",
    "Local I/O Read Time":
      "The time spent reading local data (e.g. from temporary tables and indexes), in\nmilliseconds\n.\nThis\nincludes\nvalues for child operations and is a total value (i.e. not a per-loop average).\nThis was added as a separate field in PostgreSQL 17, and requires both\ntrack_io_timing\nand\nBUFFERS\n.\nIn the default text format, this will show as\nI/O Timings: local read\nIn versions 15 and 16 it is available as a combined metric as\nshared/local\nGetting timing information has an overhead, due to checking the system clock. You can use\npg_test_timing\nto measure this for your system.",
    "Local I/O Write Time":
      "The time spent writing local data (e.g. for temporary tables and indexes), in\nmilliseconds\n.\nThis\nincludes\nvalues for child operations and is a total value (i.e. not a per-loop average).\nThis was added as a separate field in PostgreSQL 17, and requires both\ntrack_io_timing\nand\nBUFFERS\n.\nIn the default text format, this will show as\nI/O Timings: local write\nIn versions 15 and 16 it is available as a combined metric as\nshared/local\nGetting timing information has an overhead, due to checking the system clock. You can use\npg_test_timing\nto measure this for your system.",
    "Temp I/O Read Time":
      "The time spent reading short-term data, in\nmilliseconds\n(for example during sort and hash operations that were not done in memory).\nThis\nincludes\nvalues for child operations and is a total value (i.e. not a per-loop average).\nThis was added in PostgreSQL 15, and requires both\ntrack_io_timing\nand\nBUFFERS\n.\nIn the text format of explain, this shows as\nI/O Timings: temp read\nGetting timing information has an overhead, due to checking the system clock. You can use\npg_test_timing\nto measure this for your system.",
    "Temp I/O Write Time":
      "The time spent writing short-term data, in\nmilliseconds\n(for example during sort and hash operations that were not done in memory).\nThis\nincludes\nvalues for child operations and is a total value (i.e. not a per-loop average).\nThis was added in PostgreSQL 15, and requires both\ntrack_io_timing\nand\nBUFFERS\n.\nIn the text format of explain, this shows as\nI/O Timings: temp write\nGetting timing information has an overhead, due to checking the system clock. You can use\npg_test_timing\nto measure this for your system.",
  },
  "Function Scan": {
    "Parent Relationship":
      "A guide as to why this operation needs to be run in order to facilitate the parent operation. There are six different possibilities:\nOuter\n: The value you’ll see most often. It means “take in the rows from this operation as input, process them and pass them on”.\nInner\n: Only ever seen on the second child of join operations, and is always seen there. This is the “inner” part of the loop — for each outer row, we look up its match using this operation.\nMember\n: Used for all children of Append and ModifyTable nodes, and on bitmap processing nodes like BitmapAnd and BitmapOr operations.\nInitPlan\n: Used for calculations performed before the query can start, eg a constant referred to in the query or the result of a CTE scan.\nSubquery\n: The child is a subquery of the parent operation. Since Postgres always uses subquery scans to feed subquery data to parent queries, only ever appears on the children of subquery scans.\nSubPlan\n: Like a Subquery, represents a new query, but used when a subquery scan is not necessary.",
    "Parallel Aware":
      "Whether or not the operation will be run in a special mode to support parallelism. Some operations need to be aware that they are running in parallel, for example sequential scans need to know they only need to scan a smaller proportion of the table. Other operations can be run on several threads without each one having any knowledge of the others.",
    Schema:
      "The schema of the “Relation Name” object.\nThis is only shown when VERBOSE is on.",
    Alias: "The alias used to refer to the Relation Name object.",
    "Startup Cost":
      "The estimated cost of returning the first row.\nThis is in an arbitrary unit, with the aim of being correlated to the startup time.",
    "Total Cost":
      "The estimated cost of returning all rows. This is in an arbitrary unit, with the aim of being correlated to the total time.\nThe Postgres query planner often has several ways it could resolve the same query. It calculates costs — which are hopefully correlated with the time it would take — for potential plans, and then picks the one with the lowest cost. It’s worth bearing in mind that the costs are unit-free — they’re not designed to convert into time, or disk reads. They’re just supposed to be bigger for slower operations, and smaller for faster ones.\nIf the planner thinks it can finish early due to a parent Limit operation, the total cost of the Limit operation will reflect this, but the total cost of its child operations will not.",
    "Plan Rows":
      "The number of rows,\nper-loop\n, that the planner expects to be returned by the operation.\nPoor row estimates can lead to suboptimal query planning. They can often be improved by running\nANALYZE\n(not the EXPLAIN parameter), by increasing statistics, or by allowing Postgres to understand correlation between columns using multivariate statistics.\nIf the planner thinks it can finish early due to a Limit operation, the plan rows of the Limit operation will reflect this, but the plan rows of its child operations will not.",
    "Plan Width":
      "The\nestimated\naverage size of the rows produced by the operation, in\nbytes\n.",
    "Actual Startup Time":
      "The amount of time, in\nmilliseconds\n, it takes to get the first row out of the operation.\nSometimes, this is very close to the setup time — for example on a sequential scan which returns all the rows in a table.\nOther times, though, it’s more or less the total time. For example, in order to return the first row of a sort, you have to sort all of the rows to work out which one comes first.",
    "Actual Total Time":
      "The actual amount of time in milliseconds spent on this operation\nand all of its children\n. It’s a\nper-loop average\n, rounded to the nearest thousandth of a millisecond.\nWorking out individual operation timings, especially where CTEs and SubPlans are concerned, can be tricky. This is one of the main reasons we decided to build\npgMustard\n.",
    "Actual Rows":
      "The number of rows returned by the operation\nper loop\n.\nThe important thing to notice about this is that it’s an average of all the loops executed, rounded to the nearest integer. This means that while “Actual Loops” multiplied by “Actual Rows” is a pretty good approximation for total number of rows returned most of the time, it can be off by as much as half of the number of loops. Usually it’s just slightly confusing as you see a row or two appear or disappear between operations, but on operations with lots of loops there is potential for serious miscalculation.\nPoor row estimates, where Actual Rows differs substantially from Plan Rows, can lead to suboptimal query planning. Estimates can often be improved by running\nANALYZE\n(not the EXPLAIN parameter), by increasing statistics, or by allowing Postgres to understand correlation between columns using multivariate statistics.",
    "Actual Loops":
      "The number of times the operation is executed. For a lot of operations it will have a value of one, but when it is not, there are three different cases:\nSome operations can be executed more than once. For example, “Nested Loops” run their “Inner” child once for every row returned by their “Outer” child.\nWhen an operation that would normally only consist of one loop is split across multiple threads, each partial operation is counted as a Loop.\nThe number of loops can be zero when an operation doesn’t need to be executed at all. For example if a table read is planned to provide candidates for an inner join, but there turns out to be no rows on the other side of the join, the operation can be effectively eliminated.",
    Output:
      "A list of the columns returned by the operation.\nThis is only shown when VERBOSE is on.",
    Filter:
      "When present, this is a filter used to remove rows.\nThe important thing to note is that this is a filter in the traditional sense: these rows are read in (either from a data source or another operation in the plan), inspected, and then approved or removed based on the filter.\nIf a high proportion of rows are being removed by the Filter, you may want to investigate whether a (more) selective index could help.\nIf you notice a lot of rows being filtered late in a query plan, this might be due to an operation (like a GROUP BY or SORT) using more columns than are necessary, requiring joins to take place before rows can be discarded. It is also sometimes a result of unnecessary or ill-advised uses of DISTINCT.",
    "Rows Removed by Filter":
      "The number of rows removed by the\nFilter\n. This is a\nper-loop average\n, rounded to the nearest integer.\nIf a high proportion of rows are being removed, you may want to investigate whether a (more) selective index could help.",
    "Shared Hit Blocks":
      "The number of blocks from indexes/tables that were found in the Postgres buffer cache.\nThis\nincludes\nvalues for child operations and is a\ntotal\nvalue (i.e. not a per-loop average).\nOnce you have subtracted child operation values, the proportion of shared hit to shared read blocks is an interesting measure of cache performance.\nThe ratio of shared blocks (hit plus read) to rows processed (including any filtered out) is also interesting: a high ratio means Postgres is reading a lot of data for what it is doing, which can be a sign of bloat.",
    "Shared Read Blocks":
      "The number of blocks from tables/indexes that were read from disk (or the OS cache).\nThis\nincludes\nvalues for child operations and is a\ntotal\nvalue (i.e. not per-loop).\nOnce you have subtracted child operation values, the proportion of shared hit to shared read blocks is an interesting measure of cache performance.\nThe ratio of shared blocks (hit plus read) to rows processed (including any filtered out) is also interesting: a high ratio means Postgres is reading a lot of data for what it is doing, which can be a sign of bloat.",
    "Shared Dirtied Blocks":
      "The number of blocks from tables/indexes that were modified by the operation.\nThis\nincludes\nvalues for child operations and is a\ntotal\nvalue (i.e. not per-loop).\nInterestingly, a SELECT query can report shared dirtied blocks when setting hint bits on recently-committed rows, or pruning old row versions. While somewhat surprising, both of these are perfectly normal and healthy.",
    "Shared Written Blocks":
      "The number of blocks from tables/indexes that were evicted from the cache.\nThis\nincludes\nvalues for child operations and is a\ntotal\nvalue (i.e. not a per-loop average).",
    "Local Hit Blocks":
      "The number of blocks from temporary tables and indexes that were found in the cache.\nThis\nincludes\nvalues for child operations and is a\ntotal\nvalue (not a per-loop average).",
    "Local Read Blocks":
      "The number of blocks read from\ntemporary tables and indexes that were not found in the Postgres cache (read from disk or the OS cache).\nThis\nincludes\nvalues for child operations and is a\ntotal\nvalue (not a per-loop average).",
    "Local Dirtied Blocks":
      "The number of blocks from\ntemporary tables and indexes that have been modified by the operation.\nThis\nincludes\nvalues for child operations and is a\ntotal\nvalue (i.e. not a per-loop average).",
    "Local Written Blocks":
      "The number of blocks from\ntemporary tables and indexes that were evicted from the cache.\nThis\nincludes\nvalues for child operations and is a\ntotal\nvalue (i.e. not a per-loop average).",
    "Temp Read Blocks":
      "The number of blocks read from short-term data used to calculate hashes, sorts, Materialize operations, and similar.\nThis\nincludes\nvalues for child operations and is a\ntotal\nvalue (i.e. not a per-loop average).\nYour settings of\nwork_mem\nand\nhash_mem_multiplier\ndetermine how much memory is available to Postgres per operation.",
    "Temp Written Blocks":
      "The number of blocks from short-term data (used to calculate operations like hashes, sorts, and materializes) that were evicted from the cache.\nThis\nincludes\nvalues for child operations and is a\ntotal\nvalue (i.e. not a per-loop average).\nYour settings of\nwork_mem\nand\nhash_mem_multiplier\ndetermine how much memory is available to Postgres per operation.",
    "Shared I/O Read Time":
      "The time spent reading data from tables and indexes, in\nmilliseconds\n.\nThis\nincludes\nvalues for child operations and is a total value (not a per-loop average).\nRequires\ntrack_io_timing\nand\nBUFFERS\nto be on.\nIn the latest version, the text format of explain displays this as\nI/O Timings: shared read\nIn PostgreSQL 15 and 16 it shows as a combined metric\nI/O Timings: shared/local read\nGetting timing information has an overhead, due to checking the system clock. You can use\npg_test_timing\nto measure this for your system.",
    "Shared I/O Write Time":
      "The time spent writing data for tables and indexes, in\nmilliseconds\n.\nThis\nincludes\nvalues for child operations and is a total value (not a per-loop average).\nRequires\ntrack_io_timing\nand\nBUFFERS\nto be on.\nIn the latest version, the text format of explain displays this as\nI/O Timings: shared write\nIn PostgreSQL 15 and 16 it shows as a combined metric\nI/O Timings: shared/local write\nGetting timing information has an overhead, due to checking the system clock. You can use\npg_test_timing\nto measure this for your system.",
    "Local I/O Read Time":
      "The time spent reading local data (e.g. from temporary tables and indexes), in\nmilliseconds\n.\nThis\nincludes\nvalues for child operations and is a total value (i.e. not a per-loop average).\nThis was added as a separate field in PostgreSQL 17, and requires both\ntrack_io_timing\nand\nBUFFERS\n.\nIn the default text format, this will show as\nI/O Timings: local read\nIn versions 15 and 16 it is available as a combined metric as\nshared/local\nGetting timing information has an overhead, due to checking the system clock. You can use\npg_test_timing\nto measure this for your system.",
    "Local I/O Write Time":
      "The time spent writing local data (e.g. for temporary tables and indexes), in\nmilliseconds\n.\nThis\nincludes\nvalues for child operations and is a total value (i.e. not a per-loop average).\nThis was added as a separate field in PostgreSQL 17, and requires both\ntrack_io_timing\nand\nBUFFERS\n.\nIn the default text format, this will show as\nI/O Timings: local write\nIn versions 15 and 16 it is available as a combined metric as\nshared/local\nGetting timing information has an overhead, due to checking the system clock. You can use\npg_test_timing\nto measure this for your system.",
    "Temp I/O Read Time":
      "The time spent reading short-term data, in\nmilliseconds\n(for example during sort and hash operations that were not done in memory).\nThis\nincludes\nvalues for child operations and is a total value (i.e. not a per-loop average).\nThis was added in PostgreSQL 15, and requires both\ntrack_io_timing\nand\nBUFFERS\n.\nIn the text format of explain, this shows as\nI/O Timings: temp read\nGetting timing information has an overhead, due to checking the system clock. You can use\npg_test_timing\nto measure this for your system.",
    "Temp I/O Write Time":
      "The time spent writing short-term data, in\nmilliseconds\n(for example during sort and hash operations that were not done in memory).\nThis\nincludes\nvalues for child operations and is a total value (i.e. not a per-loop average).\nThis was added in PostgreSQL 15, and requires both\ntrack_io_timing\nand\nBUFFERS\n.\nIn the text format of explain, this shows as\nI/O Timings: temp write\nGetting timing information has an overhead, due to checking the system clock. You can use\npg_test_timing\nto measure this for your system.",
    Workers:
      "A summary of the operation detail broken down by thread.\nThese entries\ndon’t\ninclude the main (or leader) thread.\nYou can work out the values for the main thread by subtracting the worker statistics from the total.\nThis information is only shown when VERBOSE is on.",
  },
  Gather: {
    "Parent Relationship":
      "A guide as to why this operation needs to be run in order to facilitate the parent operation. There are six different possibilities:\nOuter\n: The value you’ll see most often. It means “take in the rows from this operation as input, process them and pass them on”.\nInner\n: Only ever seen on the second child of join operations, and is always seen there. This is the “inner” part of the loop — for each outer row, we look up its match using this operation.\nMember\n: Used for all children of Append and ModifyTable nodes, and on bitmap processing nodes like BitmapAnd and BitmapOr operations.\nInitPlan\n: Used for calculations performed before the query can start, eg a constant referred to in the query or the result of a CTE scan.\nSubquery\n: The child is a subquery of the parent operation. Since Postgres always uses subquery scans to feed subquery data to parent queries, only ever appears on the children of subquery scans.\nSubPlan\n: Like a Subquery, represents a new query, but used when a subquery scan is not necessary.",
    "Parallel Aware":
      "Whether or not the operation will be run in a special mode to support parallelism. Some operations need to be aware that they are running in parallel, for example sequential scans need to know they only need to scan a smaller proportion of the table. Other operations can be run on several threads without each one having any knowledge of the others.",
    "Startup Cost":
      "The estimated cost of returning the first row.\nThis is in an arbitrary unit, with the aim of being correlated to the startup time.",
    "Total Cost":
      "The estimated cost of returning all rows. This is in an arbitrary unit, with the aim of being correlated to the total time.\nThe Postgres query planner often has several ways it could resolve the same query. It calculates costs — which are hopefully correlated with the time it would take — for potential plans, and then picks the one with the lowest cost. It’s worth bearing in mind that the costs are unit-free — they’re not designed to convert into time, or disk reads. They’re just supposed to be bigger for slower operations, and smaller for faster ones.\nIf the planner thinks it can finish early due to a parent Limit operation, the total cost of the Limit operation will reflect this, but the total cost of its child operations will not.",
    "Plan Rows":
      "The number of rows,\nper-loop\n, that the planner expects to be returned by the operation.\nPoor row estimates can lead to suboptimal query planning. They can often be improved by running\nANALYZE\n(not the EXPLAIN parameter), by increasing statistics, or by allowing Postgres to understand correlation between columns using multivariate statistics.\nIf the planner thinks it can finish early due to a Limit operation, the plan rows of the Limit operation will reflect this, but the plan rows of its child operations will not.",
    "Plan Width":
      "The\nestimated\naverage size of the rows produced by the operation, in\nbytes\n.",
    "Actual Startup Time":
      "The amount of time, in\nmilliseconds\n, it takes to get the first row out of the operation.\nSometimes, this is very close to the setup time — for example on a sequential scan which returns all the rows in a table.\nOther times, though, it’s more or less the total time. For example, in order to return the first row of a sort, you have to sort all of the rows to work out which one comes first.",
    "Actual Total Time":
      "The actual amount of time in milliseconds spent on this operation\nand all of its children\n. It’s a\nper-loop average\n, rounded to the nearest thousandth of a millisecond.\nWorking out individual operation timings, especially where CTEs and SubPlans are concerned, can be tricky. This is one of the main reasons we decided to build\npgMustard\n.",
    "Actual Rows":
      "The number of rows returned by the operation\nper loop\n.\nThe important thing to notice about this is that it’s an average of all the loops executed, rounded to the nearest integer. This means that while “Actual Loops” multiplied by “Actual Rows” is a pretty good approximation for total number of rows returned most of the time, it can be off by as much as half of the number of loops. Usually it’s just slightly confusing as you see a row or two appear or disappear between operations, but on operations with lots of loops there is potential for serious miscalculation.\nPoor row estimates, where Actual Rows differs substantially from Plan Rows, can lead to suboptimal query planning. Estimates can often be improved by running\nANALYZE\n(not the EXPLAIN parameter), by increasing statistics, or by allowing Postgres to understand correlation between columns using multivariate statistics.",
    "Actual Loops":
      "The number of times the operation is executed. For a lot of operations it will have a value of one, but when it is not, there are three different cases:\nSome operations can be executed more than once. For example, “Nested Loops” run their “Inner” child once for every row returned by their “Outer” child.\nWhen an operation that would normally only consist of one loop is split across multiple threads, each partial operation is counted as a Loop.\nThe number of loops can be zero when an operation doesn’t need to be executed at all. For example if a table read is planned to provide candidates for an inner join, but there turns out to be no rows on the other side of the join, the operation can be effectively eliminated.",
    Output:
      "A list of the columns returned by the operation.\nThis is only shown when VERBOSE is on.",
    "Workers Planned":
      "The number of\nadditional\nworker processes requested by the planner. This does not include the main process.\nHow Postgres determines this number, and any discrepancy with Workers Launched, are well documented in\nthe official parallel query docs\n.",
    "Workers Launched":
      "The number of\nadditional\nworker processes. This does not include the main process.\nHow Postgres determines this number, and any discrepancy with Workers Planned, are well documented in\nthe official parallel query docs\n.",
    "Single Copy":
      "This is\ntrue\nif Postgres will not execute a plan more than once.\nAs such, if you see this alongside “Workers Planned: 1” then the main process would (or did) not do anything in parallel.\nIf you do not see it in a text format query plan, you can assume it is\nfalse\n.",
    "Shared Hit Blocks":
      "The number of blocks from indexes/tables that were found in the Postgres buffer cache.\nThis\nincludes\nvalues for child operations and is a\ntotal\nvalue (i.e. not a per-loop average).\nOnce you have subtracted child operation values, the proportion of shared hit to shared read blocks is an interesting measure of cache performance.\nThe ratio of shared blocks (hit plus read) to rows processed (including any filtered out) is also interesting: a high ratio means Postgres is reading a lot of data for what it is doing, which can be a sign of bloat.",
    "Shared Read Blocks":
      "The number of blocks from tables/indexes that were read from disk (or the OS cache).\nThis\nincludes\nvalues for child operations and is a\ntotal\nvalue (i.e. not per-loop).\nOnce you have subtracted child operation values, the proportion of shared hit to shared read blocks is an interesting measure of cache performance.\nThe ratio of shared blocks (hit plus read) to rows processed (including any filtered out) is also interesting: a high ratio means Postgres is reading a lot of data for what it is doing, which can be a sign of bloat.",
    "Shared Dirtied Blocks":
      "The number of blocks from tables/indexes that were modified by the operation.\nThis\nincludes\nvalues for child operations and is a\ntotal\nvalue (i.e. not per-loop).\nInterestingly, a SELECT query can report shared dirtied blocks when setting hint bits on recently-committed rows, or pruning old row versions. While somewhat surprising, both of these are perfectly normal and healthy.",
    "Shared Written Blocks":
      "The number of blocks from tables/indexes that were evicted from the cache.\nThis\nincludes\nvalues for child operations and is a\ntotal\nvalue (i.e. not a per-loop average).",
    "Local Hit Blocks":
      "The number of blocks from temporary tables and indexes that were found in the cache.\nThis\nincludes\nvalues for child operations and is a\ntotal\nvalue (not a per-loop average).",
    "Local Read Blocks":
      "The number of blocks read from\ntemporary tables and indexes that were not found in the Postgres cache (read from disk or the OS cache).\nThis\nincludes\nvalues for child operations and is a\ntotal\nvalue (not a per-loop average).",
    "Local Dirtied Blocks":
      "The number of blocks from\ntemporary tables and indexes that have been modified by the operation.\nThis\nincludes\nvalues for child operations and is a\ntotal\nvalue (i.e. not a per-loop average).",
    "Local Written Blocks":
      "The number of blocks from\ntemporary tables and indexes that were evicted from the cache.\nThis\nincludes\nvalues for child operations and is a\ntotal\nvalue (i.e. not a per-loop average).",
    "Temp Read Blocks":
      "The number of blocks read from short-term data used to calculate hashes, sorts, Materialize operations, and similar.\nThis\nincludes\nvalues for child operations and is a\ntotal\nvalue (i.e. not a per-loop average).\nYour settings of\nwork_mem\nand\nhash_mem_multiplier\ndetermine how much memory is available to Postgres per operation.",
    "Temp Written Blocks":
      "The number of blocks from short-term data (used to calculate operations like hashes, sorts, and materializes) that were evicted from the cache.\nThis\nincludes\nvalues for child operations and is a\ntotal\nvalue (i.e. not a per-loop average).\nYour settings of\nwork_mem\nand\nhash_mem_multiplier\ndetermine how much memory is available to Postgres per operation.",
    "Shared I/O Read Time":
      "The time spent reading data from tables and indexes, in\nmilliseconds\n.\nThis\nincludes\nvalues for child operations and is a total value (not a per-loop average).\nRequires\ntrack_io_timing\nand\nBUFFERS\nto be on.\nIn the latest version, the text format of explain displays this as\nI/O Timings: shared read\nIn PostgreSQL 15 and 16 it shows as a combined metric\nI/O Timings: shared/local read\nGetting timing information has an overhead, due to checking the system clock. You can use\npg_test_timing\nto measure this for your system.",
    "Shared I/O Write Time":
      "The time spent writing data for tables and indexes, in\nmilliseconds\n.\nThis\nincludes\nvalues for child operations and is a total value (not a per-loop average).\nRequires\ntrack_io_timing\nand\nBUFFERS\nto be on.\nIn the latest version, the text format of explain displays this as\nI/O Timings: shared write\nIn PostgreSQL 15 and 16 it shows as a combined metric\nI/O Timings: shared/local write\nGetting timing information has an overhead, due to checking the system clock. You can use\npg_test_timing\nto measure this for your system.",
    "Local I/O Read Time":
      "The time spent reading local data (e.g. from temporary tables and indexes), in\nmilliseconds\n.\nThis\nincludes\nvalues for child operations and is a total value (i.e. not a per-loop average).\nThis was added as a separate field in PostgreSQL 17, and requires both\ntrack_io_timing\nand\nBUFFERS\n.\nIn the default text format, this will show as\nI/O Timings: local read\nIn versions 15 and 16 it is available as a combined metric as\nshared/local\nGetting timing information has an overhead, due to checking the system clock. You can use\npg_test_timing\nto measure this for your system.",
    "Local I/O Write Time":
      "The time spent writing local data (e.g. for temporary tables and indexes), in\nmilliseconds\n.\nThis\nincludes\nvalues for child operations and is a total value (i.e. not a per-loop average).\nThis was added as a separate field in PostgreSQL 17, and requires both\ntrack_io_timing\nand\nBUFFERS\n.\nIn the default text format, this will show as\nI/O Timings: local write\nIn versions 15 and 16 it is available as a combined metric as\nshared/local\nGetting timing information has an overhead, due to checking the system clock. You can use\npg_test_timing\nto measure this for your system.",
    "Temp I/O Read Time":
      "The time spent reading short-term data, in\nmilliseconds\n(for example during sort and hash operations that were not done in memory).\nThis\nincludes\nvalues for child operations and is a total value (i.e. not a per-loop average).\nThis was added in PostgreSQL 15, and requires both\ntrack_io_timing\nand\nBUFFERS\n.\nIn the text format of explain, this shows as\nI/O Timings: temp read\nGetting timing information has an overhead, due to checking the system clock. You can use\npg_test_timing\nto measure this for your system.",
    "Temp I/O Write Time":
      "The time spent writing short-term data, in\nmilliseconds\n(for example during sort and hash operations that were not done in memory).\nThis\nincludes\nvalues for child operations and is a total value (i.e. not a per-loop average).\nThis was added in PostgreSQL 15, and requires both\ntrack_io_timing\nand\nBUFFERS\n.\nIn the text format of explain, this shows as\nI/O Timings: temp write\nGetting timing information has an overhead, due to checking the system clock. You can use\npg_test_timing\nto measure this for your system.",
  },
  "Gather Merge": {
    "Parent Relationship":
      "A guide as to why this operation needs to be run in order to facilitate the parent operation. There are six different possibilities:\nOuter\n: The value you’ll see most often. It means “take in the rows from this operation as input, process them and pass them on”.\nInner\n: Only ever seen on the second child of join operations, and is always seen there. This is the “inner” part of the loop — for each outer row, we look up its match using this operation.\nMember\n: Used for all children of Append and ModifyTable nodes, and on bitmap processing nodes like BitmapAnd and BitmapOr operations.\nInitPlan\n: Used for calculations performed before the query can start, eg a constant referred to in the query or the result of a CTE scan.\nSubquery\n: The child is a subquery of the parent operation. Since Postgres always uses subquery scans to feed subquery data to parent queries, only ever appears on the children of subquery scans.\nSubPlan\n: Like a Subquery, represents a new query, but used when a subquery scan is not necessary.",
    "Parallel Aware":
      "Whether or not the operation will be run in a special mode to support parallelism. Some operations need to be aware that they are running in parallel, for example sequential scans need to know they only need to scan a smaller proportion of the table. Other operations can be run on several threads without each one having any knowledge of the others.",
    "Startup Cost":
      "The estimated cost of returning the first row.\nThis is in an arbitrary unit, with the aim of being correlated to the startup time.",
    "Total Cost":
      "The estimated cost of returning all rows. This is in an arbitrary unit, with the aim of being correlated to the total time.\nThe Postgres query planner often has several ways it could resolve the same query. It calculates costs — which are hopefully correlated with the time it would take — for potential plans, and then picks the one with the lowest cost. It’s worth bearing in mind that the costs are unit-free — they’re not designed to convert into time, or disk reads. They’re just supposed to be bigger for slower operations, and smaller for faster ones.\nIf the planner thinks it can finish early due to a parent Limit operation, the total cost of the Limit operation will reflect this, but the total cost of its child operations will not.",
    "Plan Rows":
      "The number of rows,\nper-loop\n, that the planner expects to be returned by the operation.\nPoor row estimates can lead to suboptimal query planning. They can often be improved by running\nANALYZE\n(not the EXPLAIN parameter), by increasing statistics, or by allowing Postgres to understand correlation between columns using multivariate statistics.\nIf the planner thinks it can finish early due to a Limit operation, the plan rows of the Limit operation will reflect this, but the plan rows of its child operations will not.",
    "Plan Width":
      "The\nestimated\naverage size of the rows produced by the operation, in\nbytes\n.",
    "Actual Startup Time":
      "The amount of time, in\nmilliseconds\n, it takes to get the first row out of the operation.\nSometimes, this is very close to the setup time — for example on a sequential scan which returns all the rows in a table.\nOther times, though, it’s more or less the total time. For example, in order to return the first row of a sort, you have to sort all of the rows to work out which one comes first.",
    "Actual Total Time":
      "The actual amount of time in milliseconds spent on this operation\nand all of its children\n. It’s a\nper-loop average\n, rounded to the nearest thousandth of a millisecond.\nWorking out individual operation timings, especially where CTEs and SubPlans are concerned, can be tricky. This is one of the main reasons we decided to build\npgMustard\n.",
    "Actual Rows":
      "The number of rows returned by the operation\nper loop\n.\nThe important thing to notice about this is that it’s an average of all the loops executed, rounded to the nearest integer. This means that while “Actual Loops” multiplied by “Actual Rows” is a pretty good approximation for total number of rows returned most of the time, it can be off by as much as half of the number of loops. Usually it’s just slightly confusing as you see a row or two appear or disappear between operations, but on operations with lots of loops there is potential for serious miscalculation.\nPoor row estimates, where Actual Rows differs substantially from Plan Rows, can lead to suboptimal query planning. Estimates can often be improved by running\nANALYZE\n(not the EXPLAIN parameter), by increasing statistics, or by allowing Postgres to understand correlation between columns using multivariate statistics.",
    "Actual Loops":
      "The number of times the operation is executed. For a lot of operations it will have a value of one, but when it is not, there are three different cases:\nSome operations can be executed more than once. For example, “Nested Loops” run their “Inner” child once for every row returned by their “Outer” child.\nWhen an operation that would normally only consist of one loop is split across multiple threads, each partial operation is counted as a Loop.\nThe number of loops can be zero when an operation doesn’t need to be executed at all. For example if a table read is planned to provide candidates for an inner join, but there turns out to be no rows on the other side of the join, the operation can be effectively eliminated.",
    Output:
      "A list of the columns returned by the operation.\nThis is only shown when VERBOSE is on.",
    "Workers Planned":
      "The number of\nadditional\nworker processes requested by the planner. This does not include the main process.\nHow Postgres determines this number, and any discrepancy with Workers Launched, are well documented in\nthe official parallel query docs\n.",
    "Workers Launched":
      "The number of\nadditional\nworker processes. This does not include the main process.\nHow Postgres determines this number, and any discrepancy with Workers Planned, are well documented in\nthe official parallel query docs\n.",
    "Shared Hit Blocks":
      "The number of blocks from indexes/tables that were found in the Postgres buffer cache.\nThis\nincludes\nvalues for child operations and is a\ntotal\nvalue (i.e. not a per-loop average).\nOnce you have subtracted child operation values, the proportion of shared hit to shared read blocks is an interesting measure of cache performance.\nThe ratio of shared blocks (hit plus read) to rows processed (including any filtered out) is also interesting: a high ratio means Postgres is reading a lot of data for what it is doing, which can be a sign of bloat.",
    "Shared Read Blocks":
      "The number of blocks from tables/indexes that were read from disk (or the OS cache).\nThis\nincludes\nvalues for child operations and is a\ntotal\nvalue (i.e. not per-loop).\nOnce you have subtracted child operation values, the proportion of shared hit to shared read blocks is an interesting measure of cache performance.\nThe ratio of shared blocks (hit plus read) to rows processed (including any filtered out) is also interesting: a high ratio means Postgres is reading a lot of data for what it is doing, which can be a sign of bloat.",
    "Shared Dirtied Blocks":
      "The number of blocks from tables/indexes that were modified by the operation.\nThis\nincludes\nvalues for child operations and is a\ntotal\nvalue (i.e. not per-loop).\nInterestingly, a SELECT query can report shared dirtied blocks when setting hint bits on recently-committed rows, or pruning old row versions. While somewhat surprising, both of these are perfectly normal and healthy.",
    "Shared Written Blocks":
      "The number of blocks from tables/indexes that were evicted from the cache.\nThis\nincludes\nvalues for child operations and is a\ntotal\nvalue (i.e. not a per-loop average).",
    "Local Hit Blocks":
      "The number of blocks from temporary tables and indexes that were found in the cache.\nThis\nincludes\nvalues for child operations and is a\ntotal\nvalue (not a per-loop average).",
    "Local Read Blocks":
      "The number of blocks read from\ntemporary tables and indexes that were not found in the Postgres cache (read from disk or the OS cache).\nThis\nincludes\nvalues for child operations and is a\ntotal\nvalue (not a per-loop average).",
    "Local Dirtied Blocks":
      "The number of blocks from\ntemporary tables and indexes that have been modified by the operation.\nThis\nincludes\nvalues for child operations and is a\ntotal\nvalue (i.e. not a per-loop average).",
    "Local Written Blocks":
      "The number of blocks from\ntemporary tables and indexes that were evicted from the cache.\nThis\nincludes\nvalues for child operations and is a\ntotal\nvalue (i.e. not a per-loop average).",
    "Temp Read Blocks":
      "The number of blocks read from short-term data used to calculate hashes, sorts, Materialize operations, and similar.\nThis\nincludes\nvalues for child operations and is a\ntotal\nvalue (i.e. not a per-loop average).\nYour settings of\nwork_mem\nand\nhash_mem_multiplier\ndetermine how much memory is available to Postgres per operation.",
    "Temp Written Blocks":
      "The number of blocks from short-term data (used to calculate operations like hashes, sorts, and materializes) that were evicted from the cache.\nThis\nincludes\nvalues for child operations and is a\ntotal\nvalue (i.e. not a per-loop average).\nYour settings of\nwork_mem\nand\nhash_mem_multiplier\ndetermine how much memory is available to Postgres per operation.",
    "Shared I/O Read Time":
      "The time spent reading data from tables and indexes, in\nmilliseconds\n.\nThis\nincludes\nvalues for child operations and is a total value (not a per-loop average).\nRequires\ntrack_io_timing\nand\nBUFFERS\nto be on.\nIn the latest version, the text format of explain displays this as\nI/O Timings: shared read\nIn PostgreSQL 15 and 16 it shows as a combined metric\nI/O Timings: shared/local read\nGetting timing information has an overhead, due to checking the system clock. You can use\npg_test_timing\nto measure this for your system.",
    "Shared I/O Write Time":
      "The time spent writing data for tables and indexes, in\nmilliseconds\n.\nThis\nincludes\nvalues for child operations and is a total value (not a per-loop average).\nRequires\ntrack_io_timing\nand\nBUFFERS\nto be on.\nIn the latest version, the text format of explain displays this as\nI/O Timings: shared write\nIn PostgreSQL 15 and 16 it shows as a combined metric\nI/O Timings: shared/local write\nGetting timing information has an overhead, due to checking the system clock. You can use\npg_test_timing\nto measure this for your system.",
    "Local I/O Read Time":
      "The time spent reading local data (e.g. from temporary tables and indexes), in\nmilliseconds\n.\nThis\nincludes\nvalues for child operations and is a total value (i.e. not a per-loop average).\nThis was added as a separate field in PostgreSQL 17, and requires both\ntrack_io_timing\nand\nBUFFERS\n.\nIn the default text format, this will show as\nI/O Timings: local read\nIn versions 15 and 16 it is available as a combined metric as\nshared/local\nGetting timing information has an overhead, due to checking the system clock. You can use\npg_test_timing\nto measure this for your system.",
    "Local I/O Write Time":
      "The time spent writing local data (e.g. for temporary tables and indexes), in\nmilliseconds\n.\nThis\nincludes\nvalues for child operations and is a total value (i.e. not a per-loop average).\nThis was added as a separate field in PostgreSQL 17, and requires both\ntrack_io_timing\nand\nBUFFERS\n.\nIn the default text format, this will show as\nI/O Timings: local write\nIn versions 15 and 16 it is available as a combined metric as\nshared/local\nGetting timing information has an overhead, due to checking the system clock. You can use\npg_test_timing\nto measure this for your system.",
    "Temp I/O Read Time":
      "The time spent reading short-term data, in\nmilliseconds\n(for example during sort and hash operations that were not done in memory).\nThis\nincludes\nvalues for child operations and is a total value (i.e. not a per-loop average).\nThis was added in PostgreSQL 15, and requires both\ntrack_io_timing\nand\nBUFFERS\n.\nIn the text format of explain, this shows as\nI/O Timings: temp read\nGetting timing information has an overhead, due to checking the system clock. You can use\npg_test_timing\nto measure this for your system.",
    "Temp I/O Write Time":
      "The time spent writing short-term data, in\nmilliseconds\n(for example during sort and hash operations that were not done in memory).\nThis\nincludes\nvalues for child operations and is a total value (i.e. not a per-loop average).\nThis was added in PostgreSQL 15, and requires both\ntrack_io_timing\nand\nBUFFERS\n.\nIn the text format of explain, this shows as\nI/O Timings: temp write\nGetting timing information has an overhead, due to checking the system clock. You can use\npg_test_timing\nto measure this for your system.",
  },
  Group: {
    Strategy:
      "Which strategy of aggregation was performed: Plain, Hashed, Sorted, or Mixed.\nIn non-text format query plans, this lets you see whether Postgres is doing a HashAggregate (Hashed), a GroupAggregate (Sorted), or a MixedAggregate (Mixed).",
    "Partial Mode":
      "If this is\nSimple\n, the operation happens in one step.\nOtherwise,\nPartial\noperations do chunks of the operation in parallel, and a separate\nFinalize\noperation joins the different parts together.\nFrom the docs: “Aggregate functions which support Partial Mode are eligible to participate in various optimizations, such as parallel aggregation.”\n[source]",
    "Parent Relationship":
      "A guide as to why this operation needs to be run in order to facilitate the parent operation. There are six different possibilities:\nOuter\n: The value you’ll see most often. It means “take in the rows from this operation as input, process them and pass them on”.\nInner\n: Only ever seen on the second child of join operations, and is always seen there. This is the “inner” part of the loop — for each outer row, we look up its match using this operation.\nMember\n: Used for all children of Append and ModifyTable nodes, and on bitmap processing nodes like BitmapAnd and BitmapOr operations.\nInitPlan\n: Used for calculations performed before the query can start, eg a constant referred to in the query or the result of a CTE scan.\nSubquery\n: The child is a subquery of the parent operation. Since Postgres always uses subquery scans to feed subquery data to parent queries, only ever appears on the children of subquery scans.\nSubPlan\n: Like a Subquery, represents a new query, but used when a subquery scan is not necessary.",
    "Parallel Aware":
      "Whether or not the operation will be run in a special mode to support parallelism. Some operations need to be aware that they are running in parallel, for example sequential scans need to know they only need to scan a smaller proportion of the table. Other operations can be run on several threads without each one having any knowledge of the others.",
    "Startup Cost":
      "The estimated cost of returning the first row.\nThis is in an arbitrary unit, with the aim of being correlated to the startup time.",
    "Total Cost":
      "The estimated cost of returning all rows. This is in an arbitrary unit, with the aim of being correlated to the total time.\nThe Postgres query planner often has several ways it could resolve the same query. It calculates costs — which are hopefully correlated with the time it would take — for potential plans, and then picks the one with the lowest cost. It’s worth bearing in mind that the costs are unit-free — they’re not designed to convert into time, or disk reads. They’re just supposed to be bigger for slower operations, and smaller for faster ones.\nIf the planner thinks it can finish early due to a parent Limit operation, the total cost of the Limit operation will reflect this, but the total cost of its child operations will not.",
    "Plan Rows":
      "The number of rows,\nper-loop\n, that the planner expects to be returned by the operation.\nPoor row estimates can lead to suboptimal query planning. They can often be improved by running\nANALYZE\n(not the EXPLAIN parameter), by increasing statistics, or by allowing Postgres to understand correlation between columns using multivariate statistics.\nIf the planner thinks it can finish early due to a Limit operation, the plan rows of the Limit operation will reflect this, but the plan rows of its child operations will not.",
    "Plan Width":
      "The\nestimated\naverage size of the rows produced by the operation, in\nbytes\n.",
    "Actual Startup Time":
      "The amount of time, in\nmilliseconds\n, it takes to get the first row out of the operation.\nSometimes, this is very close to the setup time — for example on a sequential scan which returns all the rows in a table.\nOther times, though, it’s more or less the total time. For example, in order to return the first row of a sort, you have to sort all of the rows to work out which one comes first.",
    "Actual Total Time":
      "The actual amount of time in milliseconds spent on this operation\nand all of its children\n. It’s a\nper-loop average\n, rounded to the nearest thousandth of a millisecond.\nWorking out individual operation timings, especially where CTEs and SubPlans are concerned, can be tricky. This is one of the main reasons we decided to build\npgMustard\n.",
    "Actual Rows":
      "The number of rows returned by the operation\nper loop\n.\nThe important thing to notice about this is that it’s an average of all the loops executed, rounded to the nearest integer. This means that while “Actual Loops” multiplied by “Actual Rows” is a pretty good approximation for total number of rows returned most of the time, it can be off by as much as half of the number of loops. Usually it’s just slightly confusing as you see a row or two appear or disappear between operations, but on operations with lots of loops there is potential for serious miscalculation.\nPoor row estimates, where Actual Rows differs substantially from Plan Rows, can lead to suboptimal query planning. Estimates can often be improved by running\nANALYZE\n(not the EXPLAIN parameter), by increasing statistics, or by allowing Postgres to understand correlation between columns using multivariate statistics.",
    "Actual Loops":
      "The number of times the operation is executed. For a lot of operations it will have a value of one, but when it is not, there are three different cases:\nSome operations can be executed more than once. For example, “Nested Loops” run their “Inner” child once for every row returned by their “Outer” child.\nWhen an operation that would normally only consist of one loop is split across multiple threads, each partial operation is counted as a Loop.\nThe number of loops can be zero when an operation doesn’t need to be executed at all. For example if a table read is planned to provide candidates for an inner join, but there turns out to be no rows on the other side of the join, the operation can be effectively eliminated.",
    Output:
      "A list of the columns returned by the operation.\nThis is only shown when VERBOSE is on.",
    "Shared Hit Blocks":
      "The number of blocks from indexes/tables that were found in the Postgres buffer cache.\nThis\nincludes\nvalues for child operations and is a\ntotal\nvalue (i.e. not a per-loop average).\nOnce you have subtracted child operation values, the proportion of shared hit to shared read blocks is an interesting measure of cache performance.\nThe ratio of shared blocks (hit plus read) to rows processed (including any filtered out) is also interesting: a high ratio means Postgres is reading a lot of data for what it is doing, which can be a sign of bloat.",
    "Shared Read Blocks":
      "The number of blocks from tables/indexes that were read from disk (or the OS cache).\nThis\nincludes\nvalues for child operations and is a\ntotal\nvalue (i.e. not per-loop).\nOnce you have subtracted child operation values, the proportion of shared hit to shared read blocks is an interesting measure of cache performance.\nThe ratio of shared blocks (hit plus read) to rows processed (including any filtered out) is also interesting: a high ratio means Postgres is reading a lot of data for what it is doing, which can be a sign of bloat.",
    "Shared Dirtied Blocks":
      "The number of blocks from tables/indexes that were modified by the operation.\nThis\nincludes\nvalues for child operations and is a\ntotal\nvalue (i.e. not per-loop).\nInterestingly, a SELECT query can report shared dirtied blocks when setting hint bits on recently-committed rows, or pruning old row versions. While somewhat surprising, both of these are perfectly normal and healthy.",
    "Shared Written Blocks":
      "The number of blocks from tables/indexes that were evicted from the cache.\nThis\nincludes\nvalues for child operations and is a\ntotal\nvalue (i.e. not a per-loop average).",
    "Local Hit Blocks":
      "The number of blocks from temporary tables and indexes that were found in the cache.\nThis\nincludes\nvalues for child operations and is a\ntotal\nvalue (not a per-loop average).",
    "Local Read Blocks":
      "The number of blocks read from\ntemporary tables and indexes that were not found in the Postgres cache (read from disk or the OS cache).\nThis\nincludes\nvalues for child operations and is a\ntotal\nvalue (not a per-loop average).",
    "Local Dirtied Blocks":
      "The number of blocks from\ntemporary tables and indexes that have been modified by the operation.\nThis\nincludes\nvalues for child operations and is a\ntotal\nvalue (i.e. not a per-loop average).",
    "Local Written Blocks":
      "The number of blocks from\ntemporary tables and indexes that were evicted from the cache.\nThis\nincludes\nvalues for child operations and is a\ntotal\nvalue (i.e. not a per-loop average).",
    "Temp Read Blocks":
      "The number of blocks read from short-term data used to calculate hashes, sorts, Materialize operations, and similar.\nThis\nincludes\nvalues for child operations and is a\ntotal\nvalue (i.e. not a per-loop average).\nYour settings of\nwork_mem\nand\nhash_mem_multiplier\ndetermine how much memory is available to Postgres per operation.",
    "Temp Written Blocks":
      "The number of blocks from short-term data (used to calculate operations like hashes, sorts, and materializes) that were evicted from the cache.\nThis\nincludes\nvalues for child operations and is a\ntotal\nvalue (i.e. not a per-loop average).\nYour settings of\nwork_mem\nand\nhash_mem_multiplier\ndetermine how much memory is available to Postgres per operation.",
    "Shared I/O Read Time":
      "The time spent reading data from tables and indexes, in\nmilliseconds\n.\nThis\nincludes\nvalues for child operations and is a total value (not a per-loop average).\nRequires\ntrack_io_timing\nand\nBUFFERS\nto be on.\nIn the latest version, the text format of explain displays this as\nI/O Timings: shared read\nIn PostgreSQL 15 and 16 it shows as a combined metric\nI/O Timings: shared/local read\nGetting timing information has an overhead, due to checking the system clock. You can use\npg_test_timing\nto measure this for your system.",
    "Shared I/O Write Time":
      "The time spent writing data for tables and indexes, in\nmilliseconds\n.\nThis\nincludes\nvalues for child operations and is a total value (not a per-loop average).\nRequires\ntrack_io_timing\nand\nBUFFERS\nto be on.\nIn the latest version, the text format of explain displays this as\nI/O Timings: shared write\nIn PostgreSQL 15 and 16 it shows as a combined metric\nI/O Timings: shared/local write\nGetting timing information has an overhead, due to checking the system clock. You can use\npg_test_timing\nto measure this for your system.",
    "Local I/O Read Time":
      "The time spent reading local data (e.g. from temporary tables and indexes), in\nmilliseconds\n.\nThis\nincludes\nvalues for child operations and is a total value (i.e. not a per-loop average).\nThis was added as a separate field in PostgreSQL 17, and requires both\ntrack_io_timing\nand\nBUFFERS\n.\nIn the default text format, this will show as\nI/O Timings: local read\nIn versions 15 and 16 it is available as a combined metric as\nshared/local\nGetting timing information has an overhead, due to checking the system clock. You can use\npg_test_timing\nto measure this for your system.",
    "Local I/O Write Time":
      "The time spent writing local data (e.g. for temporary tables and indexes), in\nmilliseconds\n.\nThis\nincludes\nvalues for child operations and is a total value (i.e. not a per-loop average).\nThis was added as a separate field in PostgreSQL 17, and requires both\ntrack_io_timing\nand\nBUFFERS\n.\nIn the default text format, this will show as\nI/O Timings: local write\nIn versions 15 and 16 it is available as a combined metric as\nshared/local\nGetting timing information has an overhead, due to checking the system clock. You can use\npg_test_timing\nto measure this for your system.",
    "Temp I/O Read Time":
      "The time spent reading short-term data, in\nmilliseconds\n(for example during sort and hash operations that were not done in memory).\nThis\nincludes\nvalues for child operations and is a total value (i.e. not a per-loop average).\nThis was added in PostgreSQL 15, and requires both\ntrack_io_timing\nand\nBUFFERS\n.\nIn the text format of explain, this shows as\nI/O Timings: temp read\nGetting timing information has an overhead, due to checking the system clock. You can use\npg_test_timing\nto measure this for your system.",
    "Temp I/O Write Time":
      "The time spent writing short-term data, in\nmilliseconds\n(for example during sort and hash operations that were not done in memory).\nThis\nincludes\nvalues for child operations and is a total value (i.e. not a per-loop average).\nThis was added in PostgreSQL 15, and requires both\ntrack_io_timing\nand\nBUFFERS\n.\nIn the text format of explain, this shows as\nI/O Timings: temp write\nGetting timing information has an overhead, due to checking the system clock. You can use\npg_test_timing\nto measure this for your system.",
    Workers:
      "A summary of the operation detail broken down by thread.\nThese entries\ndon’t\ninclude the main (or leader) thread.\nYou can work out the values for the main thread by subtracting the worker statistics from the total.\nThis information is only shown when VERBOSE is on.",
  },
  GroupAggregate: {
    Strategy:
      "Which strategy of aggregation was performed: Plain, Hashed, Sorted, or Mixed.\nIn non-text format query plans, this lets you see whether Postgres is doing a HashAggregate (Hashed), a GroupAggregate (Sorted), or a MixedAggregate (Mixed).",
    "Partial Mode":
      "If this is\nSimple\n, the operation happens in one step.\nOtherwise,\nPartial\noperations do chunks of the operation in parallel, and a separate\nFinalize\noperation joins the different parts together.\nFrom the docs: “Aggregate functions which support Partial Mode are eligible to participate in various optimizations, such as parallel aggregation.”\n[source]",
    "Parent Relationship":
      "A guide as to why this operation needs to be run in order to facilitate the parent operation. There are six different possibilities:\nOuter\n: The value you’ll see most often. It means “take in the rows from this operation as input, process them and pass them on”.\nInner\n: Only ever seen on the second child of join operations, and is always seen there. This is the “inner” part of the loop — for each outer row, we look up its match using this operation.\nMember\n: Used for all children of Append and ModifyTable nodes, and on bitmap processing nodes like BitmapAnd and BitmapOr operations.\nInitPlan\n: Used for calculations performed before the query can start, eg a constant referred to in the query or the result of a CTE scan.\nSubquery\n: The child is a subquery of the parent operation. Since Postgres always uses subquery scans to feed subquery data to parent queries, only ever appears on the children of subquery scans.\nSubPlan\n: Like a Subquery, represents a new query, but used when a subquery scan is not necessary.",
    "Parallel Aware":
      "Whether or not the operation will be run in a special mode to support parallelism. Some operations need to be aware that they are running in parallel, for example sequential scans need to know they only need to scan a smaller proportion of the table. Other operations can be run on several threads without each one having any knowledge of the others.",
    "Startup Cost":
      "The estimated cost of returning the first row.\nThis is in an arbitrary unit, with the aim of being correlated to the startup time.",
    "Total Cost":
      "The estimated cost of returning all rows. This is in an arbitrary unit, with the aim of being correlated to the total time.\nThe Postgres query planner often has several ways it could resolve the same query. It calculates costs — which are hopefully correlated with the time it would take — for potential plans, and then picks the one with the lowest cost. It’s worth bearing in mind that the costs are unit-free — they’re not designed to convert into time, or disk reads. They’re just supposed to be bigger for slower operations, and smaller for faster ones.\nIf the planner thinks it can finish early due to a parent Limit operation, the total cost of the Limit operation will reflect this, but the total cost of its child operations will not.",
    "Plan Rows":
      "The number of rows,\nper-loop\n, that the planner expects to be returned by the operation.\nPoor row estimates can lead to suboptimal query planning. They can often be improved by running\nANALYZE\n(not the EXPLAIN parameter), by increasing statistics, or by allowing Postgres to understand correlation between columns using multivariate statistics.\nIf the planner thinks it can finish early due to a Limit operation, the plan rows of the Limit operation will reflect this, but the plan rows of its child operations will not.",
    "Plan Width":
      "The\nestimated\naverage size of the rows produced by the operation, in\nbytes\n.",
    "Actual Startup Time":
      "The amount of time, in\nmilliseconds\n, it takes to get the first row out of the operation.\nSometimes, this is very close to the setup time — for example on a sequential scan which returns all the rows in a table.\nOther times, though, it’s more or less the total time. For example, in order to return the first row of a sort, you have to sort all of the rows to work out which one comes first.",
    "Actual Total Time":
      "The actual amount of time in milliseconds spent on this operation\nand all of its children\n. It’s a\nper-loop average\n, rounded to the nearest thousandth of a millisecond.\nWorking out individual operation timings, especially where CTEs and SubPlans are concerned, can be tricky. This is one of the main reasons we decided to build\npgMustard\n.",
    "Actual Rows":
      "The number of rows returned by the operation\nper loop\n.\nThe important thing to notice about this is that it’s an average of all the loops executed, rounded to the nearest integer. This means that while “Actual Loops” multiplied by “Actual Rows” is a pretty good approximation for total number of rows returned most of the time, it can be off by as much as half of the number of loops. Usually it’s just slightly confusing as you see a row or two appear or disappear between operations, but on operations with lots of loops there is potential for serious miscalculation.\nPoor row estimates, where Actual Rows differs substantially from Plan Rows, can lead to suboptimal query planning. Estimates can often be improved by running\nANALYZE\n(not the EXPLAIN parameter), by increasing statistics, or by allowing Postgres to understand correlation between columns using multivariate statistics.",
    "Actual Loops":
      "The number of times the operation is executed. For a lot of operations it will have a value of one, but when it is not, there are three different cases:\nSome operations can be executed more than once. For example, “Nested Loops” run their “Inner” child once for every row returned by their “Outer” child.\nWhen an operation that would normally only consist of one loop is split across multiple threads, each partial operation is counted as a Loop.\nThe number of loops can be zero when an operation doesn’t need to be executed at all. For example if a table read is planned to provide candidates for an inner join, but there turns out to be no rows on the other side of the join, the operation can be effectively eliminated.",
    Output:
      "A list of the columns returned by the operation.\nThis is only shown when VERBOSE is on.",
    "Shared Hit Blocks":
      "The number of blocks from indexes/tables that were found in the Postgres buffer cache.\nThis\nincludes\nvalues for child operations and is a\ntotal\nvalue (i.e. not a per-loop average).\nOnce you have subtracted child operation values, the proportion of shared hit to shared read blocks is an interesting measure of cache performance.\nThe ratio of shared blocks (hit plus read) to rows processed (including any filtered out) is also interesting: a high ratio means Postgres is reading a lot of data for what it is doing, which can be a sign of bloat.",
    "Shared Read Blocks":
      "The number of blocks from tables/indexes that were read from disk (or the OS cache).\nThis\nincludes\nvalues for child operations and is a\ntotal\nvalue (i.e. not per-loop).\nOnce you have subtracted child operation values, the proportion of shared hit to shared read blocks is an interesting measure of cache performance.\nThe ratio of shared blocks (hit plus read) to rows processed (including any filtered out) is also interesting: a high ratio means Postgres is reading a lot of data for what it is doing, which can be a sign of bloat.",
    "Shared Dirtied Blocks":
      "The number of blocks from tables/indexes that were modified by the operation.\nThis\nincludes\nvalues for child operations and is a\ntotal\nvalue (i.e. not per-loop).\nInterestingly, a SELECT query can report shared dirtied blocks when setting hint bits on recently-committed rows, or pruning old row versions. While somewhat surprising, both of these are perfectly normal and healthy.",
    "Shared Written Blocks":
      "The number of blocks from tables/indexes that were evicted from the cache.\nThis\nincludes\nvalues for child operations and is a\ntotal\nvalue (i.e. not a per-loop average).",
    "Local Hit Blocks":
      "The number of blocks from temporary tables and indexes that were found in the cache.\nThis\nincludes\nvalues for child operations and is a\ntotal\nvalue (not a per-loop average).",
    "Local Read Blocks":
      "The number of blocks read from\ntemporary tables and indexes that were not found in the Postgres cache (read from disk or the OS cache).\nThis\nincludes\nvalues for child operations and is a\ntotal\nvalue (not a per-loop average).",
    "Local Dirtied Blocks":
      "The number of blocks from\ntemporary tables and indexes that have been modified by the operation.\nThis\nincludes\nvalues for child operations and is a\ntotal\nvalue (i.e. not a per-loop average).",
    "Local Written Blocks":
      "The number of blocks from\ntemporary tables and indexes that were evicted from the cache.\nThis\nincludes\nvalues for child operations and is a\ntotal\nvalue (i.e. not a per-loop average).",
    "Temp Read Blocks":
      "The number of blocks read from short-term data used to calculate hashes, sorts, Materialize operations, and similar.\nThis\nincludes\nvalues for child operations and is a\ntotal\nvalue (i.e. not a per-loop average).\nYour settings of\nwork_mem\nand\nhash_mem_multiplier\ndetermine how much memory is available to Postgres per operation.",
    "Temp Written Blocks":
      "The number of blocks from short-term data (used to calculate operations like hashes, sorts, and materializes) that were evicted from the cache.\nThis\nincludes\nvalues for child operations and is a\ntotal\nvalue (i.e. not a per-loop average).\nYour settings of\nwork_mem\nand\nhash_mem_multiplier\ndetermine how much memory is available to Postgres per operation.",
    "Shared I/O Read Time":
      "The time spent reading data from tables and indexes, in\nmilliseconds\n.\nThis\nincludes\nvalues for child operations and is a total value (not a per-loop average).\nRequires\ntrack_io_timing\nand\nBUFFERS\nto be on.\nIn the latest version, the text format of explain displays this as\nI/O Timings: shared read\nIn PostgreSQL 15 and 16 it shows as a combined metric\nI/O Timings: shared/local read\nGetting timing information has an overhead, due to checking the system clock. You can use\npg_test_timing\nto measure this for your system.",
    "Shared I/O Write Time":
      "The time spent writing data for tables and indexes, in\nmilliseconds\n.\nThis\nincludes\nvalues for child operations and is a total value (not a per-loop average).\nRequires\ntrack_io_timing\nand\nBUFFERS\nto be on.\nIn the latest version, the text format of explain displays this as\nI/O Timings: shared write\nIn PostgreSQL 15 and 16 it shows as a combined metric\nI/O Timings: shared/local write\nGetting timing information has an overhead, due to checking the system clock. You can use\npg_test_timing\nto measure this for your system.",
    "Local I/O Read Time":
      "The time spent reading local data (e.g. from temporary tables and indexes), in\nmilliseconds\n.\nThis\nincludes\nvalues for child operations and is a total value (i.e. not a per-loop average).\nThis was added as a separate field in PostgreSQL 17, and requires both\ntrack_io_timing\nand\nBUFFERS\n.\nIn the default text format, this will show as\nI/O Timings: local read\nIn versions 15 and 16 it is available as a combined metric as\nshared/local\nGetting timing information has an overhead, due to checking the system clock. You can use\npg_test_timing\nto measure this for your system.",
    "Local I/O Write Time":
      "The time spent writing local data (e.g. for temporary tables and indexes), in\nmilliseconds\n.\nThis\nincludes\nvalues for child operations and is a total value (i.e. not a per-loop average).\nThis was added as a separate field in PostgreSQL 17, and requires both\ntrack_io_timing\nand\nBUFFERS\n.\nIn the default text format, this will show as\nI/O Timings: local write\nIn versions 15 and 16 it is available as a combined metric as\nshared/local\nGetting timing information has an overhead, due to checking the system clock. You can use\npg_test_timing\nto measure this for your system.",
    "Temp I/O Read Time":
      "The time spent reading short-term data, in\nmilliseconds\n(for example during sort and hash operations that were not done in memory).\nThis\nincludes\nvalues for child operations and is a total value (i.e. not a per-loop average).\nThis was added in PostgreSQL 15, and requires both\ntrack_io_timing\nand\nBUFFERS\n.\nIn the text format of explain, this shows as\nI/O Timings: temp read\nGetting timing information has an overhead, due to checking the system clock. You can use\npg_test_timing\nto measure this for your system.",
    "Temp I/O Write Time":
      "The time spent writing short-term data, in\nmilliseconds\n(for example during sort and hash operations that were not done in memory).\nThis\nincludes\nvalues for child operations and is a total value (i.e. not a per-loop average).\nThis was added in PostgreSQL 15, and requires both\ntrack_io_timing\nand\nBUFFERS\n.\nIn the text format of explain, this shows as\nI/O Timings: temp write\nGetting timing information has an overhead, due to checking the system clock. You can use\npg_test_timing\nto measure this for your system.",
    Workers:
      "A summary of the operation detail broken down by thread.\nThese entries\ndon’t\ninclude the main (or leader) thread.\nYou can work out the values for the main thread by subtracting the worker statistics from the total.\nThis information is only shown when VERBOSE is on.",
  },
  Hash: {
    "Parent Relationship":
      "A guide as to why this operation needs to be run in order to facilitate the parent operation. There are six different possibilities:\nOuter\n: The value you’ll see most often. It means “take in the rows from this operation as input, process them and pass them on”.\nInner\n: Only ever seen on the second child of join operations, and is always seen there. This is the “inner” part of the loop — for each outer row, we look up its match using this operation.\nMember\n: Used for all children of Append and ModifyTable nodes, and on bitmap processing nodes like BitmapAnd and BitmapOr operations.\nInitPlan\n: Used for calculations performed before the query can start, eg a constant referred to in the query or the result of a CTE scan.\nSubquery\n: The child is a subquery of the parent operation. Since Postgres always uses subquery scans to feed subquery data to parent queries, only ever appears on the children of subquery scans.\nSubPlan\n: Like a Subquery, represents a new query, but used when a subquery scan is not necessary.",
    "Parallel Aware":
      "Whether or not the operation will be run in a special mode to support parallelism. Some operations need to be aware that they are running in parallel, for example sequential scans need to know they only need to scan a smaller proportion of the table. Other operations can be run on several threads without each one having any knowledge of the others.",
    "Startup Cost":
      "The estimated cost of returning the first row.\nThis is in an arbitrary unit, with the aim of being correlated to the startup time.",
    "Total Cost":
      "The estimated cost of returning all rows. This is in an arbitrary unit, with the aim of being correlated to the total time.\nThe Postgres query planner often has several ways it could resolve the same query. It calculates costs — which are hopefully correlated with the time it would take — for potential plans, and then picks the one with the lowest cost. It’s worth bearing in mind that the costs are unit-free — they’re not designed to convert into time, or disk reads. They’re just supposed to be bigger for slower operations, and smaller for faster ones.\nIf the planner thinks it can finish early due to a parent Limit operation, the total cost of the Limit operation will reflect this, but the total cost of its child operations will not.",
    "Plan Rows":
      "The number of rows,\nper-loop\n, that the planner expects to be returned by the operation.\nPoor row estimates can lead to suboptimal query planning. They can often be improved by running\nANALYZE\n(not the EXPLAIN parameter), by increasing statistics, or by allowing Postgres to understand correlation between columns using multivariate statistics.\nIf the planner thinks it can finish early due to a Limit operation, the plan rows of the Limit operation will reflect this, but the plan rows of its child operations will not.",
    "Plan Width":
      "The\nestimated\naverage size of the rows produced by the operation, in\nbytes\n.",
    "Actual Startup Time":
      "The amount of time, in\nmilliseconds\n, it takes to get the first row out of the operation.\nSometimes, this is very close to the setup time — for example on a sequential scan which returns all the rows in a table.\nOther times, though, it’s more or less the total time. For example, in order to return the first row of a sort, you have to sort all of the rows to work out which one comes first.",
    "Actual Total Time":
      "The actual amount of time in milliseconds spent on this operation\nand all of its children\n. It’s a\nper-loop average\n, rounded to the nearest thousandth of a millisecond.\nWorking out individual operation timings, especially where CTEs and SubPlans are concerned, can be tricky. This is one of the main reasons we decided to build\npgMustard\n.",
    "Actual Rows":
      "The number of rows returned by the operation\nper loop\n.\nThe important thing to notice about this is that it’s an average of all the loops executed, rounded to the nearest integer. This means that while “Actual Loops” multiplied by “Actual Rows” is a pretty good approximation for total number of rows returned most of the time, it can be off by as much as half of the number of loops. Usually it’s just slightly confusing as you see a row or two appear or disappear between operations, but on operations with lots of loops there is potential for serious miscalculation.\nPoor row estimates, where Actual Rows differs substantially from Plan Rows, can lead to suboptimal query planning. Estimates can often be improved by running\nANALYZE\n(not the EXPLAIN parameter), by increasing statistics, or by allowing Postgres to understand correlation between columns using multivariate statistics.",
    "Actual Loops":
      "The number of times the operation is executed. For a lot of operations it will have a value of one, but when it is not, there are three different cases:\nSome operations can be executed more than once. For example, “Nested Loops” run their “Inner” child once for every row returned by their “Outer” child.\nWhen an operation that would normally only consist of one loop is split across multiple threads, each partial operation is counted as a Loop.\nThe number of loops can be zero when an operation doesn’t need to be executed at all. For example if a table read is planned to provide candidates for an inner join, but there turns out to be no rows on the other side of the join, the operation can be effectively eliminated.",
    Output:
      "A list of the columns returned by the operation.\nThis is only shown when VERBOSE is on.",
    "Hash Buckets":
      "Hashed data is assigned to hash buckets.\nBuckets are doubled until there are enough, so they are always a power of 2.\nSometimes Postgres will choose to increase the original number of buckets in order to reduce the number of tuples per bucket.",
    "Original Hash Buckets":
      "Hashed data is assigned to hash buckets.\nBuckets are doubled until there are enough, so they are always a power of 2.\nA difference with\nHash Buckets\nis due to Postgres choosing to increase the original number of buckets in order to reduce the number of tuples per bucket.",
    "Hash Batches":
      "If the hash is done in memory, there will only be a single batch.\nA difference with\nOriginal Hash Batches\nis due to Postgres choosing to increase the number of batches in order to reduce memory consumption.",
    "Original Hash Batches":
      "If the hash is done in memory, there will only be a single batch.\nA difference with\nHash Batches\nis due to Postgres choosing to increase the number of batches in order to reduce memory consumption.",
    "Peak Memory Usage":
      "The peak memory used in a Hash, Hash Join, HashAggregate, or Memoize operation.\nIt is reported in\nKB\n.",
    "Shared Hit Blocks":
      "The number of blocks from indexes/tables that were found in the Postgres buffer cache.\nThis\nincludes\nvalues for child operations and is a\ntotal\nvalue (i.e. not a per-loop average).\nOnce you have subtracted child operation values, the proportion of shared hit to shared read blocks is an interesting measure of cache performance.\nThe ratio of shared blocks (hit plus read) to rows processed (including any filtered out) is also interesting: a high ratio means Postgres is reading a lot of data for what it is doing, which can be a sign of bloat.",
    "Shared Read Blocks":
      "The number of blocks from tables/indexes that were read from disk (or the OS cache).\nThis\nincludes\nvalues for child operations and is a\ntotal\nvalue (i.e. not per-loop).\nOnce you have subtracted child operation values, the proportion of shared hit to shared read blocks is an interesting measure of cache performance.\nThe ratio of shared blocks (hit plus read) to rows processed (including any filtered out) is also interesting: a high ratio means Postgres is reading a lot of data for what it is doing, which can be a sign of bloat.",
    "Shared Dirtied Blocks":
      "The number of blocks from tables/indexes that were modified by the operation.\nThis\nincludes\nvalues for child operations and is a\ntotal\nvalue (i.e. not per-loop).\nInterestingly, a SELECT query can report shared dirtied blocks when setting hint bits on recently-committed rows, or pruning old row versions. While somewhat surprising, both of these are perfectly normal and healthy.",
    "Shared Written Blocks":
      "The number of blocks from tables/indexes that were evicted from the cache.\nThis\nincludes\nvalues for child operations and is a\ntotal\nvalue (i.e. not a per-loop average).",
    "Local Hit Blocks":
      "The number of blocks from temporary tables and indexes that were found in the cache.\nThis\nincludes\nvalues for child operations and is a\ntotal\nvalue (not a per-loop average).",
    "Local Read Blocks":
      "The number of blocks read from\ntemporary tables and indexes that were not found in the Postgres cache (read from disk or the OS cache).\nThis\nincludes\nvalues for child operations and is a\ntotal\nvalue (not a per-loop average).",
    "Local Dirtied Blocks":
      "The number of blocks from\ntemporary tables and indexes that have been modified by the operation.\nThis\nincludes\nvalues for child operations and is a\ntotal\nvalue (i.e. not a per-loop average).",
    "Local Written Blocks":
      "The number of blocks from\ntemporary tables and indexes that were evicted from the cache.\nThis\nincludes\nvalues for child operations and is a\ntotal\nvalue (i.e. not a per-loop average).",
    "Temp Read Blocks":
      "The number of blocks read from short-term data used to calculate hashes, sorts, Materialize operations, and similar.\nThis\nincludes\nvalues for child operations and is a\ntotal\nvalue (i.e. not a per-loop average).\nYour settings of\nwork_mem\nand\nhash_mem_multiplier\ndetermine how much memory is available to Postgres per operation.",
    "Temp Written Blocks":
      "The number of blocks from short-term data (used to calculate operations like hashes, sorts, and materializes) that were evicted from the cache.\nThis\nincludes\nvalues for child operations and is a\ntotal\nvalue (i.e. not a per-loop average).\nYour settings of\nwork_mem\nand\nhash_mem_multiplier\ndetermine how much memory is available to Postgres per operation.",
    "Shared I/O Read Time":
      "The time spent reading data from tables and indexes, in\nmilliseconds\n.\nThis\nincludes\nvalues for child operations and is a total value (not a per-loop average).\nRequires\ntrack_io_timing\nand\nBUFFERS\nto be on.\nIn the latest version, the text format of explain displays this as\nI/O Timings: shared read\nIn PostgreSQL 15 and 16 it shows as a combined metric\nI/O Timings: shared/local read\nGetting timing information has an overhead, due to checking the system clock. You can use\npg_test_timing\nto measure this for your system.",
    "Shared I/O Write Time":
      "The time spent writing data for tables and indexes, in\nmilliseconds\n.\nThis\nincludes\nvalues for child operations and is a total value (not a per-loop average).\nRequires\ntrack_io_timing\nand\nBUFFERS\nto be on.\nIn the latest version, the text format of explain displays this as\nI/O Timings: shared write\nIn PostgreSQL 15 and 16 it shows as a combined metric\nI/O Timings: shared/local write\nGetting timing information has an overhead, due to checking the system clock. You can use\npg_test_timing\nto measure this for your system.",
    "Local I/O Read Time":
      "The time spent reading local data (e.g. from temporary tables and indexes), in\nmilliseconds\n.\nThis\nincludes\nvalues for child operations and is a total value (i.e. not a per-loop average).\nThis was added as a separate field in PostgreSQL 17, and requires both\ntrack_io_timing\nand\nBUFFERS\n.\nIn the default text format, this will show as\nI/O Timings: local read\nIn versions 15 and 16 it is available as a combined metric as\nshared/local\nGetting timing information has an overhead, due to checking the system clock. You can use\npg_test_timing\nto measure this for your system.",
    "Local I/O Write Time":
      "The time spent writing local data (e.g. for temporary tables and indexes), in\nmilliseconds\n.\nThis\nincludes\nvalues for child operations and is a total value (i.e. not a per-loop average).\nThis was added as a separate field in PostgreSQL 17, and requires both\ntrack_io_timing\nand\nBUFFERS\n.\nIn the default text format, this will show as\nI/O Timings: local write\nIn versions 15 and 16 it is available as a combined metric as\nshared/local\nGetting timing information has an overhead, due to checking the system clock. You can use\npg_test_timing\nto measure this for your system.",
    "Temp I/O Read Time":
      "The time spent reading short-term data, in\nmilliseconds\n(for example during sort and hash operations that were not done in memory).\nThis\nincludes\nvalues for child operations and is a total value (i.e. not a per-loop average).\nThis was added in PostgreSQL 15, and requires both\ntrack_io_timing\nand\nBUFFERS\n.\nIn the text format of explain, this shows as\nI/O Timings: temp read\nGetting timing information has an overhead, due to checking the system clock. You can use\npg_test_timing\nto measure this for your system.",
    "Temp I/O Write Time":
      "The time spent writing short-term data, in\nmilliseconds\n(for example during sort and hash operations that were not done in memory).\nThis\nincludes\nvalues for child operations and is a total value (i.e. not a per-loop average).\nThis was added in PostgreSQL 15, and requires both\ntrack_io_timing\nand\nBUFFERS\n.\nIn the text format of explain, this shows as\nI/O Timings: temp write\nGetting timing information has an overhead, due to checking the system clock. You can use\npg_test_timing\nto measure this for your system.",
  },
  HashAggregate: {
    Strategy:
      "Which strategy of aggregation was performed: Plain, Hashed, Sorted, or Mixed.\nIn non-text format query plans, this lets you see whether Postgres is doing a HashAggregate (Hashed), a GroupAggregate (Sorted), or a MixedAggregate (Mixed).",
    "Partial Mode":
      "If this is\nSimple\n, the operation happens in one step.\nOtherwise,\nPartial\noperations do chunks of the operation in parallel, and a separate\nFinalize\noperation joins the different parts together.\nFrom the docs: “Aggregate functions which support Partial Mode are eligible to participate in various optimizations, such as parallel aggregation.”\n[source]",
    "Parent Relationship":
      "A guide as to why this operation needs to be run in order to facilitate the parent operation. There are six different possibilities:\nOuter\n: The value you’ll see most often. It means “take in the rows from this operation as input, process them and pass them on”.\nInner\n: Only ever seen on the second child of join operations, and is always seen there. This is the “inner” part of the loop — for each outer row, we look up its match using this operation.\nMember\n: Used for all children of Append and ModifyTable nodes, and on bitmap processing nodes like BitmapAnd and BitmapOr operations.\nInitPlan\n: Used for calculations performed before the query can start, eg a constant referred to in the query or the result of a CTE scan.\nSubquery\n: The child is a subquery of the parent operation. Since Postgres always uses subquery scans to feed subquery data to parent queries, only ever appears on the children of subquery scans.\nSubPlan\n: Like a Subquery, represents a new query, but used when a subquery scan is not necessary.",
    "Parallel Aware":
      "Whether or not the operation will be run in a special mode to support parallelism. Some operations need to be aware that they are running in parallel, for example sequential scans need to know they only need to scan a smaller proportion of the table. Other operations can be run on several threads without each one having any knowledge of the others.",
    "Startup Cost":
      "The estimated cost of returning the first row.\nThis is in an arbitrary unit, with the aim of being correlated to the startup time.",
    "Total Cost":
      "The estimated cost of returning all rows. This is in an arbitrary unit, with the aim of being correlated to the total time.\nThe Postgres query planner often has several ways it could resolve the same query. It calculates costs — which are hopefully correlated with the time it would take — for potential plans, and then picks the one with the lowest cost. It’s worth bearing in mind that the costs are unit-free — they’re not designed to convert into time, or disk reads. They’re just supposed to be bigger for slower operations, and smaller for faster ones.\nIf the planner thinks it can finish early due to a parent Limit operation, the total cost of the Limit operation will reflect this, but the total cost of its child operations will not.",
    "Plan Rows":
      "The number of rows,\nper-loop\n, that the planner expects to be returned by the operation.\nPoor row estimates can lead to suboptimal query planning. They can often be improved by running\nANALYZE\n(not the EXPLAIN parameter), by increasing statistics, or by allowing Postgres to understand correlation between columns using multivariate statistics.\nIf the planner thinks it can finish early due to a Limit operation, the plan rows of the Limit operation will reflect this, but the plan rows of its child operations will not.",
    "Plan Width":
      "The\nestimated\naverage size of the rows produced by the operation, in\nbytes\n.",
    "Actual Startup Time":
      "The amount of time, in\nmilliseconds\n, it takes to get the first row out of the operation.\nSometimes, this is very close to the setup time — for example on a sequential scan which returns all the rows in a table.\nOther times, though, it’s more or less the total time. For example, in order to return the first row of a sort, you have to sort all of the rows to work out which one comes first.",
    "Actual Total Time":
      "The actual amount of time in milliseconds spent on this operation\nand all of its children\n. It’s a\nper-loop average\n, rounded to the nearest thousandth of a millisecond.\nWorking out individual operation timings, especially where CTEs and SubPlans are concerned, can be tricky. This is one of the main reasons we decided to build\npgMustard\n.",
    "Actual Rows":
      "The number of rows returned by the operation\nper loop\n.\nThe important thing to notice about this is that it’s an average of all the loops executed, rounded to the nearest integer. This means that while “Actual Loops” multiplied by “Actual Rows” is a pretty good approximation for total number of rows returned most of the time, it can be off by as much as half of the number of loops. Usually it’s just slightly confusing as you see a row or two appear or disappear between operations, but on operations with lots of loops there is potential for serious miscalculation.\nPoor row estimates, where Actual Rows differs substantially from Plan Rows, can lead to suboptimal query planning. Estimates can often be improved by running\nANALYZE\n(not the EXPLAIN parameter), by increasing statistics, or by allowing Postgres to understand correlation between columns using multivariate statistics.",
    "Actual Loops":
      "The number of times the operation is executed. For a lot of operations it will have a value of one, but when it is not, there are three different cases:\nSome operations can be executed more than once. For example, “Nested Loops” run their “Inner” child once for every row returned by their “Outer” child.\nWhen an operation that would normally only consist of one loop is split across multiple threads, each partial operation is counted as a Loop.\nThe number of loops can be zero when an operation doesn’t need to be executed at all. For example if a table read is planned to provide candidates for an inner join, but there turns out to be no rows on the other side of the join, the operation can be effectively eliminated.",
    Output:
      "A list of the columns returned by the operation.\nThis is only shown when VERBOSE is on.",
    "Peak Memory Usage":
      "The peak memory used in a Hash, Hash Join, HashAggregate, or Memoize operation.\nIt is reported in\nKB\n.",
    "Shared Hit Blocks":
      "The number of blocks from indexes/tables that were found in the Postgres buffer cache.\nThis\nincludes\nvalues for child operations and is a\ntotal\nvalue (i.e. not a per-loop average).\nOnce you have subtracted child operation values, the proportion of shared hit to shared read blocks is an interesting measure of cache performance.\nThe ratio of shared blocks (hit plus read) to rows processed (including any filtered out) is also interesting: a high ratio means Postgres is reading a lot of data for what it is doing, which can be a sign of bloat.",
    "Shared Read Blocks":
      "The number of blocks from tables/indexes that were read from disk (or the OS cache).\nThis\nincludes\nvalues for child operations and is a\ntotal\nvalue (i.e. not per-loop).\nOnce you have subtracted child operation values, the proportion of shared hit to shared read blocks is an interesting measure of cache performance.\nThe ratio of shared blocks (hit plus read) to rows processed (including any filtered out) is also interesting: a high ratio means Postgres is reading a lot of data for what it is doing, which can be a sign of bloat.",
    "Shared Dirtied Blocks":
      "The number of blocks from tables/indexes that were modified by the operation.\nThis\nincludes\nvalues for child operations and is a\ntotal\nvalue (i.e. not per-loop).\nInterestingly, a SELECT query can report shared dirtied blocks when setting hint bits on recently-committed rows, or pruning old row versions. While somewhat surprising, both of these are perfectly normal and healthy.",
    "Shared Written Blocks":
      "The number of blocks from tables/indexes that were evicted from the cache.\nThis\nincludes\nvalues for child operations and is a\ntotal\nvalue (i.e. not a per-loop average).",
    "Local Hit Blocks":
      "The number of blocks from temporary tables and indexes that were found in the cache.\nThis\nincludes\nvalues for child operations and is a\ntotal\nvalue (not a per-loop average).",
    "Local Read Blocks":
      "The number of blocks read from\ntemporary tables and indexes that were not found in the Postgres cache (read from disk or the OS cache).\nThis\nincludes\nvalues for child operations and is a\ntotal\nvalue (not a per-loop average).",
    "Local Dirtied Blocks":
      "The number of blocks from\ntemporary tables and indexes that have been modified by the operation.\nThis\nincludes\nvalues for child operations and is a\ntotal\nvalue (i.e. not a per-loop average).",
    "Local Written Blocks":
      "The number of blocks from\ntemporary tables and indexes that were evicted from the cache.\nThis\nincludes\nvalues for child operations and is a\ntotal\nvalue (i.e. not a per-loop average).",
    "Temp Read Blocks":
      "The number of blocks read from short-term data used to calculate hashes, sorts, Materialize operations, and similar.\nThis\nincludes\nvalues for child operations and is a\ntotal\nvalue (i.e. not a per-loop average).\nYour settings of\nwork_mem\nand\nhash_mem_multiplier\ndetermine how much memory is available to Postgres per operation.",
    "Temp Written Blocks":
      "The number of blocks from short-term data (used to calculate operations like hashes, sorts, and materializes) that were evicted from the cache.\nThis\nincludes\nvalues for child operations and is a\ntotal\nvalue (i.e. not a per-loop average).\nYour settings of\nwork_mem\nand\nhash_mem_multiplier\ndetermine how much memory is available to Postgres per operation.",
    "Shared I/O Read Time":
      "The time spent reading data from tables and indexes, in\nmilliseconds\n.\nThis\nincludes\nvalues for child operations and is a total value (not a per-loop average).\nRequires\ntrack_io_timing\nand\nBUFFERS\nto be on.\nIn the latest version, the text format of explain displays this as\nI/O Timings: shared read\nIn PostgreSQL 15 and 16 it shows as a combined metric\nI/O Timings: shared/local read\nGetting timing information has an overhead, due to checking the system clock. You can use\npg_test_timing\nto measure this for your system.",
    "Shared I/O Write Time":
      "The time spent writing data for tables and indexes, in\nmilliseconds\n.\nThis\nincludes\nvalues for child operations and is a total value (not a per-loop average).\nRequires\ntrack_io_timing\nand\nBUFFERS\nto be on.\nIn the latest version, the text format of explain displays this as\nI/O Timings: shared write\nIn PostgreSQL 15 and 16 it shows as a combined metric\nI/O Timings: shared/local write\nGetting timing information has an overhead, due to checking the system clock. You can use\npg_test_timing\nto measure this for your system.",
    "Local I/O Read Time":
      "The time spent reading local data (e.g. from temporary tables and indexes), in\nmilliseconds\n.\nThis\nincludes\nvalues for child operations and is a total value (i.e. not a per-loop average).\nThis was added as a separate field in PostgreSQL 17, and requires both\ntrack_io_timing\nand\nBUFFERS\n.\nIn the default text format, this will show as\nI/O Timings: local read\nIn versions 15 and 16 it is available as a combined metric as\nshared/local\nGetting timing information has an overhead, due to checking the system clock. You can use\npg_test_timing\nto measure this for your system.",
    "Local I/O Write Time":
      "The time spent writing local data (e.g. for temporary tables and indexes), in\nmilliseconds\n.\nThis\nincludes\nvalues for child operations and is a total value (i.e. not a per-loop average).\nThis was added as a separate field in PostgreSQL 17, and requires both\ntrack_io_timing\nand\nBUFFERS\n.\nIn the default text format, this will show as\nI/O Timings: local write\nIn versions 15 and 16 it is available as a combined metric as\nshared/local\nGetting timing information has an overhead, due to checking the system clock. You can use\npg_test_timing\nto measure this for your system.",
    "Temp I/O Read Time":
      "The time spent reading short-term data, in\nmilliseconds\n(for example during sort and hash operations that were not done in memory).\nThis\nincludes\nvalues for child operations and is a total value (i.e. not a per-loop average).\nThis was added in PostgreSQL 15, and requires both\ntrack_io_timing\nand\nBUFFERS\n.\nIn the text format of explain, this shows as\nI/O Timings: temp read\nGetting timing information has an overhead, due to checking the system clock. You can use\npg_test_timing\nto measure this for your system.",
    "Temp I/O Write Time":
      "The time spent writing short-term data, in\nmilliseconds\n(for example during sort and hash operations that were not done in memory).\nThis\nincludes\nvalues for child operations and is a total value (i.e. not a per-loop average).\nThis was added in PostgreSQL 15, and requires both\ntrack_io_timing\nand\nBUFFERS\n.\nIn the text format of explain, this shows as\nI/O Timings: temp write\nGetting timing information has an overhead, due to checking the system clock. You can use\npg_test_timing\nto measure this for your system.",
    Workers:
      "A summary of the operation detail broken down by thread.\nThese entries\ndon’t\ninclude the main (or leader) thread.\nYou can work out the values for the main thread by subtracting the worker statistics from the total.\nThis information is only shown when VERBOSE is on.",
  },
  HashSetOp: {
    Strategy:
      "Which strategy of aggregation was performed: Plain, Hashed, Sorted, or Mixed.\nIn non-text format query plans, this lets you see whether Postgres is doing a HashAggregate (Hashed), a GroupAggregate (Sorted), or a MixedAggregate (Mixed).",
    "Parent Relationship":
      "A guide as to why this operation needs to be run in order to facilitate the parent operation. There are six different possibilities:\nOuter\n: The value you’ll see most often. It means “take in the rows from this operation as input, process them and pass them on”.\nInner\n: Only ever seen on the second child of join operations, and is always seen there. This is the “inner” part of the loop — for each outer row, we look up its match using this operation.\nMember\n: Used for all children of Append and ModifyTable nodes, and on bitmap processing nodes like BitmapAnd and BitmapOr operations.\nInitPlan\n: Used for calculations performed before the query can start, eg a constant referred to in the query or the result of a CTE scan.\nSubquery\n: The child is a subquery of the parent operation. Since Postgres always uses subquery scans to feed subquery data to parent queries, only ever appears on the children of subquery scans.\nSubPlan\n: Like a Subquery, represents a new query, but used when a subquery scan is not necessary.",
    "Parallel Aware":
      "Whether or not the operation will be run in a special mode to support parallelism. Some operations need to be aware that they are running in parallel, for example sequential scans need to know they only need to scan a smaller proportion of the table. Other operations can be run on several threads without each one having any knowledge of the others.",
    Command:
      "The set operation:\nIntersect\nor\nExcept\n.\nUNION operations are handled by Append.",
    "Startup Cost":
      "The estimated cost of returning the first row.\nThis is in an arbitrary unit, with the aim of being correlated to the startup time.",
    "Total Cost":
      "The estimated cost of returning all rows. This is in an arbitrary unit, with the aim of being correlated to the total time.\nThe Postgres query planner often has several ways it could resolve the same query. It calculates costs — which are hopefully correlated with the time it would take — for potential plans, and then picks the one with the lowest cost. It’s worth bearing in mind that the costs are unit-free — they’re not designed to convert into time, or disk reads. They’re just supposed to be bigger for slower operations, and smaller for faster ones.\nIf the planner thinks it can finish early due to a parent Limit operation, the total cost of the Limit operation will reflect this, but the total cost of its child operations will not.",
    "Plan Rows":
      "The number of rows,\nper-loop\n, that the planner expects to be returned by the operation.\nPoor row estimates can lead to suboptimal query planning. They can often be improved by running\nANALYZE\n(not the EXPLAIN parameter), by increasing statistics, or by allowing Postgres to understand correlation between columns using multivariate statistics.\nIf the planner thinks it can finish early due to a Limit operation, the plan rows of the Limit operation will reflect this, but the plan rows of its child operations will not.",
    "Plan Width":
      "The\nestimated\naverage size of the rows produced by the operation, in\nbytes\n.",
    "Actual Startup Time":
      "The amount of time, in\nmilliseconds\n, it takes to get the first row out of the operation.\nSometimes, this is very close to the setup time — for example on a sequential scan which returns all the rows in a table.\nOther times, though, it’s more or less the total time. For example, in order to return the first row of a sort, you have to sort all of the rows to work out which one comes first.",
    "Actual Total Time":
      "The actual amount of time in milliseconds spent on this operation\nand all of its children\n. It’s a\nper-loop average\n, rounded to the nearest thousandth of a millisecond.\nWorking out individual operation timings, especially where CTEs and SubPlans are concerned, can be tricky. This is one of the main reasons we decided to build\npgMustard\n.",
    "Actual Rows":
      "The number of rows returned by the operation\nper loop\n.\nThe important thing to notice about this is that it’s an average of all the loops executed, rounded to the nearest integer. This means that while “Actual Loops” multiplied by “Actual Rows” is a pretty good approximation for total number of rows returned most of the time, it can be off by as much as half of the number of loops. Usually it’s just slightly confusing as you see a row or two appear or disappear between operations, but on operations with lots of loops there is potential for serious miscalculation.\nPoor row estimates, where Actual Rows differs substantially from Plan Rows, can lead to suboptimal query planning. Estimates can often be improved by running\nANALYZE\n(not the EXPLAIN parameter), by increasing statistics, or by allowing Postgres to understand correlation between columns using multivariate statistics.",
    "Actual Loops":
      "The number of times the operation is executed. For a lot of operations it will have a value of one, but when it is not, there are three different cases:\nSome operations can be executed more than once. For example, “Nested Loops” run their “Inner” child once for every row returned by their “Outer” child.\nWhen an operation that would normally only consist of one loop is split across multiple threads, each partial operation is counted as a Loop.\nThe number of loops can be zero when an operation doesn’t need to be executed at all. For example if a table read is planned to provide candidates for an inner join, but there turns out to be no rows on the other side of the join, the operation can be effectively eliminated.",
    Output:
      "A list of the columns returned by the operation.\nThis is only shown when VERBOSE is on.",
    "Shared Hit Blocks":
      "The number of blocks from indexes/tables that were found in the Postgres buffer cache.\nThis\nincludes\nvalues for child operations and is a\ntotal\nvalue (i.e. not a per-loop average).\nOnce you have subtracted child operation values, the proportion of shared hit to shared read blocks is an interesting measure of cache performance.\nThe ratio of shared blocks (hit plus read) to rows processed (including any filtered out) is also interesting: a high ratio means Postgres is reading a lot of data for what it is doing, which can be a sign of bloat.",
    "Shared Read Blocks":
      "The number of blocks from tables/indexes that were read from disk (or the OS cache).\nThis\nincludes\nvalues for child operations and is a\ntotal\nvalue (i.e. not per-loop).\nOnce you have subtracted child operation values, the proportion of shared hit to shared read blocks is an interesting measure of cache performance.\nThe ratio of shared blocks (hit plus read) to rows processed (including any filtered out) is also interesting: a high ratio means Postgres is reading a lot of data for what it is doing, which can be a sign of bloat.",
    "Shared Dirtied Blocks":
      "The number of blocks from tables/indexes that were modified by the operation.\nThis\nincludes\nvalues for child operations and is a\ntotal\nvalue (i.e. not per-loop).\nInterestingly, a SELECT query can report shared dirtied blocks when setting hint bits on recently-committed rows, or pruning old row versions. While somewhat surprising, both of these are perfectly normal and healthy.",
    "Shared Written Blocks":
      "The number of blocks from tables/indexes that were evicted from the cache.\nThis\nincludes\nvalues for child operations and is a\ntotal\nvalue (i.e. not a per-loop average).",
    "Local Hit Blocks":
      "The number of blocks from temporary tables and indexes that were found in the cache.\nThis\nincludes\nvalues for child operations and is a\ntotal\nvalue (not a per-loop average).",
    "Local Read Blocks":
      "The number of blocks read from\ntemporary tables and indexes that were not found in the Postgres cache (read from disk or the OS cache).\nThis\nincludes\nvalues for child operations and is a\ntotal\nvalue (not a per-loop average).",
    "Local Dirtied Blocks":
      "The number of blocks from\ntemporary tables and indexes that have been modified by the operation.\nThis\nincludes\nvalues for child operations and is a\ntotal\nvalue (i.e. not a per-loop average).",
    "Local Written Blocks":
      "The number of blocks from\ntemporary tables and indexes that were evicted from the cache.\nThis\nincludes\nvalues for child operations and is a\ntotal\nvalue (i.e. not a per-loop average).",
    "Temp Read Blocks":
      "The number of blocks read from short-term data used to calculate hashes, sorts, Materialize operations, and similar.\nThis\nincludes\nvalues for child operations and is a\ntotal\nvalue (i.e. not a per-loop average).\nYour settings of\nwork_mem\nand\nhash_mem_multiplier\ndetermine how much memory is available to Postgres per operation.",
    "Temp Written Blocks":
      "The number of blocks from short-term data (used to calculate operations like hashes, sorts, and materializes) that were evicted from the cache.\nThis\nincludes\nvalues for child operations and is a\ntotal\nvalue (i.e. not a per-loop average).\nYour settings of\nwork_mem\nand\nhash_mem_multiplier\ndetermine how much memory is available to Postgres per operation.",
    "Shared I/O Read Time":
      "The time spent reading data from tables and indexes, in\nmilliseconds\n.\nThis\nincludes\nvalues for child operations and is a total value (not a per-loop average).\nRequires\ntrack_io_timing\nand\nBUFFERS\nto be on.\nIn the latest version, the text format of explain displays this as\nI/O Timings: shared read\nIn PostgreSQL 15 and 16 it shows as a combined metric\nI/O Timings: shared/local read\nGetting timing information has an overhead, due to checking the system clock. You can use\npg_test_timing\nto measure this for your system.",
    "Shared I/O Write Time":
      "The time spent writing data for tables and indexes, in\nmilliseconds\n.\nThis\nincludes\nvalues for child operations and is a total value (not a per-loop average).\nRequires\ntrack_io_timing\nand\nBUFFERS\nto be on.\nIn the latest version, the text format of explain displays this as\nI/O Timings: shared write\nIn PostgreSQL 15 and 16 it shows as a combined metric\nI/O Timings: shared/local write\nGetting timing information has an overhead, due to checking the system clock. You can use\npg_test_timing\nto measure this for your system.",
    "Local I/O Read Time":
      "The time spent reading local data (e.g. from temporary tables and indexes), in\nmilliseconds\n.\nThis\nincludes\nvalues for child operations and is a total value (i.e. not a per-loop average).\nThis was added as a separate field in PostgreSQL 17, and requires both\ntrack_io_timing\nand\nBUFFERS\n.\nIn the default text format, this will show as\nI/O Timings: local read\nIn versions 15 and 16 it is available as a combined metric as\nshared/local\nGetting timing information has an overhead, due to checking the system clock. You can use\npg_test_timing\nto measure this for your system.",
    "Local I/O Write Time":
      "The time spent writing local data (e.g. for temporary tables and indexes), in\nmilliseconds\n.\nThis\nincludes\nvalues for child operations and is a total value (i.e. not a per-loop average).\nThis was added as a separate field in PostgreSQL 17, and requires both\ntrack_io_timing\nand\nBUFFERS\n.\nIn the default text format, this will show as\nI/O Timings: local write\nIn versions 15 and 16 it is available as a combined metric as\nshared/local\nGetting timing information has an overhead, due to checking the system clock. You can use\npg_test_timing\nto measure this for your system.",
    "Temp I/O Read Time":
      "The time spent reading short-term data, in\nmilliseconds\n(for example during sort and hash operations that were not done in memory).\nThis\nincludes\nvalues for child operations and is a total value (i.e. not a per-loop average).\nThis was added in PostgreSQL 15, and requires both\ntrack_io_timing\nand\nBUFFERS\n.\nIn the text format of explain, this shows as\nI/O Timings: temp read\nGetting timing information has an overhead, due to checking the system clock. You can use\npg_test_timing\nto measure this for your system.",
    "Temp I/O Write Time":
      "The time spent writing short-term data, in\nmilliseconds\n(for example during sort and hash operations that were not done in memory).\nThis\nincludes\nvalues for child operations and is a total value (i.e. not a per-loop average).\nThis was added in PostgreSQL 15, and requires both\ntrack_io_timing\nand\nBUFFERS\n.\nIn the text format of explain, this shows as\nI/O Timings: temp write\nGetting timing information has an overhead, due to checking the system clock. You can use\npg_test_timing\nto measure this for your system.",
  },
  "Incremental Sort": {
    "Parent Relationship":
      "A guide as to why this operation needs to be run in order to facilitate the parent operation. There are six different possibilities:\nOuter\n: The value you’ll see most often. It means “take in the rows from this operation as input, process them and pass them on”.\nInner\n: Only ever seen on the second child of join operations, and is always seen there. This is the “inner” part of the loop — for each outer row, we look up its match using this operation.\nMember\n: Used for all children of Append and ModifyTable nodes, and on bitmap processing nodes like BitmapAnd and BitmapOr operations.\nInitPlan\n: Used for calculations performed before the query can start, eg a constant referred to in the query or the result of a CTE scan.\nSubquery\n: The child is a subquery of the parent operation. Since Postgres always uses subquery scans to feed subquery data to parent queries, only ever appears on the children of subquery scans.\nSubPlan\n: Like a Subquery, represents a new query, but used when a subquery scan is not necessary.",
    "Parallel Aware":
      "Whether or not the operation will be run in a special mode to support parallelism. Some operations need to be aware that they are running in parallel, for example sequential scans need to know they only need to scan a smaller proportion of the table. Other operations can be run on several threads without each one having any knowledge of the others.",
    "Startup Cost":
      "The estimated cost of returning the first row.\nThis is in an arbitrary unit, with the aim of being correlated to the startup time.",
    "Total Cost":
      "The estimated cost of returning all rows. This is in an arbitrary unit, with the aim of being correlated to the total time.\nThe Postgres query planner often has several ways it could resolve the same query. It calculates costs — which are hopefully correlated with the time it would take — for potential plans, and then picks the one with the lowest cost. It’s worth bearing in mind that the costs are unit-free — they’re not designed to convert into time, or disk reads. They’re just supposed to be bigger for slower operations, and smaller for faster ones.\nIf the planner thinks it can finish early due to a parent Limit operation, the total cost of the Limit operation will reflect this, but the total cost of its child operations will not.",
    "Plan Rows":
      "The number of rows,\nper-loop\n, that the planner expects to be returned by the operation.\nPoor row estimates can lead to suboptimal query planning. They can often be improved by running\nANALYZE\n(not the EXPLAIN parameter), by increasing statistics, or by allowing Postgres to understand correlation between columns using multivariate statistics.\nIf the planner thinks it can finish early due to a Limit operation, the plan rows of the Limit operation will reflect this, but the plan rows of its child operations will not.",
    "Plan Width":
      "The\nestimated\naverage size of the rows produced by the operation, in\nbytes\n.",
    "Actual Startup Time":
      "The amount of time, in\nmilliseconds\n, it takes to get the first row out of the operation.\nSometimes, this is very close to the setup time — for example on a sequential scan which returns all the rows in a table.\nOther times, though, it’s more or less the total time. For example, in order to return the first row of a sort, you have to sort all of the rows to work out which one comes first.",
    "Actual Total Time":
      "The actual amount of time in milliseconds spent on this operation\nand all of its children\n. It’s a\nper-loop average\n, rounded to the nearest thousandth of a millisecond.\nWorking out individual operation timings, especially where CTEs and SubPlans are concerned, can be tricky. This is one of the main reasons we decided to build\npgMustard\n.",
    "Actual Rows":
      "The number of rows returned by the operation\nper loop\n.\nThe important thing to notice about this is that it’s an average of all the loops executed, rounded to the nearest integer. This means that while “Actual Loops” multiplied by “Actual Rows” is a pretty good approximation for total number of rows returned most of the time, it can be off by as much as half of the number of loops. Usually it’s just slightly confusing as you see a row or two appear or disappear between operations, but on operations with lots of loops there is potential for serious miscalculation.\nPoor row estimates, where Actual Rows differs substantially from Plan Rows, can lead to suboptimal query planning. Estimates can often be improved by running\nANALYZE\n(not the EXPLAIN parameter), by increasing statistics, or by allowing Postgres to understand correlation between columns using multivariate statistics.",
    "Actual Loops":
      "The number of times the operation is executed. For a lot of operations it will have a value of one, but when it is not, there are three different cases:\nSome operations can be executed more than once. For example, “Nested Loops” run their “Inner” child once for every row returned by their “Outer” child.\nWhen an operation that would normally only consist of one loop is split across multiple threads, each partial operation is counted as a Loop.\nThe number of loops can be zero when an operation doesn’t need to be executed at all. For example if a table read is planned to provide candidates for an inner join, but there turns out to be no rows on the other side of the join, the operation can be effectively eliminated.",
    Output:
      "A list of the columns returned by the operation.\nThis is only shown when VERBOSE is on.",
    "Sort Key":
      "The order by condition.\nIf the sort is by a single column, or multiple columns from the same table, you may be able to avoid the sort entirely by adding an index with the desired order.",
    "Presorted Key":
      "The Presorted Key are any columns from the order by condition that are already in order as part of an Incremental Sort operation.\nIf the sort is by multiple columns from the same table, you may be able to avoid the sort entirely by adding an index with the desired order, which you can see from the Sort Key.",
    "Sort Method":
      "If the memory it requires is lower than your\nwork_mem\nsetting, Postgres can use a\nquicksort\n, or (if there is a LIMIT) a\ntop-N heapsort\n.\nOtherwise, it will do an\nexternal\nsort on-disk, which is slow but may be necessary for a large sort. If the sort is by a single column, or multiple columns from the same table, you may be able to avoid it entirely by adding an index with the desired order.\nAn external sort has a lower footprint than a quicksort, so it is possible to see external sorts with\nsort space used\nlower than\nwork_mem\n.",
    "Sort Space Used":
      "The amount of memory or disk space, in\nKB\n, used for the sort.\nAn external sort has a lower footprint than a quicksort, so it is possible to see external sorts with sort space used lower than\nwork_mem\n.",
    "Sort Space Type":
      "Whether the sort was done in\nmemory\nor on\ndisk\n.\nOn-disk sorts have a lower footprint than in-memory sorts, so it is possible to see on-disk sorts with\nsort space used\nlower than\nwork_mem\n.",
    "Shared Hit Blocks":
      "The number of blocks from indexes/tables that were found in the Postgres buffer cache.\nThis\nincludes\nvalues for child operations and is a\ntotal\nvalue (i.e. not a per-loop average).\nOnce you have subtracted child operation values, the proportion of shared hit to shared read blocks is an interesting measure of cache performance.\nThe ratio of shared blocks (hit plus read) to rows processed (including any filtered out) is also interesting: a high ratio means Postgres is reading a lot of data for what it is doing, which can be a sign of bloat.",
    "Shared Read Blocks":
      "The number of blocks from tables/indexes that were read from disk (or the OS cache).\nThis\nincludes\nvalues for child operations and is a\ntotal\nvalue (i.e. not per-loop).\nOnce you have subtracted child operation values, the proportion of shared hit to shared read blocks is an interesting measure of cache performance.\nThe ratio of shared blocks (hit plus read) to rows processed (including any filtered out) is also interesting: a high ratio means Postgres is reading a lot of data for what it is doing, which can be a sign of bloat.",
    "Shared Dirtied Blocks":
      "The number of blocks from tables/indexes that were modified by the operation.\nThis\nincludes\nvalues for child operations and is a\ntotal\nvalue (i.e. not per-loop).\nInterestingly, a SELECT query can report shared dirtied blocks when setting hint bits on recently-committed rows, or pruning old row versions. While somewhat surprising, both of these are perfectly normal and healthy.",
    "Shared Written Blocks":
      "The number of blocks from tables/indexes that were evicted from the cache.\nThis\nincludes\nvalues for child operations and is a\ntotal\nvalue (i.e. not a per-loop average).",
    "Local Hit Blocks":
      "The number of blocks from temporary tables and indexes that were found in the cache.\nThis\nincludes\nvalues for child operations and is a\ntotal\nvalue (not a per-loop average).",
    "Local Read Blocks":
      "The number of blocks read from\ntemporary tables and indexes that were not found in the Postgres cache (read from disk or the OS cache).\nThis\nincludes\nvalues for child operations and is a\ntotal\nvalue (not a per-loop average).",
    "Local Dirtied Blocks":
      "The number of blocks from\ntemporary tables and indexes that have been modified by the operation.\nThis\nincludes\nvalues for child operations and is a\ntotal\nvalue (i.e. not a per-loop average).",
    "Local Written Blocks":
      "The number of blocks from\ntemporary tables and indexes that were evicted from the cache.\nThis\nincludes\nvalues for child operations and is a\ntotal\nvalue (i.e. not a per-loop average).",
    "Temp Read Blocks":
      "The number of blocks read from short-term data used to calculate hashes, sorts, Materialize operations, and similar.\nThis\nincludes\nvalues for child operations and is a\ntotal\nvalue (i.e. not a per-loop average).\nYour settings of\nwork_mem\nand\nhash_mem_multiplier\ndetermine how much memory is available to Postgres per operation.",
    "Temp Written Blocks":
      "The number of blocks from short-term data (used to calculate operations like hashes, sorts, and materializes) that were evicted from the cache.\nThis\nincludes\nvalues for child operations and is a\ntotal\nvalue (i.e. not a per-loop average).\nYour settings of\nwork_mem\nand\nhash_mem_multiplier\ndetermine how much memory is available to Postgres per operation.",
    "Shared I/O Read Time":
      "The time spent reading data from tables and indexes, in\nmilliseconds\n.\nThis\nincludes\nvalues for child operations and is a total value (not a per-loop average).\nRequires\ntrack_io_timing\nand\nBUFFERS\nto be on.\nIn the latest version, the text format of explain displays this as\nI/O Timings: shared read\nIn PostgreSQL 15 and 16 it shows as a combined metric\nI/O Timings: shared/local read\nGetting timing information has an overhead, due to checking the system clock. You can use\npg_test_timing\nto measure this for your system.",
    "Shared I/O Write Time":
      "The time spent writing data for tables and indexes, in\nmilliseconds\n.\nThis\nincludes\nvalues for child operations and is a total value (not a per-loop average).\nRequires\ntrack_io_timing\nand\nBUFFERS\nto be on.\nIn the latest version, the text format of explain displays this as\nI/O Timings: shared write\nIn PostgreSQL 15 and 16 it shows as a combined metric\nI/O Timings: shared/local write\nGetting timing information has an overhead, due to checking the system clock. You can use\npg_test_timing\nto measure this for your system.",
    "Local I/O Read Time":
      "The time spent reading local data (e.g. from temporary tables and indexes), in\nmilliseconds\n.\nThis\nincludes\nvalues for child operations and is a total value (i.e. not a per-loop average).\nThis was added as a separate field in PostgreSQL 17, and requires both\ntrack_io_timing\nand\nBUFFERS\n.\nIn the default text format, this will show as\nI/O Timings: local read\nIn versions 15 and 16 it is available as a combined metric as\nshared/local\nGetting timing information has an overhead, due to checking the system clock. You can use\npg_test_timing\nto measure this for your system.",
    "Local I/O Write Time":
      "The time spent writing local data (e.g. for temporary tables and indexes), in\nmilliseconds\n.\nThis\nincludes\nvalues for child operations and is a total value (i.e. not a per-loop average).\nThis was added as a separate field in PostgreSQL 17, and requires both\ntrack_io_timing\nand\nBUFFERS\n.\nIn the default text format, this will show as\nI/O Timings: local write\nIn versions 15 and 16 it is available as a combined metric as\nshared/local\nGetting timing information has an overhead, due to checking the system clock. You can use\npg_test_timing\nto measure this for your system.",
    "Temp I/O Read Time":
      "The time spent reading short-term data, in\nmilliseconds\n(for example during sort and hash operations that were not done in memory).\nThis\nincludes\nvalues for child operations and is a total value (i.e. not a per-loop average).\nThis was added in PostgreSQL 15, and requires both\ntrack_io_timing\nand\nBUFFERS\n.\nIn the text format of explain, this shows as\nI/O Timings: temp read\nGetting timing information has an overhead, due to checking the system clock. You can use\npg_test_timing\nto measure this for your system.",
    "Temp I/O Write Time":
      "The time spent writing short-term data, in\nmilliseconds\n(for example during sort and hash operations that were not done in memory).\nThis\nincludes\nvalues for child operations and is a total value (i.e. not a per-loop average).\nThis was added in PostgreSQL 15, and requires both\ntrack_io_timing\nand\nBUFFERS\n.\nIn the text format of explain, this shows as\nI/O Timings: temp write\nGetting timing information has an overhead, due to checking the system clock. You can use\npg_test_timing\nto measure this for your system.",
    Workers:
      "A summary of the operation detail broken down by thread.\nThese entries\ndon’t\ninclude the main (or leader) thread.\nYou can work out the values for the main thread by subtracting the worker statistics from the total.\nThis information is only shown when VERBOSE is on.",
  },
  Limit: {
    "Parent Relationship":
      "A guide as to why this operation needs to be run in order to facilitate the parent operation. There are six different possibilities:\nOuter\n: The value you’ll see most often. It means “take in the rows from this operation as input, process them and pass them on”.\nInner\n: Only ever seen on the second child of join operations, and is always seen there. This is the “inner” part of the loop — for each outer row, we look up its match using this operation.\nMember\n: Used for all children of Append and ModifyTable nodes, and on bitmap processing nodes like BitmapAnd and BitmapOr operations.\nInitPlan\n: Used for calculations performed before the query can start, eg a constant referred to in the query or the result of a CTE scan.\nSubquery\n: The child is a subquery of the parent operation. Since Postgres always uses subquery scans to feed subquery data to parent queries, only ever appears on the children of subquery scans.\nSubPlan\n: Like a Subquery, represents a new query, but used when a subquery scan is not necessary.",
    "Parallel Aware":
      "Whether or not the operation will be run in a special mode to support parallelism. Some operations need to be aware that they are running in parallel, for example sequential scans need to know they only need to scan a smaller proportion of the table. Other operations can be run on several threads without each one having any knowledge of the others.",
    "Startup Cost":
      "The estimated cost of returning the first row.\nThis is in an arbitrary unit, with the aim of being correlated to the startup time.",
    "Total Cost":
      "The estimated cost of returning all rows. This is in an arbitrary unit, with the aim of being correlated to the total time.\nThe Postgres query planner often has several ways it could resolve the same query. It calculates costs — which are hopefully correlated with the time it would take — for potential plans, and then picks the one with the lowest cost. It’s worth bearing in mind that the costs are unit-free — they’re not designed to convert into time, or disk reads. They’re just supposed to be bigger for slower operations, and smaller for faster ones.\nIf the planner thinks it can finish early due to a parent Limit operation, the total cost of the Limit operation will reflect this, but the total cost of its child operations will not.",
    "Plan Rows":
      "The number of rows,\nper-loop\n, that the planner expects to be returned by the operation.\nPoor row estimates can lead to suboptimal query planning. They can often be improved by running\nANALYZE\n(not the EXPLAIN parameter), by increasing statistics, or by allowing Postgres to understand correlation between columns using multivariate statistics.\nIf the planner thinks it can finish early due to a Limit operation, the plan rows of the Limit operation will reflect this, but the plan rows of its child operations will not.",
    "Plan Width":
      "The\nestimated\naverage size of the rows produced by the operation, in\nbytes\n.",
    "Actual Startup Time":
      "The amount of time, in\nmilliseconds\n, it takes to get the first row out of the operation.\nSometimes, this is very close to the setup time — for example on a sequential scan which returns all the rows in a table.\nOther times, though, it’s more or less the total time. For example, in order to return the first row of a sort, you have to sort all of the rows to work out which one comes first.",
    "Actual Total Time":
      "The actual amount of time in milliseconds spent on this operation\nand all of its children\n. It’s a\nper-loop average\n, rounded to the nearest thousandth of a millisecond.\nWorking out individual operation timings, especially where CTEs and SubPlans are concerned, can be tricky. This is one of the main reasons we decided to build\npgMustard\n.",
    "Actual Rows":
      "The number of rows returned by the operation\nper loop\n.\nThe important thing to notice about this is that it’s an average of all the loops executed, rounded to the nearest integer. This means that while “Actual Loops” multiplied by “Actual Rows” is a pretty good approximation for total number of rows returned most of the time, it can be off by as much as half of the number of loops. Usually it’s just slightly confusing as you see a row or two appear or disappear between operations, but on operations with lots of loops there is potential for serious miscalculation.\nPoor row estimates, where Actual Rows differs substantially from Plan Rows, can lead to suboptimal query planning. Estimates can often be improved by running\nANALYZE\n(not the EXPLAIN parameter), by increasing statistics, or by allowing Postgres to understand correlation between columns using multivariate statistics.",
    "Actual Loops":
      "The number of times the operation is executed. For a lot of operations it will have a value of one, but when it is not, there are three different cases:\nSome operations can be executed more than once. For example, “Nested Loops” run their “Inner” child once for every row returned by their “Outer” child.\nWhen an operation that would normally only consist of one loop is split across multiple threads, each partial operation is counted as a Loop.\nThe number of loops can be zero when an operation doesn’t need to be executed at all. For example if a table read is planned to provide candidates for an inner join, but there turns out to be no rows on the other side of the join, the operation can be effectively eliminated.",
    Output:
      "A list of the columns returned by the operation.\nThis is only shown when VERBOSE is on.",
    "Shared Hit Blocks":
      "The number of blocks from indexes/tables that were found in the Postgres buffer cache.\nThis\nincludes\nvalues for child operations and is a\ntotal\nvalue (i.e. not a per-loop average).\nOnce you have subtracted child operation values, the proportion of shared hit to shared read blocks is an interesting measure of cache performance.\nThe ratio of shared blocks (hit plus read) to rows processed (including any filtered out) is also interesting: a high ratio means Postgres is reading a lot of data for what it is doing, which can be a sign of bloat.",
    "Shared Read Blocks":
      "The number of blocks from tables/indexes that were read from disk (or the OS cache).\nThis\nincludes\nvalues for child operations and is a\ntotal\nvalue (i.e. not per-loop).\nOnce you have subtracted child operation values, the proportion of shared hit to shared read blocks is an interesting measure of cache performance.\nThe ratio of shared blocks (hit plus read) to rows processed (including any filtered out) is also interesting: a high ratio means Postgres is reading a lot of data for what it is doing, which can be a sign of bloat.",
    "Shared Dirtied Blocks":
      "The number of blocks from tables/indexes that were modified by the operation.\nThis\nincludes\nvalues for child operations and is a\ntotal\nvalue (i.e. not per-loop).\nInterestingly, a SELECT query can report shared dirtied blocks when setting hint bits on recently-committed rows, or pruning old row versions. While somewhat surprising, both of these are perfectly normal and healthy.",
    "Shared Written Blocks":
      "The number of blocks from tables/indexes that were evicted from the cache.\nThis\nincludes\nvalues for child operations and is a\ntotal\nvalue (i.e. not a per-loop average).",
    "Local Hit Blocks":
      "The number of blocks from temporary tables and indexes that were found in the cache.\nThis\nincludes\nvalues for child operations and is a\ntotal\nvalue (not a per-loop average).",
    "Local Read Blocks":
      "The number of blocks read from\ntemporary tables and indexes that were not found in the Postgres cache (read from disk or the OS cache).\nThis\nincludes\nvalues for child operations and is a\ntotal\nvalue (not a per-loop average).",
    "Local Dirtied Blocks":
      "The number of blocks from\ntemporary tables and indexes that have been modified by the operation.\nThis\nincludes\nvalues for child operations and is a\ntotal\nvalue (i.e. not a per-loop average).",
    "Local Written Blocks":
      "The number of blocks from\ntemporary tables and indexes that were evicted from the cache.\nThis\nincludes\nvalues for child operations and is a\ntotal\nvalue (i.e. not a per-loop average).",
    "Temp Read Blocks":
      "The number of blocks read from short-term data used to calculate hashes, sorts, Materialize operations, and similar.\nThis\nincludes\nvalues for child operations and is a\ntotal\nvalue (i.e. not a per-loop average).\nYour settings of\nwork_mem\nand\nhash_mem_multiplier\ndetermine how much memory is available to Postgres per operation.",
    "Temp Written Blocks":
      "The number of blocks from short-term data (used to calculate operations like hashes, sorts, and materializes) that were evicted from the cache.\nThis\nincludes\nvalues for child operations and is a\ntotal\nvalue (i.e. not a per-loop average).\nYour settings of\nwork_mem\nand\nhash_mem_multiplier\ndetermine how much memory is available to Postgres per operation.",
    "Shared I/O Read Time":
      "The time spent reading data from tables and indexes, in\nmilliseconds\n.\nThis\nincludes\nvalues for child operations and is a total value (not a per-loop average).\nRequires\ntrack_io_timing\nand\nBUFFERS\nto be on.\nIn the latest version, the text format of explain displays this as\nI/O Timings: shared read\nIn PostgreSQL 15 and 16 it shows as a combined metric\nI/O Timings: shared/local read\nGetting timing information has an overhead, due to checking the system clock. You can use\npg_test_timing\nto measure this for your system.",
    "Shared I/O Write Time":
      "The time spent writing data for tables and indexes, in\nmilliseconds\n.\nThis\nincludes\nvalues for child operations and is a total value (not a per-loop average).\nRequires\ntrack_io_timing\nand\nBUFFERS\nto be on.\nIn the latest version, the text format of explain displays this as\nI/O Timings: shared write\nIn PostgreSQL 15 and 16 it shows as a combined metric\nI/O Timings: shared/local write\nGetting timing information has an overhead, due to checking the system clock. You can use\npg_test_timing\nto measure this for your system.",
    "Local I/O Read Time":
      "The time spent reading local data (e.g. from temporary tables and indexes), in\nmilliseconds\n.\nThis\nincludes\nvalues for child operations and is a total value (i.e. not a per-loop average).\nThis was added as a separate field in PostgreSQL 17, and requires both\ntrack_io_timing\nand\nBUFFERS\n.\nIn the default text format, this will show as\nI/O Timings: local read\nIn versions 15 and 16 it is available as a combined metric as\nshared/local\nGetting timing information has an overhead, due to checking the system clock. You can use\npg_test_timing\nto measure this for your system.",
    "Local I/O Write Time":
      "The time spent writing local data (e.g. for temporary tables and indexes), in\nmilliseconds\n.\nThis\nincludes\nvalues for child operations and is a total value (i.e. not a per-loop average).\nThis was added as a separate field in PostgreSQL 17, and requires both\ntrack_io_timing\nand\nBUFFERS\n.\nIn the default text format, this will show as\nI/O Timings: local write\nIn versions 15 and 16 it is available as a combined metric as\nshared/local\nGetting timing information has an overhead, due to checking the system clock. You can use\npg_test_timing\nto measure this for your system.",
    "Temp I/O Read Time":
      "The time spent reading short-term data, in\nmilliseconds\n(for example during sort and hash operations that were not done in memory).\nThis\nincludes\nvalues for child operations and is a total value (i.e. not a per-loop average).\nThis was added in PostgreSQL 15, and requires both\ntrack_io_timing\nand\nBUFFERS\n.\nIn the text format of explain, this shows as\nI/O Timings: temp read\nGetting timing information has an overhead, due to checking the system clock. You can use\npg_test_timing\nto measure this for your system.",
    "Temp I/O Write Time":
      "The time spent writing short-term data, in\nmilliseconds\n(for example during sort and hash operations that were not done in memory).\nThis\nincludes\nvalues for child operations and is a total value (i.e. not a per-loop average).\nThis was added in PostgreSQL 15, and requires both\ntrack_io_timing\nand\nBUFFERS\n.\nIn the text format of explain, this shows as\nI/O Timings: temp write\nGetting timing information has an overhead, due to checking the system clock. You can use\npg_test_timing\nto measure this for your system.",
  },
  LockRows: {
    "Parent Relationship":
      "A guide as to why this operation needs to be run in order to facilitate the parent operation. There are six different possibilities:\nOuter\n: The value you’ll see most often. It means “take in the rows from this operation as input, process them and pass them on”.\nInner\n: Only ever seen on the second child of join operations, and is always seen there. This is the “inner” part of the loop — for each outer row, we look up its match using this operation.\nMember\n: Used for all children of Append and ModifyTable nodes, and on bitmap processing nodes like BitmapAnd and BitmapOr operations.\nInitPlan\n: Used for calculations performed before the query can start, eg a constant referred to in the query or the result of a CTE scan.\nSubquery\n: The child is a subquery of the parent operation. Since Postgres always uses subquery scans to feed subquery data to parent queries, only ever appears on the children of subquery scans.\nSubPlan\n: Like a Subquery, represents a new query, but used when a subquery scan is not necessary.",
    "Parallel Aware":
      "Whether or not the operation will be run in a special mode to support parallelism. Some operations need to be aware that they are running in parallel, for example sequential scans need to know they only need to scan a smaller proportion of the table. Other operations can be run on several threads without each one having any knowledge of the others.",
    "Startup Cost":
      "The estimated cost of returning the first row.\nThis is in an arbitrary unit, with the aim of being correlated to the startup time.",
    "Total Cost":
      "The estimated cost of returning all rows. This is in an arbitrary unit, with the aim of being correlated to the total time.\nThe Postgres query planner often has several ways it could resolve the same query. It calculates costs — which are hopefully correlated with the time it would take — for potential plans, and then picks the one with the lowest cost. It’s worth bearing in mind that the costs are unit-free — they’re not designed to convert into time, or disk reads. They’re just supposed to be bigger for slower operations, and smaller for faster ones.\nIf the planner thinks it can finish early due to a parent Limit operation, the total cost of the Limit operation will reflect this, but the total cost of its child operations will not.",
    "Plan Rows":
      "The number of rows,\nper-loop\n, that the planner expects to be returned by the operation.\nPoor row estimates can lead to suboptimal query planning. They can often be improved by running\nANALYZE\n(not the EXPLAIN parameter), by increasing statistics, or by allowing Postgres to understand correlation between columns using multivariate statistics.\nIf the planner thinks it can finish early due to a Limit operation, the plan rows of the Limit operation will reflect this, but the plan rows of its child operations will not.",
    "Plan Width":
      "The\nestimated\naverage size of the rows produced by the operation, in\nbytes\n.",
    "Actual Startup Time":
      "The amount of time, in\nmilliseconds\n, it takes to get the first row out of the operation.\nSometimes, this is very close to the setup time — for example on a sequential scan which returns all the rows in a table.\nOther times, though, it’s more or less the total time. For example, in order to return the first row of a sort, you have to sort all of the rows to work out which one comes first.",
    "Actual Total Time":
      "The actual amount of time in milliseconds spent on this operation\nand all of its children\n. It’s a\nper-loop average\n, rounded to the nearest thousandth of a millisecond.\nWorking out individual operation timings, especially where CTEs and SubPlans are concerned, can be tricky. This is one of the main reasons we decided to build\npgMustard\n.",
    "Actual Rows":
      "The number of rows returned by the operation\nper loop\n.\nThe important thing to notice about this is that it’s an average of all the loops executed, rounded to the nearest integer. This means that while “Actual Loops” multiplied by “Actual Rows” is a pretty good approximation for total number of rows returned most of the time, it can be off by as much as half of the number of loops. Usually it’s just slightly confusing as you see a row or two appear or disappear between operations, but on operations with lots of loops there is potential for serious miscalculation.\nPoor row estimates, where Actual Rows differs substantially from Plan Rows, can lead to suboptimal query planning. Estimates can often be improved by running\nANALYZE\n(not the EXPLAIN parameter), by increasing statistics, or by allowing Postgres to understand correlation between columns using multivariate statistics.",
    "Actual Loops":
      "The number of times the operation is executed. For a lot of operations it will have a value of one, but when it is not, there are three different cases:\nSome operations can be executed more than once. For example, “Nested Loops” run their “Inner” child once for every row returned by their “Outer” child.\nWhen an operation that would normally only consist of one loop is split across multiple threads, each partial operation is counted as a Loop.\nThe number of loops can be zero when an operation doesn’t need to be executed at all. For example if a table read is planned to provide candidates for an inner join, but there turns out to be no rows on the other side of the join, the operation can be effectively eliminated.",
    Output:
      "A list of the columns returned by the operation.\nThis is only shown when VERBOSE is on.",
    "Shared Hit Blocks":
      "The number of blocks from indexes/tables that were found in the Postgres buffer cache.\nThis\nincludes\nvalues for child operations and is a\ntotal\nvalue (i.e. not a per-loop average).\nOnce you have subtracted child operation values, the proportion of shared hit to shared read blocks is an interesting measure of cache performance.\nThe ratio of shared blocks (hit plus read) to rows processed (including any filtered out) is also interesting: a high ratio means Postgres is reading a lot of data for what it is doing, which can be a sign of bloat.",
    "Shared Read Blocks":
      "The number of blocks from tables/indexes that were read from disk (or the OS cache).\nThis\nincludes\nvalues for child operations and is a\ntotal\nvalue (i.e. not per-loop).\nOnce you have subtracted child operation values, the proportion of shared hit to shared read blocks is an interesting measure of cache performance.\nThe ratio of shared blocks (hit plus read) to rows processed (including any filtered out) is also interesting: a high ratio means Postgres is reading a lot of data for what it is doing, which can be a sign of bloat.",
    "Shared Dirtied Blocks":
      "The number of blocks from tables/indexes that were modified by the operation.\nThis\nincludes\nvalues for child operations and is a\ntotal\nvalue (i.e. not per-loop).\nInterestingly, a SELECT query can report shared dirtied blocks when setting hint bits on recently-committed rows, or pruning old row versions. While somewhat surprising, both of these are perfectly normal and healthy.",
    "Shared Written Blocks":
      "The number of blocks from tables/indexes that were evicted from the cache.\nThis\nincludes\nvalues for child operations and is a\ntotal\nvalue (i.e. not a per-loop average).",
    "Local Hit Blocks":
      "The number of blocks from temporary tables and indexes that were found in the cache.\nThis\nincludes\nvalues for child operations and is a\ntotal\nvalue (not a per-loop average).",
    "Local Read Blocks":
      "The number of blocks read from\ntemporary tables and indexes that were not found in the Postgres cache (read from disk or the OS cache).\nThis\nincludes\nvalues for child operations and is a\ntotal\nvalue (not a per-loop average).",
    "Local Dirtied Blocks":
      "The number of blocks from\ntemporary tables and indexes that have been modified by the operation.\nThis\nincludes\nvalues for child operations and is a\ntotal\nvalue (i.e. not a per-loop average).",
    "Local Written Blocks":
      "The number of blocks from\ntemporary tables and indexes that were evicted from the cache.\nThis\nincludes\nvalues for child operations and is a\ntotal\nvalue (i.e. not a per-loop average).",
    "Temp Read Blocks":
      "The number of blocks read from short-term data used to calculate hashes, sorts, Materialize operations, and similar.\nThis\nincludes\nvalues for child operations and is a\ntotal\nvalue (i.e. not a per-loop average).\nYour settings of\nwork_mem\nand\nhash_mem_multiplier\ndetermine how much memory is available to Postgres per operation.",
    "Temp Written Blocks":
      "The number of blocks from short-term data (used to calculate operations like hashes, sorts, and materializes) that were evicted from the cache.\nThis\nincludes\nvalues for child operations and is a\ntotal\nvalue (i.e. not a per-loop average).\nYour settings of\nwork_mem\nand\nhash_mem_multiplier\ndetermine how much memory is available to Postgres per operation.",
    "Shared I/O Read Time":
      "The time spent reading data from tables and indexes, in\nmilliseconds\n.\nThis\nincludes\nvalues for child operations and is a total value (not a per-loop average).\nRequires\ntrack_io_timing\nand\nBUFFERS\nto be on.\nIn the latest version, the text format of explain displays this as\nI/O Timings: shared read\nIn PostgreSQL 15 and 16 it shows as a combined metric\nI/O Timings: shared/local read\nGetting timing information has an overhead, due to checking the system clock. You can use\npg_test_timing\nto measure this for your system.",
    "Shared I/O Write Time":
      "The time spent writing data for tables and indexes, in\nmilliseconds\n.\nThis\nincludes\nvalues for child operations and is a total value (not a per-loop average).\nRequires\ntrack_io_timing\nand\nBUFFERS\nto be on.\nIn the latest version, the text format of explain displays this as\nI/O Timings: shared write\nIn PostgreSQL 15 and 16 it shows as a combined metric\nI/O Timings: shared/local write\nGetting timing information has an overhead, due to checking the system clock. You can use\npg_test_timing\nto measure this for your system.",
    "Local I/O Read Time":
      "The time spent reading local data (e.g. from temporary tables and indexes), in\nmilliseconds\n.\nThis\nincludes\nvalues for child operations and is a total value (i.e. not a per-loop average).\nThis was added as a separate field in PostgreSQL 17, and requires both\ntrack_io_timing\nand\nBUFFERS\n.\nIn the default text format, this will show as\nI/O Timings: local read\nIn versions 15 and 16 it is available as a combined metric as\nshared/local\nGetting timing information has an overhead, due to checking the system clock. You can use\npg_test_timing\nto measure this for your system.",
    "Local I/O Write Time":
      "The time spent writing local data (e.g. for temporary tables and indexes), in\nmilliseconds\n.\nThis\nincludes\nvalues for child operations and is a total value (i.e. not a per-loop average).\nThis was added as a separate field in PostgreSQL 17, and requires both\ntrack_io_timing\nand\nBUFFERS\n.\nIn the default text format, this will show as\nI/O Timings: local write\nIn versions 15 and 16 it is available as a combined metric as\nshared/local\nGetting timing information has an overhead, due to checking the system clock. You can use\npg_test_timing\nto measure this for your system.",
    "Temp I/O Read Time":
      "The time spent reading short-term data, in\nmilliseconds\n(for example during sort and hash operations that were not done in memory).\nThis\nincludes\nvalues for child operations and is a total value (i.e. not a per-loop average).\nThis was added in PostgreSQL 15, and requires both\ntrack_io_timing\nand\nBUFFERS\n.\nIn the text format of explain, this shows as\nI/O Timings: temp read\nGetting timing information has an overhead, due to checking the system clock. You can use\npg_test_timing\nto measure this for your system.",
    "Temp I/O Write Time":
      "The time spent writing short-term data, in\nmilliseconds\n(for example during sort and hash operations that were not done in memory).\nThis\nincludes\nvalues for child operations and is a total value (i.e. not a per-loop average).\nThis was added in PostgreSQL 15, and requires both\ntrack_io_timing\nand\nBUFFERS\n.\nIn the text format of explain, this shows as\nI/O Timings: temp write\nGetting timing information has an overhead, due to checking the system clock. You can use\npg_test_timing\nto measure this for your system.",
  },
  Materialize: {
    "Parent Relationship":
      "A guide as to why this operation needs to be run in order to facilitate the parent operation. There are six different possibilities:\nOuter\n: The value you’ll see most often. It means “take in the rows from this operation as input, process them and pass them on”.\nInner\n: Only ever seen on the second child of join operations, and is always seen there. This is the “inner” part of the loop — for each outer row, we look up its match using this operation.\nMember\n: Used for all children of Append and ModifyTable nodes, and on bitmap processing nodes like BitmapAnd and BitmapOr operations.\nInitPlan\n: Used for calculations performed before the query can start, eg a constant referred to in the query or the result of a CTE scan.\nSubquery\n: The child is a subquery of the parent operation. Since Postgres always uses subquery scans to feed subquery data to parent queries, only ever appears on the children of subquery scans.\nSubPlan\n: Like a Subquery, represents a new query, but used when a subquery scan is not necessary.",
    "Parallel Aware":
      "Whether or not the operation will be run in a special mode to support parallelism. Some operations need to be aware that they are running in parallel, for example sequential scans need to know they only need to scan a smaller proportion of the table. Other operations can be run on several threads without each one having any knowledge of the others.",
    "Startup Cost":
      "The estimated cost of returning the first row.\nThis is in an arbitrary unit, with the aim of being correlated to the startup time.",
    "Total Cost":
      "The estimated cost of returning all rows. This is in an arbitrary unit, with the aim of being correlated to the total time.\nThe Postgres query planner often has several ways it could resolve the same query. It calculates costs — which are hopefully correlated with the time it would take — for potential plans, and then picks the one with the lowest cost. It’s worth bearing in mind that the costs are unit-free — they’re not designed to convert into time, or disk reads. They’re just supposed to be bigger for slower operations, and smaller for faster ones.\nIf the planner thinks it can finish early due to a parent Limit operation, the total cost of the Limit operation will reflect this, but the total cost of its child operations will not.",
    "Plan Rows":
      "The number of rows,\nper-loop\n, that the planner expects to be returned by the operation.\nPoor row estimates can lead to suboptimal query planning. They can often be improved by running\nANALYZE\n(not the EXPLAIN parameter), by increasing statistics, or by allowing Postgres to understand correlation between columns using multivariate statistics.\nIf the planner thinks it can finish early due to a Limit operation, the plan rows of the Limit operation will reflect this, but the plan rows of its child operations will not.",
    "Plan Width":
      "The\nestimated\naverage size of the rows produced by the operation, in\nbytes\n.",
    "Actual Startup Time":
      "The amount of time, in\nmilliseconds\n, it takes to get the first row out of the operation.\nSometimes, this is very close to the setup time — for example on a sequential scan which returns all the rows in a table.\nOther times, though, it’s more or less the total time. For example, in order to return the first row of a sort, you have to sort all of the rows to work out which one comes first.",
    "Actual Total Time":
      "The actual amount of time in milliseconds spent on this operation\nand all of its children\n. It’s a\nper-loop average\n, rounded to the nearest thousandth of a millisecond.\nWorking out individual operation timings, especially where CTEs and SubPlans are concerned, can be tricky. This is one of the main reasons we decided to build\npgMustard\n.",
    "Actual Rows":
      "The number of rows returned by the operation\nper loop\n.\nThe important thing to notice about this is that it’s an average of all the loops executed, rounded to the nearest integer. This means that while “Actual Loops” multiplied by “Actual Rows” is a pretty good approximation for total number of rows returned most of the time, it can be off by as much as half of the number of loops. Usually it’s just slightly confusing as you see a row or two appear or disappear between operations, but on operations with lots of loops there is potential for serious miscalculation.\nPoor row estimates, where Actual Rows differs substantially from Plan Rows, can lead to suboptimal query planning. Estimates can often be improved by running\nANALYZE\n(not the EXPLAIN parameter), by increasing statistics, or by allowing Postgres to understand correlation between columns using multivariate statistics.",
    "Actual Loops":
      "The number of times the operation is executed. For a lot of operations it will have a value of one, but when it is not, there are three different cases:\nSome operations can be executed more than once. For example, “Nested Loops” run their “Inner” child once for every row returned by their “Outer” child.\nWhen an operation that would normally only consist of one loop is split across multiple threads, each partial operation is counted as a Loop.\nThe number of loops can be zero when an operation doesn’t need to be executed at all. For example if a table read is planned to provide candidates for an inner join, but there turns out to be no rows on the other side of the join, the operation can be effectively eliminated.",
    Output:
      "A list of the columns returned by the operation.\nThis is only shown when VERBOSE is on.",
    "Shared Hit Blocks":
      "The number of blocks from indexes/tables that were found in the Postgres buffer cache.\nThis\nincludes\nvalues for child operations and is a\ntotal\nvalue (i.e. not a per-loop average).\nOnce you have subtracted child operation values, the proportion of shared hit to shared read blocks is an interesting measure of cache performance.\nThe ratio of shared blocks (hit plus read) to rows processed (including any filtered out) is also interesting: a high ratio means Postgres is reading a lot of data for what it is doing, which can be a sign of bloat.",
    "Shared Read Blocks":
      "The number of blocks from tables/indexes that were read from disk (or the OS cache).\nThis\nincludes\nvalues for child operations and is a\ntotal\nvalue (i.e. not per-loop).\nOnce you have subtracted child operation values, the proportion of shared hit to shared read blocks is an interesting measure of cache performance.\nThe ratio of shared blocks (hit plus read) to rows processed (including any filtered out) is also interesting: a high ratio means Postgres is reading a lot of data for what it is doing, which can be a sign of bloat.",
    "Shared Dirtied Blocks":
      "The number of blocks from tables/indexes that were modified by the operation.\nThis\nincludes\nvalues for child operations and is a\ntotal\nvalue (i.e. not per-loop).\nInterestingly, a SELECT query can report shared dirtied blocks when setting hint bits on recently-committed rows, or pruning old row versions. While somewhat surprising, both of these are perfectly normal and healthy.",
    "Shared Written Blocks":
      "The number of blocks from tables/indexes that were evicted from the cache.\nThis\nincludes\nvalues for child operations and is a\ntotal\nvalue (i.e. not a per-loop average).",
    "Local Hit Blocks":
      "The number of blocks from temporary tables and indexes that were found in the cache.\nThis\nincludes\nvalues for child operations and is a\ntotal\nvalue (not a per-loop average).",
    "Local Read Blocks":
      "The number of blocks read from\ntemporary tables and indexes that were not found in the Postgres cache (read from disk or the OS cache).\nThis\nincludes\nvalues for child operations and is a\ntotal\nvalue (not a per-loop average).",
    "Local Dirtied Blocks":
      "The number of blocks from\ntemporary tables and indexes that have been modified by the operation.\nThis\nincludes\nvalues for child operations and is a\ntotal\nvalue (i.e. not a per-loop average).",
    "Local Written Blocks":
      "The number of blocks from\ntemporary tables and indexes that were evicted from the cache.\nThis\nincludes\nvalues for child operations and is a\ntotal\nvalue (i.e. not a per-loop average).",
    "Temp Read Blocks":
      "The number of blocks read from short-term data used to calculate hashes, sorts, Materialize operations, and similar.\nThis\nincludes\nvalues for child operations and is a\ntotal\nvalue (i.e. not a per-loop average).\nYour settings of\nwork_mem\nand\nhash_mem_multiplier\ndetermine how much memory is available to Postgres per operation.",
    "Temp Written Blocks":
      "The number of blocks from short-term data (used to calculate operations like hashes, sorts, and materializes) that were evicted from the cache.\nThis\nincludes\nvalues for child operations and is a\ntotal\nvalue (i.e. not a per-loop average).\nYour settings of\nwork_mem\nand\nhash_mem_multiplier\ndetermine how much memory is available to Postgres per operation.",
    "Shared I/O Read Time":
      "The time spent reading data from tables and indexes, in\nmilliseconds\n.\nThis\nincludes\nvalues for child operations and is a total value (not a per-loop average).\nRequires\ntrack_io_timing\nand\nBUFFERS\nto be on.\nIn the latest version, the text format of explain displays this as\nI/O Timings: shared read\nIn PostgreSQL 15 and 16 it shows as a combined metric\nI/O Timings: shared/local read\nGetting timing information has an overhead, due to checking the system clock. You can use\npg_test_timing\nto measure this for your system.",
    "Shared I/O Write Time":
      "The time spent writing data for tables and indexes, in\nmilliseconds\n.\nThis\nincludes\nvalues for child operations and is a total value (not a per-loop average).\nRequires\ntrack_io_timing\nand\nBUFFERS\nto be on.\nIn the latest version, the text format of explain displays this as\nI/O Timings: shared write\nIn PostgreSQL 15 and 16 it shows as a combined metric\nI/O Timings: shared/local write\nGetting timing information has an overhead, due to checking the system clock. You can use\npg_test_timing\nto measure this for your system.",
    "Local I/O Read Time":
      "The time spent reading local data (e.g. from temporary tables and indexes), in\nmilliseconds\n.\nThis\nincludes\nvalues for child operations and is a total value (i.e. not a per-loop average).\nThis was added as a separate field in PostgreSQL 17, and requires both\ntrack_io_timing\nand\nBUFFERS\n.\nIn the default text format, this will show as\nI/O Timings: local read\nIn versions 15 and 16 it is available as a combined metric as\nshared/local\nGetting timing information has an overhead, due to checking the system clock. You can use\npg_test_timing\nto measure this for your system.",
    "Local I/O Write Time":
      "The time spent writing local data (e.g. for temporary tables and indexes), in\nmilliseconds\n.\nThis\nincludes\nvalues for child operations and is a total value (i.e. not a per-loop average).\nThis was added as a separate field in PostgreSQL 17, and requires both\ntrack_io_timing\nand\nBUFFERS\n.\nIn the default text format, this will show as\nI/O Timings: local write\nIn versions 15 and 16 it is available as a combined metric as\nshared/local\nGetting timing information has an overhead, due to checking the system clock. You can use\npg_test_timing\nto measure this for your system.",
    "Temp I/O Read Time":
      "The time spent reading short-term data, in\nmilliseconds\n(for example during sort and hash operations that were not done in memory).\nThis\nincludes\nvalues for child operations and is a total value (i.e. not a per-loop average).\nThis was added in PostgreSQL 15, and requires both\ntrack_io_timing\nand\nBUFFERS\n.\nIn the text format of explain, this shows as\nI/O Timings: temp read\nGetting timing information has an overhead, due to checking the system clock. You can use\npg_test_timing\nto measure this for your system.",
    "Temp I/O Write Time":
      "The time spent writing short-term data, in\nmilliseconds\n(for example during sort and hash operations that were not done in memory).\nThis\nincludes\nvalues for child operations and is a total value (i.e. not a per-loop average).\nThis was added in PostgreSQL 15, and requires both\ntrack_io_timing\nand\nBUFFERS\n.\nIn the text format of explain, this shows as\nI/O Timings: temp write\nGetting timing information has an overhead, due to checking the system clock. You can use\npg_test_timing\nto measure this for your system.",
  },
  Memoize: {
    "Parent Relationship":
      "A guide as to why this operation needs to be run in order to facilitate the parent operation. There are six different possibilities:\nOuter\n: The value you’ll see most often. It means “take in the rows from this operation as input, process them and pass them on”.\nInner\n: Only ever seen on the second child of join operations, and is always seen there. This is the “inner” part of the loop — for each outer row, we look up its match using this operation.\nMember\n: Used for all children of Append and ModifyTable nodes, and on bitmap processing nodes like BitmapAnd and BitmapOr operations.\nInitPlan\n: Used for calculations performed before the query can start, eg a constant referred to in the query or the result of a CTE scan.\nSubquery\n: The child is a subquery of the parent operation. Since Postgres always uses subquery scans to feed subquery data to parent queries, only ever appears on the children of subquery scans.\nSubPlan\n: Like a Subquery, represents a new query, but used when a subquery scan is not necessary.",
    "Parallel Aware":
      "Whether or not the operation will be run in a special mode to support parallelism. Some operations need to be aware that they are running in parallel, for example sequential scans need to know they only need to scan a smaller proportion of the table. Other operations can be run on several threads without each one having any knowledge of the others.",
    "Startup Cost":
      "The estimated cost of returning the first row.\nThis is in an arbitrary unit, with the aim of being correlated to the startup time.",
    "Total Cost":
      "The estimated cost of returning all rows. This is in an arbitrary unit, with the aim of being correlated to the total time.\nThe Postgres query planner often has several ways it could resolve the same query. It calculates costs — which are hopefully correlated with the time it would take — for potential plans, and then picks the one with the lowest cost. It’s worth bearing in mind that the costs are unit-free — they’re not designed to convert into time, or disk reads. They’re just supposed to be bigger for slower operations, and smaller for faster ones.\nIf the planner thinks it can finish early due to a parent Limit operation, the total cost of the Limit operation will reflect this, but the total cost of its child operations will not.",
    "Plan Rows":
      "The number of rows,\nper-loop\n, that the planner expects to be returned by the operation.\nPoor row estimates can lead to suboptimal query planning. They can often be improved by running\nANALYZE\n(not the EXPLAIN parameter), by increasing statistics, or by allowing Postgres to understand correlation between columns using multivariate statistics.\nIf the planner thinks it can finish early due to a Limit operation, the plan rows of the Limit operation will reflect this, but the plan rows of its child operations will not.",
    "Plan Width":
      "The\nestimated\naverage size of the rows produced by the operation, in\nbytes\n.",
    "Actual Startup Time":
      "The amount of time, in\nmilliseconds\n, it takes to get the first row out of the operation.\nSometimes, this is very close to the setup time — for example on a sequential scan which returns all the rows in a table.\nOther times, though, it’s more or less the total time. For example, in order to return the first row of a sort, you have to sort all of the rows to work out which one comes first.",
    "Actual Total Time":
      "The actual amount of time in milliseconds spent on this operation\nand all of its children\n. It’s a\nper-loop average\n, rounded to the nearest thousandth of a millisecond.\nWorking out individual operation timings, especially where CTEs and SubPlans are concerned, can be tricky. This is one of the main reasons we decided to build\npgMustard\n.",
    "Actual Rows":
      "The number of rows returned by the operation\nper loop\n.\nThe important thing to notice about this is that it’s an average of all the loops executed, rounded to the nearest integer. This means that while “Actual Loops” multiplied by “Actual Rows” is a pretty good approximation for total number of rows returned most of the time, it can be off by as much as half of the number of loops. Usually it’s just slightly confusing as you see a row or two appear or disappear between operations, but on operations with lots of loops there is potential for serious miscalculation.\nPoor row estimates, where Actual Rows differs substantially from Plan Rows, can lead to suboptimal query planning. Estimates can often be improved by running\nANALYZE\n(not the EXPLAIN parameter), by increasing statistics, or by allowing Postgres to understand correlation between columns using multivariate statistics.",
    "Actual Loops":
      "The number of times the operation is executed. For a lot of operations it will have a value of one, but when it is not, there are three different cases:\nSome operations can be executed more than once. For example, “Nested Loops” run their “Inner” child once for every row returned by their “Outer” child.\nWhen an operation that would normally only consist of one loop is split across multiple threads, each partial operation is counted as a Loop.\nThe number of loops can be zero when an operation doesn’t need to be executed at all. For example if a table read is planned to provide candidates for an inner join, but there turns out to be no rows on the other side of the join, the operation can be effectively eliminated.",
    Output:
      "A list of the columns returned by the operation.\nThis is only shown when VERBOSE is on.",
    "Peak Memory Usage":
      "The peak memory used in a Hash, Hash Join, HashAggregate, or Memoize operation.\nIt is reported in\nKB\n.",
  },
  "Merge Append": {
    "Parent Relationship":
      "A guide as to why this operation needs to be run in order to facilitate the parent operation. There are six different possibilities:\nOuter\n: The value you’ll see most often. It means “take in the rows from this operation as input, process them and pass them on”.\nInner\n: Only ever seen on the second child of join operations, and is always seen there. This is the “inner” part of the loop — for each outer row, we look up its match using this operation.\nMember\n: Used for all children of Append and ModifyTable nodes, and on bitmap processing nodes like BitmapAnd and BitmapOr operations.\nInitPlan\n: Used for calculations performed before the query can start, eg a constant referred to in the query or the result of a CTE scan.\nSubquery\n: The child is a subquery of the parent operation. Since Postgres always uses subquery scans to feed subquery data to parent queries, only ever appears on the children of subquery scans.\nSubPlan\n: Like a Subquery, represents a new query, but used when a subquery scan is not necessary.",
    "Parallel Aware":
      "Whether or not the operation will be run in a special mode to support parallelism. Some operations need to be aware that they are running in parallel, for example sequential scans need to know they only need to scan a smaller proportion of the table. Other operations can be run on several threads without each one having any knowledge of the others.",
    "Startup Cost":
      "The estimated cost of returning the first row.\nThis is in an arbitrary unit, with the aim of being correlated to the startup time.",
    "Total Cost":
      "The estimated cost of returning all rows. This is in an arbitrary unit, with the aim of being correlated to the total time.\nThe Postgres query planner often has several ways it could resolve the same query. It calculates costs — which are hopefully correlated with the time it would take — for potential plans, and then picks the one with the lowest cost. It’s worth bearing in mind that the costs are unit-free — they’re not designed to convert into time, or disk reads. They’re just supposed to be bigger for slower operations, and smaller for faster ones.\nIf the planner thinks it can finish early due to a parent Limit operation, the total cost of the Limit operation will reflect this, but the total cost of its child operations will not.",
    "Plan Rows":
      "The number of rows,\nper-loop\n, that the planner expects to be returned by the operation.\nPoor row estimates can lead to suboptimal query planning. They can often be improved by running\nANALYZE\n(not the EXPLAIN parameter), by increasing statistics, or by allowing Postgres to understand correlation between columns using multivariate statistics.\nIf the planner thinks it can finish early due to a Limit operation, the plan rows of the Limit operation will reflect this, but the plan rows of its child operations will not.",
    "Plan Width":
      "The\nestimated\naverage size of the rows produced by the operation, in\nbytes\n.",
    "Actual Startup Time":
      "The amount of time, in\nmilliseconds\n, it takes to get the first row out of the operation.\nSometimes, this is very close to the setup time — for example on a sequential scan which returns all the rows in a table.\nOther times, though, it’s more or less the total time. For example, in order to return the first row of a sort, you have to sort all of the rows to work out which one comes first.",
    "Actual Total Time":
      "The actual amount of time in milliseconds spent on this operation\nand all of its children\n. It’s a\nper-loop average\n, rounded to the nearest thousandth of a millisecond.\nWorking out individual operation timings, especially where CTEs and SubPlans are concerned, can be tricky. This is one of the main reasons we decided to build\npgMustard\n.",
    "Actual Rows":
      "The number of rows returned by the operation\nper loop\n.\nThe important thing to notice about this is that it’s an average of all the loops executed, rounded to the nearest integer. This means that while “Actual Loops” multiplied by “Actual Rows” is a pretty good approximation for total number of rows returned most of the time, it can be off by as much as half of the number of loops. Usually it’s just slightly confusing as you see a row or two appear or disappear between operations, but on operations with lots of loops there is potential for serious miscalculation.\nPoor row estimates, where Actual Rows differs substantially from Plan Rows, can lead to suboptimal query planning. Estimates can often be improved by running\nANALYZE\n(not the EXPLAIN parameter), by increasing statistics, or by allowing Postgres to understand correlation between columns using multivariate statistics.",
    "Actual Loops":
      "The number of times the operation is executed. For a lot of operations it will have a value of one, but when it is not, there are three different cases:\nSome operations can be executed more than once. For example, “Nested Loops” run their “Inner” child once for every row returned by their “Outer” child.\nWhen an operation that would normally only consist of one loop is split across multiple threads, each partial operation is counted as a Loop.\nThe number of loops can be zero when an operation doesn’t need to be executed at all. For example if a table read is planned to provide candidates for an inner join, but there turns out to be no rows on the other side of the join, the operation can be effectively eliminated.",
    "Sort Key":
      "The order by condition.\nIf the sort is by a single column, or multiple columns from the same table, you may be able to avoid the sort entirely by adding an index with the desired order.",
    "Subplans Removed":
      "The number of subplans Postgres determines do not need to be examined for a partitioned table. This is also known as partition pruning.\nIf you see “never executed” it means all subplans were removed.",
    "Shared Hit Blocks":
      "The number of blocks from indexes/tables that were found in the Postgres buffer cache.\nThis\nincludes\nvalues for child operations and is a\ntotal\nvalue (i.e. not a per-loop average).\nOnce you have subtracted child operation values, the proportion of shared hit to shared read blocks is an interesting measure of cache performance.\nThe ratio of shared blocks (hit plus read) to rows processed (including any filtered out) is also interesting: a high ratio means Postgres is reading a lot of data for what it is doing, which can be a sign of bloat.",
    "Shared Read Blocks":
      "The number of blocks from tables/indexes that were read from disk (or the OS cache).\nThis\nincludes\nvalues for child operations and is a\ntotal\nvalue (i.e. not per-loop).\nOnce you have subtracted child operation values, the proportion of shared hit to shared read blocks is an interesting measure of cache performance.\nThe ratio of shared blocks (hit plus read) to rows processed (including any filtered out) is also interesting: a high ratio means Postgres is reading a lot of data for what it is doing, which can be a sign of bloat.",
    "Shared Dirtied Blocks":
      "The number of blocks from tables/indexes that were modified by the operation.\nThis\nincludes\nvalues for child operations and is a\ntotal\nvalue (i.e. not per-loop).\nInterestingly, a SELECT query can report shared dirtied blocks when setting hint bits on recently-committed rows, or pruning old row versions. While somewhat surprising, both of these are perfectly normal and healthy.",
    "Shared Written Blocks":
      "The number of blocks from tables/indexes that were evicted from the cache.\nThis\nincludes\nvalues for child operations and is a\ntotal\nvalue (i.e. not a per-loop average).",
    "Local Hit Blocks":
      "The number of blocks from temporary tables and indexes that were found in the cache.\nThis\nincludes\nvalues for child operations and is a\ntotal\nvalue (not a per-loop average).",
    "Local Read Blocks":
      "The number of blocks read from\ntemporary tables and indexes that were not found in the Postgres cache (read from disk or the OS cache).\nThis\nincludes\nvalues for child operations and is a\ntotal\nvalue (not a per-loop average).",
    "Local Dirtied Blocks":
      "The number of blocks from\ntemporary tables and indexes that have been modified by the operation.\nThis\nincludes\nvalues for child operations and is a\ntotal\nvalue (i.e. not a per-loop average).",
    "Local Written Blocks":
      "The number of blocks from\ntemporary tables and indexes that were evicted from the cache.\nThis\nincludes\nvalues for child operations and is a\ntotal\nvalue (i.e. not a per-loop average).",
    "Temp Read Blocks":
      "The number of blocks read from short-term data used to calculate hashes, sorts, Materialize operations, and similar.\nThis\nincludes\nvalues for child operations and is a\ntotal\nvalue (i.e. not a per-loop average).\nYour settings of\nwork_mem\nand\nhash_mem_multiplier\ndetermine how much memory is available to Postgres per operation.",
    "Temp Written Blocks":
      "The number of blocks from short-term data (used to calculate operations like hashes, sorts, and materializes) that were evicted from the cache.\nThis\nincludes\nvalues for child operations and is a\ntotal\nvalue (i.e. not a per-loop average).\nYour settings of\nwork_mem\nand\nhash_mem_multiplier\ndetermine how much memory is available to Postgres per operation.",
    "Shared I/O Read Time":
      "The time spent reading data from tables and indexes, in\nmilliseconds\n.\nThis\nincludes\nvalues for child operations and is a total value (not a per-loop average).\nRequires\ntrack_io_timing\nand\nBUFFERS\nto be on.\nIn the latest version, the text format of explain displays this as\nI/O Timings: shared read\nIn PostgreSQL 15 and 16 it shows as a combined metric\nI/O Timings: shared/local read\nGetting timing information has an overhead, due to checking the system clock. You can use\npg_test_timing\nto measure this for your system.",
    "Shared I/O Write Time":
      "The time spent writing data for tables and indexes, in\nmilliseconds\n.\nThis\nincludes\nvalues for child operations and is a total value (not a per-loop average).\nRequires\ntrack_io_timing\nand\nBUFFERS\nto be on.\nIn the latest version, the text format of explain displays this as\nI/O Timings: shared write\nIn PostgreSQL 15 and 16 it shows as a combined metric\nI/O Timings: shared/local write\nGetting timing information has an overhead, due to checking the system clock. You can use\npg_test_timing\nto measure this for your system.",
    "Local I/O Read Time":
      "The time spent reading local data (e.g. from temporary tables and indexes), in\nmilliseconds\n.\nThis\nincludes\nvalues for child operations and is a total value (i.e. not a per-loop average).\nThis was added as a separate field in PostgreSQL 17, and requires both\ntrack_io_timing\nand\nBUFFERS\n.\nIn the default text format, this will show as\nI/O Timings: local read\nIn versions 15 and 16 it is available as a combined metric as\nshared/local\nGetting timing information has an overhead, due to checking the system clock. You can use\npg_test_timing\nto measure this for your system.",
    "Local I/O Write Time":
      "The time spent writing local data (e.g. for temporary tables and indexes), in\nmilliseconds\n.\nThis\nincludes\nvalues for child operations and is a total value (i.e. not a per-loop average).\nThis was added as a separate field in PostgreSQL 17, and requires both\ntrack_io_timing\nand\nBUFFERS\n.\nIn the default text format, this will show as\nI/O Timings: local write\nIn versions 15 and 16 it is available as a combined metric as\nshared/local\nGetting timing information has an overhead, due to checking the system clock. You can use\npg_test_timing\nto measure this for your system.",
    "Temp I/O Read Time":
      "The time spent reading short-term data, in\nmilliseconds\n(for example during sort and hash operations that were not done in memory).\nThis\nincludes\nvalues for child operations and is a total value (i.e. not a per-loop average).\nThis was added in PostgreSQL 15, and requires both\ntrack_io_timing\nand\nBUFFERS\n.\nIn the text format of explain, this shows as\nI/O Timings: temp read\nGetting timing information has an overhead, due to checking the system clock. You can use\npg_test_timing\nto measure this for your system.",
    "Temp I/O Write Time":
      "The time spent writing short-term data, in\nmilliseconds\n(for example during sort and hash operations that were not done in memory).\nThis\nincludes\nvalues for child operations and is a total value (i.e. not a per-loop average).\nThis was added in PostgreSQL 15, and requires both\ntrack_io_timing\nand\nBUFFERS\n.\nIn the text format of explain, this shows as\nI/O Timings: temp write\nGetting timing information has an overhead, due to checking the system clock. You can use\npg_test_timing\nto measure this for your system.",
  },
  MixedAggregate: {
    Strategy:
      "Which strategy of aggregation was performed: Plain, Hashed, Sorted, or Mixed.\nIn non-text format query plans, this lets you see whether Postgres is doing a HashAggregate (Hashed), a GroupAggregate (Sorted), or a MixedAggregate (Mixed).",
    "Partial Mode":
      "If this is\nSimple\n, the operation happens in one step.\nOtherwise,\nPartial\noperations do chunks of the operation in parallel, and a separate\nFinalize\noperation joins the different parts together.\nFrom the docs: “Aggregate functions which support Partial Mode are eligible to participate in various optimizations, such as parallel aggregation.”\n[source]",
    "Parent Relationship":
      "A guide as to why this operation needs to be run in order to facilitate the parent operation. There are six different possibilities:\nOuter\n: The value you’ll see most often. It means “take in the rows from this operation as input, process them and pass them on”.\nInner\n: Only ever seen on the second child of join operations, and is always seen there. This is the “inner” part of the loop — for each outer row, we look up its match using this operation.\nMember\n: Used for all children of Append and ModifyTable nodes, and on bitmap processing nodes like BitmapAnd and BitmapOr operations.\nInitPlan\n: Used for calculations performed before the query can start, eg a constant referred to in the query or the result of a CTE scan.\nSubquery\n: The child is a subquery of the parent operation. Since Postgres always uses subquery scans to feed subquery data to parent queries, only ever appears on the children of subquery scans.\nSubPlan\n: Like a Subquery, represents a new query, but used when a subquery scan is not necessary.",
    "Parallel Aware":
      "Whether or not the operation will be run in a special mode to support parallelism. Some operations need to be aware that they are running in parallel, for example sequential scans need to know they only need to scan a smaller proportion of the table. Other operations can be run on several threads without each one having any knowledge of the others.",
    "Startup Cost":
      "The estimated cost of returning the first row.\nThis is in an arbitrary unit, with the aim of being correlated to the startup time.",
    "Total Cost":
      "The estimated cost of returning all rows. This is in an arbitrary unit, with the aim of being correlated to the total time.\nThe Postgres query planner often has several ways it could resolve the same query. It calculates costs — which are hopefully correlated with the time it would take — for potential plans, and then picks the one with the lowest cost. It’s worth bearing in mind that the costs are unit-free — they’re not designed to convert into time, or disk reads. They’re just supposed to be bigger for slower operations, and smaller for faster ones.\nIf the planner thinks it can finish early due to a parent Limit operation, the total cost of the Limit operation will reflect this, but the total cost of its child operations will not.",
    "Plan Rows":
      "The number of rows,\nper-loop\n, that the planner expects to be returned by the operation.\nPoor row estimates can lead to suboptimal query planning. They can often be improved by running\nANALYZE\n(not the EXPLAIN parameter), by increasing statistics, or by allowing Postgres to understand correlation between columns using multivariate statistics.\nIf the planner thinks it can finish early due to a Limit operation, the plan rows of the Limit operation will reflect this, but the plan rows of its child operations will not.",
    "Plan Width":
      "The\nestimated\naverage size of the rows produced by the operation, in\nbytes\n.",
    "Actual Startup Time":
      "The amount of time, in\nmilliseconds\n, it takes to get the first row out of the operation.\nSometimes, this is very close to the setup time — for example on a sequential scan which returns all the rows in a table.\nOther times, though, it’s more or less the total time. For example, in order to return the first row of a sort, you have to sort all of the rows to work out which one comes first.",
    "Actual Total Time":
      "The actual amount of time in milliseconds spent on this operation\nand all of its children\n. It’s a\nper-loop average\n, rounded to the nearest thousandth of a millisecond.\nWorking out individual operation timings, especially where CTEs and SubPlans are concerned, can be tricky. This is one of the main reasons we decided to build\npgMustard\n.",
    "Actual Rows":
      "The number of rows returned by the operation\nper loop\n.\nThe important thing to notice about this is that it’s an average of all the loops executed, rounded to the nearest integer. This means that while “Actual Loops” multiplied by “Actual Rows” is a pretty good approximation for total number of rows returned most of the time, it can be off by as much as half of the number of loops. Usually it’s just slightly confusing as you see a row or two appear or disappear between operations, but on operations with lots of loops there is potential for serious miscalculation.\nPoor row estimates, where Actual Rows differs substantially from Plan Rows, can lead to suboptimal query planning. Estimates can often be improved by running\nANALYZE\n(not the EXPLAIN parameter), by increasing statistics, or by allowing Postgres to understand correlation between columns using multivariate statistics.",
    "Actual Loops":
      "The number of times the operation is executed. For a lot of operations it will have a value of one, but when it is not, there are three different cases:\nSome operations can be executed more than once. For example, “Nested Loops” run their “Inner” child once for every row returned by their “Outer” child.\nWhen an operation that would normally only consist of one loop is split across multiple threads, each partial operation is counted as a Loop.\nThe number of loops can be zero when an operation doesn’t need to be executed at all. For example if a table read is planned to provide candidates for an inner join, but there turns out to be no rows on the other side of the join, the operation can be effectively eliminated.",
    Output:
      "A list of the columns returned by the operation.\nThis is only shown when VERBOSE is on.",
    "Shared Hit Blocks":
      "The number of blocks from indexes/tables that were found in the Postgres buffer cache.\nThis\nincludes\nvalues for child operations and is a\ntotal\nvalue (i.e. not a per-loop average).\nOnce you have subtracted child operation values, the proportion of shared hit to shared read blocks is an interesting measure of cache performance.\nThe ratio of shared blocks (hit plus read) to rows processed (including any filtered out) is also interesting: a high ratio means Postgres is reading a lot of data for what it is doing, which can be a sign of bloat.",
    "Shared Read Blocks":
      "The number of blocks from tables/indexes that were read from disk (or the OS cache).\nThis\nincludes\nvalues for child operations and is a\ntotal\nvalue (i.e. not per-loop).\nOnce you have subtracted child operation values, the proportion of shared hit to shared read blocks is an interesting measure of cache performance.\nThe ratio of shared blocks (hit plus read) to rows processed (including any filtered out) is also interesting: a high ratio means Postgres is reading a lot of data for what it is doing, which can be a sign of bloat.",
    "Shared Dirtied Blocks":
      "The number of blocks from tables/indexes that were modified by the operation.\nThis\nincludes\nvalues for child operations and is a\ntotal\nvalue (i.e. not per-loop).\nInterestingly, a SELECT query can report shared dirtied blocks when setting hint bits on recently-committed rows, or pruning old row versions. While somewhat surprising, both of these are perfectly normal and healthy.",
    "Shared Written Blocks":
      "The number of blocks from tables/indexes that were evicted from the cache.\nThis\nincludes\nvalues for child operations and is a\ntotal\nvalue (i.e. not a per-loop average).",
    "Local Hit Blocks":
      "The number of blocks from temporary tables and indexes that were found in the cache.\nThis\nincludes\nvalues for child operations and is a\ntotal\nvalue (not a per-loop average).",
    "Local Read Blocks":
      "The number of blocks read from\ntemporary tables and indexes that were not found in the Postgres cache (read from disk or the OS cache).\nThis\nincludes\nvalues for child operations and is a\ntotal\nvalue (not a per-loop average).",
    "Local Dirtied Blocks":
      "The number of blocks from\ntemporary tables and indexes that have been modified by the operation.\nThis\nincludes\nvalues for child operations and is a\ntotal\nvalue (i.e. not a per-loop average).",
    "Local Written Blocks":
      "The number of blocks from\ntemporary tables and indexes that were evicted from the cache.\nThis\nincludes\nvalues for child operations and is a\ntotal\nvalue (i.e. not a per-loop average).",
    "Temp Read Blocks":
      "The number of blocks read from short-term data used to calculate hashes, sorts, Materialize operations, and similar.\nThis\nincludes\nvalues for child operations and is a\ntotal\nvalue (i.e. not a per-loop average).\nYour settings of\nwork_mem\nand\nhash_mem_multiplier\ndetermine how much memory is available to Postgres per operation.",
    "Temp Written Blocks":
      "The number of blocks from short-term data (used to calculate operations like hashes, sorts, and materializes) that were evicted from the cache.\nThis\nincludes\nvalues for child operations and is a\ntotal\nvalue (i.e. not a per-loop average).\nYour settings of\nwork_mem\nand\nhash_mem_multiplier\ndetermine how much memory is available to Postgres per operation.",
    "Shared I/O Read Time":
      "The time spent reading data from tables and indexes, in\nmilliseconds\n.\nThis\nincludes\nvalues for child operations and is a total value (not a per-loop average).\nRequires\ntrack_io_timing\nand\nBUFFERS\nto be on.\nIn the latest version, the text format of explain displays this as\nI/O Timings: shared read\nIn PostgreSQL 15 and 16 it shows as a combined metric\nI/O Timings: shared/local read\nGetting timing information has an overhead, due to checking the system clock. You can use\npg_test_timing\nto measure this for your system.",
    "Shared I/O Write Time":
      "The time spent writing data for tables and indexes, in\nmilliseconds\n.\nThis\nincludes\nvalues for child operations and is a total value (not a per-loop average).\nRequires\ntrack_io_timing\nand\nBUFFERS\nto be on.\nIn the latest version, the text format of explain displays this as\nI/O Timings: shared write\nIn PostgreSQL 15 and 16 it shows as a combined metric\nI/O Timings: shared/local write\nGetting timing information has an overhead, due to checking the system clock. You can use\npg_test_timing\nto measure this for your system.",
    "Local I/O Read Time":
      "The time spent reading local data (e.g. from temporary tables and indexes), in\nmilliseconds\n.\nThis\nincludes\nvalues for child operations and is a total value (i.e. not a per-loop average).\nThis was added as a separate field in PostgreSQL 17, and requires both\ntrack_io_timing\nand\nBUFFERS\n.\nIn the default text format, this will show as\nI/O Timings: local read\nIn versions 15 and 16 it is available as a combined metric as\nshared/local\nGetting timing information has an overhead, due to checking the system clock. You can use\npg_test_timing\nto measure this for your system.",
    "Local I/O Write Time":
      "The time spent writing local data (e.g. for temporary tables and indexes), in\nmilliseconds\n.\nThis\nincludes\nvalues for child operations and is a total value (i.e. not a per-loop average).\nThis was added as a separate field in PostgreSQL 17, and requires both\ntrack_io_timing\nand\nBUFFERS\n.\nIn the default text format, this will show as\nI/O Timings: local write\nIn versions 15 and 16 it is available as a combined metric as\nshared/local\nGetting timing information has an overhead, due to checking the system clock. You can use\npg_test_timing\nto measure this for your system.",
    "Temp I/O Read Time":
      "The time spent reading short-term data, in\nmilliseconds\n(for example during sort and hash operations that were not done in memory).\nThis\nincludes\nvalues for child operations and is a total value (i.e. not a per-loop average).\nThis was added in PostgreSQL 15, and requires both\ntrack_io_timing\nand\nBUFFERS\n.\nIn the text format of explain, this shows as\nI/O Timings: temp read\nGetting timing information has an overhead, due to checking the system clock. You can use\npg_test_timing\nto measure this for your system.",
    "Temp I/O Write Time":
      "The time spent writing short-term data, in\nmilliseconds\n(for example during sort and hash operations that were not done in memory).\nThis\nincludes\nvalues for child operations and is a total value (i.e. not a per-loop average).\nThis was added in PostgreSQL 15, and requires both\ntrack_io_timing\nand\nBUFFERS\n.\nIn the text format of explain, this shows as\nI/O Timings: temp write\nGetting timing information has an overhead, due to checking the system clock. You can use\npg_test_timing\nto measure this for your system.",
    Workers:
      "A summary of the operation detail broken down by thread.\nThese entries\ndon’t\ninclude the main (or leader) thread.\nYou can work out the values for the main thread by subtracting the worker statistics from the total.\nThis information is only shown when VERBOSE is on.",
  },
  ModifyTable: {
    Operation:
      "The operation on the table — SELECT, INSERT, UPDATE, DELETE, or MERGE.",
    "Parallel Aware":
      "Whether or not the operation will be run in a special mode to support parallelism. Some operations need to be aware that they are running in parallel, for example sequential scans need to know they only need to scan a smaller proportion of the table. Other operations can be run on several threads without each one having any knowledge of the others.",
    "Relation Name":
      "The data source being read/written from. Normally a table name (including when the data is accessed via an index), but can also be a materialised view or foreign data source.",
    Schema:
      "The schema of the “Relation Name” object.\nThis is only shown when VERBOSE is on.",
    Alias: "The alias used to refer to the Relation Name object.",
    "Startup Cost":
      "The estimated cost of returning the first row.\nThis is in an arbitrary unit, with the aim of being correlated to the startup time.",
    "Total Cost":
      "The estimated cost of returning all rows. This is in an arbitrary unit, with the aim of being correlated to the total time.\nThe Postgres query planner often has several ways it could resolve the same query. It calculates costs — which are hopefully correlated with the time it would take — for potential plans, and then picks the one with the lowest cost. It’s worth bearing in mind that the costs are unit-free — they’re not designed to convert into time, or disk reads. They’re just supposed to be bigger for slower operations, and smaller for faster ones.\nIf the planner thinks it can finish early due to a parent Limit operation, the total cost of the Limit operation will reflect this, but the total cost of its child operations will not.",
    "Plan Rows":
      "The number of rows,\nper-loop\n, that the planner expects to be returned by the operation.\nPoor row estimates can lead to suboptimal query planning. They can often be improved by running\nANALYZE\n(not the EXPLAIN parameter), by increasing statistics, or by allowing Postgres to understand correlation between columns using multivariate statistics.\nIf the planner thinks it can finish early due to a Limit operation, the plan rows of the Limit operation will reflect this, but the plan rows of its child operations will not.",
    "Plan Width":
      "The\nestimated\naverage size of the rows produced by the operation, in\nbytes\n.",
    "Actual Startup Time":
      "The amount of time, in\nmilliseconds\n, it takes to get the first row out of the operation.\nSometimes, this is very close to the setup time — for example on a sequential scan which returns all the rows in a table.\nOther times, though, it’s more or less the total time. For example, in order to return the first row of a sort, you have to sort all of the rows to work out which one comes first.",
    "Actual Total Time":
      "The actual amount of time in milliseconds spent on this operation\nand all of its children\n. It’s a\nper-loop average\n, rounded to the nearest thousandth of a millisecond.\nWorking out individual operation timings, especially where CTEs and SubPlans are concerned, can be tricky. This is one of the main reasons we decided to build\npgMustard\n.",
    "Actual Rows":
      "The number of rows returned by the operation\nper loop\n.\nThe important thing to notice about this is that it’s an average of all the loops executed, rounded to the nearest integer. This means that while “Actual Loops” multiplied by “Actual Rows” is a pretty good approximation for total number of rows returned most of the time, it can be off by as much as half of the number of loops. Usually it’s just slightly confusing as you see a row or two appear or disappear between operations, but on operations with lots of loops there is potential for serious miscalculation.\nPoor row estimates, where Actual Rows differs substantially from Plan Rows, can lead to suboptimal query planning. Estimates can often be improved by running\nANALYZE\n(not the EXPLAIN parameter), by increasing statistics, or by allowing Postgres to understand correlation between columns using multivariate statistics.",
    "Actual Loops":
      "The number of times the operation is executed. For a lot of operations it will have a value of one, but when it is not, there are three different cases:\nSome operations can be executed more than once. For example, “Nested Loops” run their “Inner” child once for every row returned by their “Outer” child.\nWhen an operation that would normally only consist of one loop is split across multiple threads, each partial operation is counted as a Loop.\nThe number of loops can be zero when an operation doesn’t need to be executed at all. For example if a table read is planned to provide candidates for an inner join, but there turns out to be no rows on the other side of the join, the operation can be effectively eliminated.",
    "Shared Hit Blocks":
      "The number of blocks from indexes/tables that were found in the Postgres buffer cache.\nThis\nincludes\nvalues for child operations and is a\ntotal\nvalue (i.e. not a per-loop average).\nOnce you have subtracted child operation values, the proportion of shared hit to shared read blocks is an interesting measure of cache performance.\nThe ratio of shared blocks (hit plus read) to rows processed (including any filtered out) is also interesting: a high ratio means Postgres is reading a lot of data for what it is doing, which can be a sign of bloat.",
    "Shared Read Blocks":
      "The number of blocks from tables/indexes that were read from disk (or the OS cache).\nThis\nincludes\nvalues for child operations and is a\ntotal\nvalue (i.e. not per-loop).\nOnce you have subtracted child operation values, the proportion of shared hit to shared read blocks is an interesting measure of cache performance.\nThe ratio of shared blocks (hit plus read) to rows processed (including any filtered out) is also interesting: a high ratio means Postgres is reading a lot of data for what it is doing, which can be a sign of bloat.",
    "Shared Dirtied Blocks":
      "The number of blocks from tables/indexes that were modified by the operation.\nThis\nincludes\nvalues for child operations and is a\ntotal\nvalue (i.e. not per-loop).\nInterestingly, a SELECT query can report shared dirtied blocks when setting hint bits on recently-committed rows, or pruning old row versions. While somewhat surprising, both of these are perfectly normal and healthy.",
    "Shared Written Blocks":
      "The number of blocks from tables/indexes that were evicted from the cache.\nThis\nincludes\nvalues for child operations and is a\ntotal\nvalue (i.e. not a per-loop average).",
    "Local Hit Blocks":
      "The number of blocks from temporary tables and indexes that were found in the cache.\nThis\nincludes\nvalues for child operations and is a\ntotal\nvalue (not a per-loop average).",
    "Local Read Blocks":
      "The number of blocks read from\ntemporary tables and indexes that were not found in the Postgres cache (read from disk or the OS cache).\nThis\nincludes\nvalues for child operations and is a\ntotal\nvalue (not a per-loop average).",
    "Local Dirtied Blocks":
      "The number of blocks from\ntemporary tables and indexes that have been modified by the operation.\nThis\nincludes\nvalues for child operations and is a\ntotal\nvalue (i.e. not a per-loop average).",
    "Local Written Blocks":
      "The number of blocks from\ntemporary tables and indexes that were evicted from the cache.\nThis\nincludes\nvalues for child operations and is a\ntotal\nvalue (i.e. not a per-loop average).",
    "Temp Read Blocks":
      "The number of blocks read from short-term data used to calculate hashes, sorts, Materialize operations, and similar.\nThis\nincludes\nvalues for child operations and is a\ntotal\nvalue (i.e. not a per-loop average).\nYour settings of\nwork_mem\nand\nhash_mem_multiplier\ndetermine how much memory is available to Postgres per operation.",
    "Temp Written Blocks":
      "The number of blocks from short-term data (used to calculate operations like hashes, sorts, and materializes) that were evicted from the cache.\nThis\nincludes\nvalues for child operations and is a\ntotal\nvalue (i.e. not a per-loop average).\nYour settings of\nwork_mem\nand\nhash_mem_multiplier\ndetermine how much memory is available to Postgres per operation.",
    "Shared I/O Read Time":
      "The time spent reading data from tables and indexes, in\nmilliseconds\n.\nThis\nincludes\nvalues for child operations and is a total value (not a per-loop average).\nRequires\ntrack_io_timing\nand\nBUFFERS\nto be on.\nIn the latest version, the text format of explain displays this as\nI/O Timings: shared read\nIn PostgreSQL 15 and 16 it shows as a combined metric\nI/O Timings: shared/local read\nGetting timing information has an overhead, due to checking the system clock. You can use\npg_test_timing\nto measure this for your system.",
    "Shared I/O Write Time":
      "The time spent writing data for tables and indexes, in\nmilliseconds\n.\nThis\nincludes\nvalues for child operations and is a total value (not a per-loop average).\nRequires\ntrack_io_timing\nand\nBUFFERS\nto be on.\nIn the latest version, the text format of explain displays this as\nI/O Timings: shared write\nIn PostgreSQL 15 and 16 it shows as a combined metric\nI/O Timings: shared/local write\nGetting timing information has an overhead, due to checking the system clock. You can use\npg_test_timing\nto measure this for your system.",
    "Local I/O Read Time":
      "The time spent reading local data (e.g. from temporary tables and indexes), in\nmilliseconds\n.\nThis\nincludes\nvalues for child operations and is a total value (i.e. not a per-loop average).\nThis was added as a separate field in PostgreSQL 17, and requires both\ntrack_io_timing\nand\nBUFFERS\n.\nIn the default text format, this will show as\nI/O Timings: local read\nIn versions 15 and 16 it is available as a combined metric as\nshared/local\nGetting timing information has an overhead, due to checking the system clock. You can use\npg_test_timing\nto measure this for your system.",
    "Local I/O Write Time":
      "The time spent writing local data (e.g. for temporary tables and indexes), in\nmilliseconds\n.\nThis\nincludes\nvalues for child operations and is a total value (i.e. not a per-loop average).\nThis was added as a separate field in PostgreSQL 17, and requires both\ntrack_io_timing\nand\nBUFFERS\n.\nIn the default text format, this will show as\nI/O Timings: local write\nIn versions 15 and 16 it is available as a combined metric as\nshared/local\nGetting timing information has an overhead, due to checking the system clock. You can use\npg_test_timing\nto measure this for your system.",
    "Temp I/O Read Time":
      "The time spent reading short-term data, in\nmilliseconds\n(for example during sort and hash operations that were not done in memory).\nThis\nincludes\nvalues for child operations and is a total value (i.e. not a per-loop average).\nThis was added in PostgreSQL 15, and requires both\ntrack_io_timing\nand\nBUFFERS\n.\nIn the text format of explain, this shows as\nI/O Timings: temp read\nGetting timing information has an overhead, due to checking the system clock. You can use\npg_test_timing\nto measure this for your system.",
    "Temp I/O Write Time":
      "The time spent writing short-term data, in\nmilliseconds\n(for example during sort and hash operations that were not done in memory).\nThis\nincludes\nvalues for child operations and is a total value (i.e. not a per-loop average).\nThis was added in PostgreSQL 15, and requires both\ntrack_io_timing\nand\nBUFFERS\n.\nIn the text format of explain, this shows as\nI/O Timings: temp write\nGetting timing information has an overhead, due to checking the system clock. You can use\npg_test_timing\nto measure this for your system.",
    "WAL Records":
      "The number of WAL (Write-Ahead Logging) records generated by the operation.",
    "WAL Bytes":
      "The amount of WAL (Write Ahead Logging) data generated by the operation.",
    "WAL FPI":
      "The number of WAL (Write Ahead Logging)\nfull page images\ngenerated by the operation.\nIn other places, including pre-release versions of PostgreSQL 13, you may see these referred to as\nfull page writes\n.",
    "Trigger information":
      "Displays which triggers were called, the number of calls for each, and the time taken.\nThe time is a\ntotal\n(across all calls) and is in\nmilliseconds\n.\nThe time is\nincluded\nin the total query execution time, and sometimes (for BEFORE triggers) in the Actual Total Time of the operation which causes the trigger to be fired.\nVery slow deletes in PostgreSQL are often a result of internal referential integrity (RI) triggers used for foreign keys that have not been indexed.\nYou can use the\nVERBOSE parameter\nto see trigger names.",
  },
  "Parallel Bitmap Heap Scan": {
    "Parent Relationship":
      "A guide as to why this operation needs to be run in order to facilitate the parent operation. There are six different possibilities:\nOuter\n: The value you’ll see most often. It means “take in the rows from this operation as input, process them and pass them on”.\nInner\n: Only ever seen on the second child of join operations, and is always seen there. This is the “inner” part of the loop — for each outer row, we look up its match using this operation.\nMember\n: Used for all children of Append and ModifyTable nodes, and on bitmap processing nodes like BitmapAnd and BitmapOr operations.\nInitPlan\n: Used for calculations performed before the query can start, eg a constant referred to in the query or the result of a CTE scan.\nSubquery\n: The child is a subquery of the parent operation. Since Postgres always uses subquery scans to feed subquery data to parent queries, only ever appears on the children of subquery scans.\nSubPlan\n: Like a Subquery, represents a new query, but used when a subquery scan is not necessary.",
    "Parallel Aware":
      "Whether or not the operation will be run in a special mode to support parallelism. Some operations need to be aware that they are running in parallel, for example sequential scans need to know they only need to scan a smaller proportion of the table. Other operations can be run on several threads without each one having any knowledge of the others.",
    "Relation Name":
      "The data source being read/written from. Normally a table name (including when the data is accessed via an index), but can also be a materialised view or foreign data source.",
    Schema:
      "The schema of the “Relation Name” object.\nThis is only shown when VERBOSE is on.",
    Alias: "The alias used to refer to the Relation Name object.",
    "Startup Cost":
      "The estimated cost of returning the first row.\nThis is in an arbitrary unit, with the aim of being correlated to the startup time.",
    "Total Cost":
      "The estimated cost of returning all rows. This is in an arbitrary unit, with the aim of being correlated to the total time.\nThe Postgres query planner often has several ways it could resolve the same query. It calculates costs — which are hopefully correlated with the time it would take — for potential plans, and then picks the one with the lowest cost. It’s worth bearing in mind that the costs are unit-free — they’re not designed to convert into time, or disk reads. They’re just supposed to be bigger for slower operations, and smaller for faster ones.\nIf the planner thinks it can finish early due to a parent Limit operation, the total cost of the Limit operation will reflect this, but the total cost of its child operations will not.",
    "Plan Rows":
      "The number of rows,\nper-loop\n, that the planner expects to be returned by the operation.\nPoor row estimates can lead to suboptimal query planning. They can often be improved by running\nANALYZE\n(not the EXPLAIN parameter), by increasing statistics, or by allowing Postgres to understand correlation between columns using multivariate statistics.\nIf the planner thinks it can finish early due to a Limit operation, the plan rows of the Limit operation will reflect this, but the plan rows of its child operations will not.",
    "Plan Width":
      "The\nestimated\naverage size of the rows produced by the operation, in\nbytes\n.",
    "Actual Startup Time":
      "The amount of time, in\nmilliseconds\n, it takes to get the first row out of the operation.\nSometimes, this is very close to the setup time — for example on a sequential scan which returns all the rows in a table.\nOther times, though, it’s more or less the total time. For example, in order to return the first row of a sort, you have to sort all of the rows to work out which one comes first.",
    "Actual Total Time":
      "The actual amount of time in milliseconds spent on this operation\nand all of its children\n. It’s a\nper-loop average\n, rounded to the nearest thousandth of a millisecond.\nWorking out individual operation timings, especially where CTEs and SubPlans are concerned, can be tricky. This is one of the main reasons we decided to build\npgMustard\n.",
    "Actual Rows":
      "The number of rows returned by the operation\nper loop\n.\nThe important thing to notice about this is that it’s an average of all the loops executed, rounded to the nearest integer. This means that while “Actual Loops” multiplied by “Actual Rows” is a pretty good approximation for total number of rows returned most of the time, it can be off by as much as half of the number of loops. Usually it’s just slightly confusing as you see a row or two appear or disappear between operations, but on operations with lots of loops there is potential for serious miscalculation.\nPoor row estimates, where Actual Rows differs substantially from Plan Rows, can lead to suboptimal query planning. Estimates can often be improved by running\nANALYZE\n(not the EXPLAIN parameter), by increasing statistics, or by allowing Postgres to understand correlation between columns using multivariate statistics.",
    "Actual Loops":
      "The number of times the operation is executed. For a lot of operations it will have a value of one, but when it is not, there are three different cases:\nSome operations can be executed more than once. For example, “Nested Loops” run their “Inner” child once for every row returned by their “Outer” child.\nWhen an operation that would normally only consist of one loop is split across multiple threads, each partial operation is counted as a Loop.\nThe number of loops can be zero when an operation doesn’t need to be executed at all. For example if a table read is planned to provide candidates for an inner join, but there turns out to be no rows on the other side of the join, the operation can be effectively eliminated.",
    Output:
      "A list of the columns returned by the operation.\nThis is only shown when VERBOSE is on.",
    "Recheck Cond":
      "The Recheck Cond is the condition a bitmap scan\nmight\nuse to filter rows out after fetching them.\nIt is only needed if the bitmap scan is lossy, or if it has used any lossy index types that do not guarantee that rows match the condition (e.g. a BRIN index).\nFor more info on whether a recheck was actually needed, look out for non-zero\nLossy Heap Blocks\nand non-zero\nRows Removed by Index Recheck\n.",
    "Rows Removed by Index Recheck":
      "The number of rows returned by the index scan that do not meet the condition and are subsequently removed.\nThis will either be the result of a lossy bitmap scan, or an index type that doesn't guarantee that a row matches the condition.",
    Filter:
      "When present, this is a filter used to remove rows.\nThe important thing to note is that this is a filter in the traditional sense: these rows are read in (either from a data source or another operation in the plan), inspected, and then approved or removed based on the filter.\nIf a high proportion of rows are being removed by the Filter, you may want to investigate whether a (more) selective index could help.\nIf you notice a lot of rows being filtered late in a query plan, this might be due to an operation (like a GROUP BY or SORT) using more columns than are necessary, requiring joins to take place before rows can be discarded. It is also sometimes a result of unnecessary or ill-advised uses of DISTINCT.",
    "Rows Removed by Filter":
      "The number of rows removed by the\nFilter\n. This is a\nper-loop average\n, rounded to the nearest integer.\nIf a high proportion of rows are being removed, you may want to investigate whether a (more) selective index could help.",
    "Exact Heap Blocks":
      'The number of\nnon\n-lossy blocks a bitmap heap scan visited.\nIf a row bitmap is too big to fit into working memory (\nwork_mem\n), some parts of it are made "lossy" – i.e. they refer to whole pages rather than specific rows.\nIf you see only Exact heap blocks, then your bitmap scan was not lossy.',
    "Lossy Heap Blocks":
      'The number of lossy blocks a bitmap heap scan visited.\nIf a row bitmap is too big to fit into working memory (\nwork_mem\n), some parts of it are made "lossy" – i.e. they refer to whole pages rather than specific rows.',
    "Shared Hit Blocks":
      "The number of blocks from indexes/tables that were found in the Postgres buffer cache.\nThis\nincludes\nvalues for child operations and is a\ntotal\nvalue (i.e. not a per-loop average).\nOnce you have subtracted child operation values, the proportion of shared hit to shared read blocks is an interesting measure of cache performance.\nThe ratio of shared blocks (hit plus read) to rows processed (including any filtered out) is also interesting: a high ratio means Postgres is reading a lot of data for what it is doing, which can be a sign of bloat.",
    "Shared Read Blocks":
      "The number of blocks from tables/indexes that were read from disk (or the OS cache).\nThis\nincludes\nvalues for child operations and is a\ntotal\nvalue (i.e. not per-loop).\nOnce you have subtracted child operation values, the proportion of shared hit to shared read blocks is an interesting measure of cache performance.\nThe ratio of shared blocks (hit plus read) to rows processed (including any filtered out) is also interesting: a high ratio means Postgres is reading a lot of data for what it is doing, which can be a sign of bloat.",
    "Shared Dirtied Blocks":
      "The number of blocks from tables/indexes that were modified by the operation.\nThis\nincludes\nvalues for child operations and is a\ntotal\nvalue (i.e. not per-loop).\nInterestingly, a SELECT query can report shared dirtied blocks when setting hint bits on recently-committed rows, or pruning old row versions. While somewhat surprising, both of these are perfectly normal and healthy.",
    "Shared Written Blocks":
      "The number of blocks from tables/indexes that were evicted from the cache.\nThis\nincludes\nvalues for child operations and is a\ntotal\nvalue (i.e. not a per-loop average).",
    "Local Hit Blocks":
      "The number of blocks from temporary tables and indexes that were found in the cache.\nThis\nincludes\nvalues for child operations and is a\ntotal\nvalue (not a per-loop average).",
    "Local Read Blocks":
      "The number of blocks read from\ntemporary tables and indexes that were not found in the Postgres cache (read from disk or the OS cache).\nThis\nincludes\nvalues for child operations and is a\ntotal\nvalue (not a per-loop average).",
    "Local Dirtied Blocks":
      "The number of blocks from\ntemporary tables and indexes that have been modified by the operation.\nThis\nincludes\nvalues for child operations and is a\ntotal\nvalue (i.e. not a per-loop average).",
    "Local Written Blocks":
      "The number of blocks from\ntemporary tables and indexes that were evicted from the cache.\nThis\nincludes\nvalues for child operations and is a\ntotal\nvalue (i.e. not a per-loop average).",
    "Temp Read Blocks":
      "The number of blocks read from short-term data used to calculate hashes, sorts, Materialize operations, and similar.\nThis\nincludes\nvalues for child operations and is a\ntotal\nvalue (i.e. not a per-loop average).\nYour settings of\nwork_mem\nand\nhash_mem_multiplier\ndetermine how much memory is available to Postgres per operation.",
    "Temp Written Blocks":
      "The number of blocks from short-term data (used to calculate operations like hashes, sorts, and materializes) that were evicted from the cache.\nThis\nincludes\nvalues for child operations and is a\ntotal\nvalue (i.e. not a per-loop average).\nYour settings of\nwork_mem\nand\nhash_mem_multiplier\ndetermine how much memory is available to Postgres per operation.",
    "Shared I/O Read Time":
      "The time spent reading data from tables and indexes, in\nmilliseconds\n.\nThis\nincludes\nvalues for child operations and is a total value (not a per-loop average).\nRequires\ntrack_io_timing\nand\nBUFFERS\nto be on.\nIn the latest version, the text format of explain displays this as\nI/O Timings: shared read\nIn PostgreSQL 15 and 16 it shows as a combined metric\nI/O Timings: shared/local read\nGetting timing information has an overhead, due to checking the system clock. You can use\npg_test_timing\nto measure this for your system.",
    "Shared I/O Write Time":
      "The time spent writing data for tables and indexes, in\nmilliseconds\n.\nThis\nincludes\nvalues for child operations and is a total value (not a per-loop average).\nRequires\ntrack_io_timing\nand\nBUFFERS\nto be on.\nIn the latest version, the text format of explain displays this as\nI/O Timings: shared write\nIn PostgreSQL 15 and 16 it shows as a combined metric\nI/O Timings: shared/local write\nGetting timing information has an overhead, due to checking the system clock. You can use\npg_test_timing\nto measure this for your system.",
    "Local I/O Read Time":
      "The time spent reading local data (e.g. from temporary tables and indexes), in\nmilliseconds\n.\nThis\nincludes\nvalues for child operations and is a total value (i.e. not a per-loop average).\nThis was added as a separate field in PostgreSQL 17, and requires both\ntrack_io_timing\nand\nBUFFERS\n.\nIn the default text format, this will show as\nI/O Timings: local read\nIn versions 15 and 16 it is available as a combined metric as\nshared/local\nGetting timing information has an overhead, due to checking the system clock. You can use\npg_test_timing\nto measure this for your system.",
    "Local I/O Write Time":
      "The time spent writing local data (e.g. for temporary tables and indexes), in\nmilliseconds\n.\nThis\nincludes\nvalues for child operations and is a total value (i.e. not a per-loop average).\nThis was added as a separate field in PostgreSQL 17, and requires both\ntrack_io_timing\nand\nBUFFERS\n.\nIn the default text format, this will show as\nI/O Timings: local write\nIn versions 15 and 16 it is available as a combined metric as\nshared/local\nGetting timing information has an overhead, due to checking the system clock. You can use\npg_test_timing\nto measure this for your system.",
    "Temp I/O Read Time":
      "The time spent reading short-term data, in\nmilliseconds\n(for example during sort and hash operations that were not done in memory).\nThis\nincludes\nvalues for child operations and is a total value (i.e. not a per-loop average).\nThis was added in PostgreSQL 15, and requires both\ntrack_io_timing\nand\nBUFFERS\n.\nIn the text format of explain, this shows as\nI/O Timings: temp read\nGetting timing information has an overhead, due to checking the system clock. You can use\npg_test_timing\nto measure this for your system.",
    "Temp I/O Write Time":
      "The time spent writing short-term data, in\nmilliseconds\n(for example during sort and hash operations that were not done in memory).\nThis\nincludes\nvalues for child operations and is a total value (i.e. not a per-loop average).\nThis was added in PostgreSQL 15, and requires both\ntrack_io_timing\nand\nBUFFERS\n.\nIn the text format of explain, this shows as\nI/O Timings: temp write\nGetting timing information has an overhead, due to checking the system clock. You can use\npg_test_timing\nto measure this for your system.",
    Workers:
      "A summary of the operation detail broken down by thread.\nThese entries\ndon’t\ninclude the main (or leader) thread.\nYou can work out the values for the main thread by subtracting the worker statistics from the total.\nThis information is only shown when VERBOSE is on.",
  },
  "Parallel Index Scan": {
    "Parent Relationship":
      "A guide as to why this operation needs to be run in order to facilitate the parent operation. There are six different possibilities:\nOuter\n: The value you’ll see most often. It means “take in the rows from this operation as input, process them and pass them on”.\nInner\n: Only ever seen on the second child of join operations, and is always seen there. This is the “inner” part of the loop — for each outer row, we look up its match using this operation.\nMember\n: Used for all children of Append and ModifyTable nodes, and on bitmap processing nodes like BitmapAnd and BitmapOr operations.\nInitPlan\n: Used for calculations performed before the query can start, eg a constant referred to in the query or the result of a CTE scan.\nSubquery\n: The child is a subquery of the parent operation. Since Postgres always uses subquery scans to feed subquery data to parent queries, only ever appears on the children of subquery scans.\nSubPlan\n: Like a Subquery, represents a new query, but used when a subquery scan is not necessary.",
    "Parallel Aware":
      "Whether or not the operation will be run in a special mode to support parallelism. Some operations need to be aware that they are running in parallel, for example sequential scans need to know they only need to scan a smaller proportion of the table. Other operations can be run on several threads without each one having any knowledge of the others.",
    "Scan Direction":
      "Postgres is able to do a\nforward\nor\nbackward\nscan of a (b-tree) index to get data in sorted order. In the default (text) format, the direction is forward unless stated otherwise.\nYou may also see scan direction of “NoMovement” in scans of other index types.",
    "Index Name":
      "Unsurprisingly, this is the name of the index being scanned.",
    "Relation Name":
      "The data source being read/written from. Normally a table name (including when the data is accessed via an index), but can also be a materialised view or foreign data source.",
    Schema:
      "The schema of the “Relation Name” object.\nThis is only shown when VERBOSE is on.",
    Alias: "The alias used to refer to the Relation Name object.",
    "Startup Cost":
      "The estimated cost of returning the first row.\nThis is in an arbitrary unit, with the aim of being correlated to the startup time.",
    "Total Cost":
      "The estimated cost of returning all rows. This is in an arbitrary unit, with the aim of being correlated to the total time.\nThe Postgres query planner often has several ways it could resolve the same query. It calculates costs — which are hopefully correlated with the time it would take — for potential plans, and then picks the one with the lowest cost. It’s worth bearing in mind that the costs are unit-free — they’re not designed to convert into time, or disk reads. They’re just supposed to be bigger for slower operations, and smaller for faster ones.\nIf the planner thinks it can finish early due to a parent Limit operation, the total cost of the Limit operation will reflect this, but the total cost of its child operations will not.",
    "Plan Rows":
      "The number of rows,\nper-loop\n, that the planner expects to be returned by the operation.\nPoor row estimates can lead to suboptimal query planning. They can often be improved by running\nANALYZE\n(not the EXPLAIN parameter), by increasing statistics, or by allowing Postgres to understand correlation between columns using multivariate statistics.\nIf the planner thinks it can finish early due to a Limit operation, the plan rows of the Limit operation will reflect this, but the plan rows of its child operations will not.",
    "Plan Width":
      "The\nestimated\naverage size of the rows produced by the operation, in\nbytes\n.",
    "Actual Startup Time":
      "The amount of time, in\nmilliseconds\n, it takes to get the first row out of the operation.\nSometimes, this is very close to the setup time — for example on a sequential scan which returns all the rows in a table.\nOther times, though, it’s more or less the total time. For example, in order to return the first row of a sort, you have to sort all of the rows to work out which one comes first.",
    "Actual Total Time":
      "The actual amount of time in milliseconds spent on this operation\nand all of its children\n. It’s a\nper-loop average\n, rounded to the nearest thousandth of a millisecond.\nWorking out individual operation timings, especially where CTEs and SubPlans are concerned, can be tricky. This is one of the main reasons we decided to build\npgMustard\n.",
    "Actual Rows":
      "The number of rows returned by the operation\nper loop\n.\nThe important thing to notice about this is that it’s an average of all the loops executed, rounded to the nearest integer. This means that while “Actual Loops” multiplied by “Actual Rows” is a pretty good approximation for total number of rows returned most of the time, it can be off by as much as half of the number of loops. Usually it’s just slightly confusing as you see a row or two appear or disappear between operations, but on operations with lots of loops there is potential for serious miscalculation.\nPoor row estimates, where Actual Rows differs substantially from Plan Rows, can lead to suboptimal query planning. Estimates can often be improved by running\nANALYZE\n(not the EXPLAIN parameter), by increasing statistics, or by allowing Postgres to understand correlation between columns using multivariate statistics.",
    "Actual Loops":
      "The number of times the operation is executed. For a lot of operations it will have a value of one, but when it is not, there are three different cases:\nSome operations can be executed more than once. For example, “Nested Loops” run their “Inner” child once for every row returned by their “Outer” child.\nWhen an operation that would normally only consist of one loop is split across multiple threads, each partial operation is counted as a Loop.\nThe number of loops can be zero when an operation doesn’t need to be executed at all. For example if a table read is planned to provide candidates for an inner join, but there turns out to be no rows on the other side of the join, the operation can be effectively eliminated.",
    Output:
      "A list of the columns returned by the operation.\nThis is only shown when VERBOSE is on.",
    "Index Cond":
      "The condition(s) used to find the locations of rows from the index.\nPostgres uses the structured nature of the index to jump to the rows it's looking for. Different index types use different strategies.\nUnfortunately, Postgres doesn’t yet distinguish between conditions used to access and conditions used to filter rows as part of the Index Cond. As such, you need to compare the index definition and query conditions to work it out, and can compare the\nCOSTS\nor\nBUFFERS\nbetween query plans as a check.\nAny conditions that could not be used to search the index will be added as a\nFilter\n, which later discards any rows necessary based on their values. This is naturally less efficient.",
    "Rows Removed by Index Recheck":
      "The number of rows returned by the index scan that do not meet the condition and are subsequently removed.\nThis will either be the result of a lossy bitmap scan, or an index type that doesn't guarantee that a row matches the condition.",
    Filter:
      "When present, this is a filter used to remove rows.\nThe important thing to note is that this is a filter in the traditional sense: these rows are read in (either from a data source or another operation in the plan), inspected, and then approved or removed based on the filter.\nIf a high proportion of rows are being removed by the Filter, you may want to investigate whether a (more) selective index could help.\nIf you notice a lot of rows being filtered late in a query plan, this might be due to an operation (like a GROUP BY or SORT) using more columns than are necessary, requiring joins to take place before rows can be discarded. It is also sometimes a result of unnecessary or ill-advised uses of DISTINCT.",
    "Rows Removed by Filter":
      "The number of rows removed by the\nFilter\n. This is a\nper-loop average\n, rounded to the nearest integer.\nIf a high proportion of rows are being removed, you may want to investigate whether a (more) selective index could help.",
    "Shared Hit Blocks":
      "The number of blocks from indexes/tables that were found in the Postgres buffer cache.\nThis\nincludes\nvalues for child operations and is a\ntotal\nvalue (i.e. not a per-loop average).\nOnce you have subtracted child operation values, the proportion of shared hit to shared read blocks is an interesting measure of cache performance.\nThe ratio of shared blocks (hit plus read) to rows processed (including any filtered out) is also interesting: a high ratio means Postgres is reading a lot of data for what it is doing, which can be a sign of bloat.",
    "Shared Read Blocks":
      "The number of blocks from tables/indexes that were read from disk (or the OS cache).\nThis\nincludes\nvalues for child operations and is a\ntotal\nvalue (i.e. not per-loop).\nOnce you have subtracted child operation values, the proportion of shared hit to shared read blocks is an interesting measure of cache performance.\nThe ratio of shared blocks (hit plus read) to rows processed (including any filtered out) is also interesting: a high ratio means Postgres is reading a lot of data for what it is doing, which can be a sign of bloat.",
    "Shared Dirtied Blocks":
      "The number of blocks from tables/indexes that were modified by the operation.\nThis\nincludes\nvalues for child operations and is a\ntotal\nvalue (i.e. not per-loop).\nInterestingly, a SELECT query can report shared dirtied blocks when setting hint bits on recently-committed rows, or pruning old row versions. While somewhat surprising, both of these are perfectly normal and healthy.",
    "Shared Written Blocks":
      "The number of blocks from tables/indexes that were evicted from the cache.\nThis\nincludes\nvalues for child operations and is a\ntotal\nvalue (i.e. not a per-loop average).",
    "Local Hit Blocks":
      "The number of blocks from temporary tables and indexes that were found in the cache.\nThis\nincludes\nvalues for child operations and is a\ntotal\nvalue (not a per-loop average).",
    "Local Read Blocks":
      "The number of blocks read from\ntemporary tables and indexes that were not found in the Postgres cache (read from disk or the OS cache).\nThis\nincludes\nvalues for child operations and is a\ntotal\nvalue (not a per-loop average).",
    "Local Dirtied Blocks":
      "The number of blocks from\ntemporary tables and indexes that have been modified by the operation.\nThis\nincludes\nvalues for child operations and is a\ntotal\nvalue (i.e. not a per-loop average).",
    "Local Written Blocks":
      "The number of blocks from\ntemporary tables and indexes that were evicted from the cache.\nThis\nincludes\nvalues for child operations and is a\ntotal\nvalue (i.e. not a per-loop average).",
    "Temp Read Blocks":
      "The number of blocks read from short-term data used to calculate hashes, sorts, Materialize operations, and similar.\nThis\nincludes\nvalues for child operations and is a\ntotal\nvalue (i.e. not a per-loop average).\nYour settings of\nwork_mem\nand\nhash_mem_multiplier\ndetermine how much memory is available to Postgres per operation.",
    "Temp Written Blocks":
      "The number of blocks from short-term data (used to calculate operations like hashes, sorts, and materializes) that were evicted from the cache.\nThis\nincludes\nvalues for child operations and is a\ntotal\nvalue (i.e. not a per-loop average).\nYour settings of\nwork_mem\nand\nhash_mem_multiplier\ndetermine how much memory is available to Postgres per operation.",
    "Shared I/O Read Time":
      "The time spent reading data from tables and indexes, in\nmilliseconds\n.\nThis\nincludes\nvalues for child operations and is a total value (not a per-loop average).\nRequires\ntrack_io_timing\nand\nBUFFERS\nto be on.\nIn the latest version, the text format of explain displays this as\nI/O Timings: shared read\nIn PostgreSQL 15 and 16 it shows as a combined metric\nI/O Timings: shared/local read\nGetting timing information has an overhead, due to checking the system clock. You can use\npg_test_timing\nto measure this for your system.",
    "Shared I/O Write Time":
      "The time spent writing data for tables and indexes, in\nmilliseconds\n.\nThis\nincludes\nvalues for child operations and is a total value (not a per-loop average).\nRequires\ntrack_io_timing\nand\nBUFFERS\nto be on.\nIn the latest version, the text format of explain displays this as\nI/O Timings: shared write\nIn PostgreSQL 15 and 16 it shows as a combined metric\nI/O Timings: shared/local write\nGetting timing information has an overhead, due to checking the system clock. You can use\npg_test_timing\nto measure this for your system.",
    "Local I/O Read Time":
      "The time spent reading local data (e.g. from temporary tables and indexes), in\nmilliseconds\n.\nThis\nincludes\nvalues for child operations and is a total value (i.e. not a per-loop average).\nThis was added as a separate field in PostgreSQL 17, and requires both\ntrack_io_timing\nand\nBUFFERS\n.\nIn the default text format, this will show as\nI/O Timings: local read\nIn versions 15 and 16 it is available as a combined metric as\nshared/local\nGetting timing information has an overhead, due to checking the system clock. You can use\npg_test_timing\nto measure this for your system.",
    "Local I/O Write Time":
      "The time spent writing local data (e.g. for temporary tables and indexes), in\nmilliseconds\n.\nThis\nincludes\nvalues for child operations and is a total value (i.e. not a per-loop average).\nThis was added as a separate field in PostgreSQL 17, and requires both\ntrack_io_timing\nand\nBUFFERS\n.\nIn the default text format, this will show as\nI/O Timings: local write\nIn versions 15 and 16 it is available as a combined metric as\nshared/local\nGetting timing information has an overhead, due to checking the system clock. You can use\npg_test_timing\nto measure this for your system.",
    "Temp I/O Read Time":
      "The time spent reading short-term data, in\nmilliseconds\n(for example during sort and hash operations that were not done in memory).\nThis\nincludes\nvalues for child operations and is a total value (i.e. not a per-loop average).\nThis was added in PostgreSQL 15, and requires both\ntrack_io_timing\nand\nBUFFERS\n.\nIn the text format of explain, this shows as\nI/O Timings: temp read\nGetting timing information has an overhead, due to checking the system clock. You can use\npg_test_timing\nto measure this for your system.",
    "Temp I/O Write Time":
      "The time spent writing short-term data, in\nmilliseconds\n(for example during sort and hash operations that were not done in memory).\nThis\nincludes\nvalues for child operations and is a total value (i.e. not a per-loop average).\nThis was added in PostgreSQL 15, and requires both\ntrack_io_timing\nand\nBUFFERS\n.\nIn the text format of explain, this shows as\nI/O Timings: temp write\nGetting timing information has an overhead, due to checking the system clock. You can use\npg_test_timing\nto measure this for your system.",
    Workers:
      "A summary of the operation detail broken down by thread.\nThese entries\ndon’t\ninclude the main (or leader) thread.\nYou can work out the values for the main thread by subtracting the worker statistics from the total.\nThis information is only shown when VERBOSE is on.",
  },
  "Parallel Index-Only Scan": {
    "Parent Relationship":
      "A guide as to why this operation needs to be run in order to facilitate the parent operation. There are six different possibilities:\nOuter\n: The value you’ll see most often. It means “take in the rows from this operation as input, process them and pass them on”.\nInner\n: Only ever seen on the second child of join operations, and is always seen there. This is the “inner” part of the loop — for each outer row, we look up its match using this operation.\nMember\n: Used for all children of Append and ModifyTable nodes, and on bitmap processing nodes like BitmapAnd and BitmapOr operations.\nInitPlan\n: Used for calculations performed before the query can start, eg a constant referred to in the query or the result of a CTE scan.\nSubquery\n: The child is a subquery of the parent operation. Since Postgres always uses subquery scans to feed subquery data to parent queries, only ever appears on the children of subquery scans.\nSubPlan\n: Like a Subquery, represents a new query, but used when a subquery scan is not necessary.",
    "Parallel Aware":
      "Whether or not the operation will be run in a special mode to support parallelism. Some operations need to be aware that they are running in parallel, for example sequential scans need to know they only need to scan a smaller proportion of the table. Other operations can be run on several threads without each one having any knowledge of the others.",
    "Scan Direction":
      "Postgres is able to do a\nforward\nor\nbackward\nscan of a (b-tree) index to get data in sorted order. In the default (text) format, the direction is forward unless stated otherwise.\nYou may also see scan direction of “NoMovement” in scans of other index types.",
    "Index Name":
      "Unsurprisingly, this is the name of the index being scanned.",
    "Relation Name":
      "The data source being read/written from. Normally a table name (including when the data is accessed via an index), but can also be a materialised view or foreign data source.",
    Schema:
      "The schema of the “Relation Name” object.\nThis is only shown when VERBOSE is on.",
    Alias: "The alias used to refer to the Relation Name object.",
    "Startup Cost":
      "The estimated cost of returning the first row.\nThis is in an arbitrary unit, with the aim of being correlated to the startup time.",
    "Total Cost":
      "The estimated cost of returning all rows. This is in an arbitrary unit, with the aim of being correlated to the total time.\nThe Postgres query planner often has several ways it could resolve the same query. It calculates costs — which are hopefully correlated with the time it would take — for potential plans, and then picks the one with the lowest cost. It’s worth bearing in mind that the costs are unit-free — they’re not designed to convert into time, or disk reads. They’re just supposed to be bigger for slower operations, and smaller for faster ones.\nIf the planner thinks it can finish early due to a parent Limit operation, the total cost of the Limit operation will reflect this, but the total cost of its child operations will not.",
    "Plan Rows":
      "The number of rows,\nper-loop\n, that the planner expects to be returned by the operation.\nPoor row estimates can lead to suboptimal query planning. They can often be improved by running\nANALYZE\n(not the EXPLAIN parameter), by increasing statistics, or by allowing Postgres to understand correlation between columns using multivariate statistics.\nIf the planner thinks it can finish early due to a Limit operation, the plan rows of the Limit operation will reflect this, but the plan rows of its child operations will not.",
    "Plan Width":
      "The\nestimated\naverage size of the rows produced by the operation, in\nbytes\n.",
    "Actual Startup Time":
      "The amount of time, in\nmilliseconds\n, it takes to get the first row out of the operation.\nSometimes, this is very close to the setup time — for example on a sequential scan which returns all the rows in a table.\nOther times, though, it’s more or less the total time. For example, in order to return the first row of a sort, you have to sort all of the rows to work out which one comes first.",
    "Actual Total Time":
      "The actual amount of time in milliseconds spent on this operation\nand all of its children\n. It’s a\nper-loop average\n, rounded to the nearest thousandth of a millisecond.\nWorking out individual operation timings, especially where CTEs and SubPlans are concerned, can be tricky. This is one of the main reasons we decided to build\npgMustard\n.",
    "Actual Rows":
      "The number of rows returned by the operation\nper loop\n.\nThe important thing to notice about this is that it’s an average of all the loops executed, rounded to the nearest integer. This means that while “Actual Loops” multiplied by “Actual Rows” is a pretty good approximation for total number of rows returned most of the time, it can be off by as much as half of the number of loops. Usually it’s just slightly confusing as you see a row or two appear or disappear between operations, but on operations with lots of loops there is potential for serious miscalculation.\nPoor row estimates, where Actual Rows differs substantially from Plan Rows, can lead to suboptimal query planning. Estimates can often be improved by running\nANALYZE\n(not the EXPLAIN parameter), by increasing statistics, or by allowing Postgres to understand correlation between columns using multivariate statistics.",
    "Actual Loops":
      "The number of times the operation is executed. For a lot of operations it will have a value of one, but when it is not, there are three different cases:\nSome operations can be executed more than once. For example, “Nested Loops” run their “Inner” child once for every row returned by their “Outer” child.\nWhen an operation that would normally only consist of one loop is split across multiple threads, each partial operation is counted as a Loop.\nThe number of loops can be zero when an operation doesn’t need to be executed at all. For example if a table read is planned to provide candidates for an inner join, but there turns out to be no rows on the other side of the join, the operation can be effectively eliminated.",
    Output:
      "A list of the columns returned by the operation.\nThis is only shown when VERBOSE is on.",
    "Index Cond":
      "The condition(s) used to find the locations of rows from the index.\nPostgres uses the structured nature of the index to jump to the rows it's looking for. Different index types use different strategies.\nUnfortunately, Postgres doesn’t yet distinguish between conditions used to access and conditions used to filter rows as part of the Index Cond. As such, you need to compare the index definition and query conditions to work it out, and can compare the\nCOSTS\nor\nBUFFERS\nbetween query plans as a check.\nAny conditions that could not be used to search the index will be added as a\nFilter\n, which later discards any rows necessary based on their values. This is naturally less efficient.",
    "Rows Removed by Index Recheck":
      "The number of rows returned by the index scan that do not meet the condition and are subsequently removed.\nThis will either be the result of a lossy bitmap scan, or an index type that doesn't guarantee that a row matches the condition.",
    Filter:
      "When present, this is a filter used to remove rows.\nThe important thing to note is that this is a filter in the traditional sense: these rows are read in (either from a data source or another operation in the plan), inspected, and then approved or removed based on the filter.\nIf a high proportion of rows are being removed by the Filter, you may want to investigate whether a (more) selective index could help.\nIf you notice a lot of rows being filtered late in a query plan, this might be due to an operation (like a GROUP BY or SORT) using more columns than are necessary, requiring joins to take place before rows can be discarded. It is also sometimes a result of unnecessary or ill-advised uses of DISTINCT.",
    "Rows Removed by Filter":
      "The number of rows removed by the\nFilter\n. This is a\nper-loop average\n, rounded to the nearest integer.\nIf a high proportion of rows are being removed, you may want to investigate whether a (more) selective index could help.",
    "Heap Fetches":
      "The number of rows Postgres had to look up in the table, rather than the index, during an index-only scan. It is a\ntotal\nvalue (not a per-loop average).\nPostgres still needs to be sure that the row is visible before it can return it, and that information is on the heap, not in the index. It can get around going to the heap for a particular row by checking the visibility map, which records whether or not each page has been changed recently.\nIf the page has changed, then that means a trip to the heap, the same as if we were doing a normal index scan — in fact it’s slightly worse than an index scan, because we’ve added in an extra check of the visibility map.\nHeap fetches can often be reduced by vacuum, or adjusting autovacuum settings, to keep the visibility map more up to date.",
    "Shared Hit Blocks":
      "The number of blocks from indexes/tables that were found in the Postgres buffer cache.\nThis\nincludes\nvalues for child operations and is a\ntotal\nvalue (i.e. not a per-loop average).\nOnce you have subtracted child operation values, the proportion of shared hit to shared read blocks is an interesting measure of cache performance.\nThe ratio of shared blocks (hit plus read) to rows processed (including any filtered out) is also interesting: a high ratio means Postgres is reading a lot of data for what it is doing, which can be a sign of bloat.",
    "Shared Read Blocks":
      "The number of blocks from tables/indexes that were read from disk (or the OS cache).\nThis\nincludes\nvalues for child operations and is a\ntotal\nvalue (i.e. not per-loop).\nOnce you have subtracted child operation values, the proportion of shared hit to shared read blocks is an interesting measure of cache performance.\nThe ratio of shared blocks (hit plus read) to rows processed (including any filtered out) is also interesting: a high ratio means Postgres is reading a lot of data for what it is doing, which can be a sign of bloat.",
    "Shared Dirtied Blocks":
      "The number of blocks from tables/indexes that were modified by the operation.\nThis\nincludes\nvalues for child operations and is a\ntotal\nvalue (i.e. not per-loop).\nInterestingly, a SELECT query can report shared dirtied blocks when setting hint bits on recently-committed rows, or pruning old row versions. While somewhat surprising, both of these are perfectly normal and healthy.",
    "Shared Written Blocks":
      "The number of blocks from tables/indexes that were evicted from the cache.\nThis\nincludes\nvalues for child operations and is a\ntotal\nvalue (i.e. not a per-loop average).",
    "Local Hit Blocks":
      "The number of blocks from temporary tables and indexes that were found in the cache.\nThis\nincludes\nvalues for child operations and is a\ntotal\nvalue (not a per-loop average).",
    "Local Read Blocks":
      "The number of blocks read from\ntemporary tables and indexes that were not found in the Postgres cache (read from disk or the OS cache).\nThis\nincludes\nvalues for child operations and is a\ntotal\nvalue (not a per-loop average).",
    "Local Dirtied Blocks":
      "The number of blocks from\ntemporary tables and indexes that have been modified by the operation.\nThis\nincludes\nvalues for child operations and is a\ntotal\nvalue (i.e. not a per-loop average).",
    "Local Written Blocks":
      "The number of blocks from\ntemporary tables and indexes that were evicted from the cache.\nThis\nincludes\nvalues for child operations and is a\ntotal\nvalue (i.e. not a per-loop average).",
    "Temp Read Blocks":
      "The number of blocks read from short-term data used to calculate hashes, sorts, Materialize operations, and similar.\nThis\nincludes\nvalues for child operations and is a\ntotal\nvalue (i.e. not a per-loop average).\nYour settings of\nwork_mem\nand\nhash_mem_multiplier\ndetermine how much memory is available to Postgres per operation.",
    "Temp Written Blocks":
      "The number of blocks from short-term data (used to calculate operations like hashes, sorts, and materializes) that were evicted from the cache.\nThis\nincludes\nvalues for child operations and is a\ntotal\nvalue (i.e. not a per-loop average).\nYour settings of\nwork_mem\nand\nhash_mem_multiplier\ndetermine how much memory is available to Postgres per operation.",
    "Shared I/O Read Time":
      "The time spent reading data from tables and indexes, in\nmilliseconds\n.\nThis\nincludes\nvalues for child operations and is a total value (not a per-loop average).\nRequires\ntrack_io_timing\nand\nBUFFERS\nto be on.\nIn the latest version, the text format of explain displays this as\nI/O Timings: shared read\nIn PostgreSQL 15 and 16 it shows as a combined metric\nI/O Timings: shared/local read\nGetting timing information has an overhead, due to checking the system clock. You can use\npg_test_timing\nto measure this for your system.",
    "Shared I/O Write Time":
      "The time spent writing data for tables and indexes, in\nmilliseconds\n.\nThis\nincludes\nvalues for child operations and is a total value (not a per-loop average).\nRequires\ntrack_io_timing\nand\nBUFFERS\nto be on.\nIn the latest version, the text format of explain displays this as\nI/O Timings: shared write\nIn PostgreSQL 15 and 16 it shows as a combined metric\nI/O Timings: shared/local write\nGetting timing information has an overhead, due to checking the system clock. You can use\npg_test_timing\nto measure this for your system.",
    "Local I/O Read Time":
      "The time spent reading local data (e.g. from temporary tables and indexes), in\nmilliseconds\n.\nThis\nincludes\nvalues for child operations and is a total value (i.e. not a per-loop average).\nThis was added as a separate field in PostgreSQL 17, and requires both\ntrack_io_timing\nand\nBUFFERS\n.\nIn the default text format, this will show as\nI/O Timings: local read\nIn versions 15 and 16 it is available as a combined metric as\nshared/local\nGetting timing information has an overhead, due to checking the system clock. You can use\npg_test_timing\nto measure this for your system.",
    "Local I/O Write Time":
      "The time spent writing local data (e.g. for temporary tables and indexes), in\nmilliseconds\n.\nThis\nincludes\nvalues for child operations and is a total value (i.e. not a per-loop average).\nThis was added as a separate field in PostgreSQL 17, and requires both\ntrack_io_timing\nand\nBUFFERS\n.\nIn the default text format, this will show as\nI/O Timings: local write\nIn versions 15 and 16 it is available as a combined metric as\nshared/local\nGetting timing information has an overhead, due to checking the system clock. You can use\npg_test_timing\nto measure this for your system.",
    "Temp I/O Read Time":
      "The time spent reading short-term data, in\nmilliseconds\n(for example during sort and hash operations that were not done in memory).\nThis\nincludes\nvalues for child operations and is a total value (i.e. not a per-loop average).\nThis was added in PostgreSQL 15, and requires both\ntrack_io_timing\nand\nBUFFERS\n.\nIn the text format of explain, this shows as\nI/O Timings: temp read\nGetting timing information has an overhead, due to checking the system clock. You can use\npg_test_timing\nto measure this for your system.",
    "Temp I/O Write Time":
      "The time spent writing short-term data, in\nmilliseconds\n(for example during sort and hash operations that were not done in memory).\nThis\nincludes\nvalues for child operations and is a total value (i.e. not a per-loop average).\nThis was added in PostgreSQL 15, and requires both\ntrack_io_timing\nand\nBUFFERS\n.\nIn the text format of explain, this shows as\nI/O Timings: temp write\nGetting timing information has an overhead, due to checking the system clock. You can use\npg_test_timing\nto measure this for your system.",
    Workers:
      "A summary of the operation detail broken down by thread.\nThese entries\ndon’t\ninclude the main (or leader) thread.\nYou can work out the values for the main thread by subtracting the worker statistics from the total.\nThis information is only shown when VERBOSE is on.",
  },
  "Parallel Seq Scan": {
    "Parent Relationship":
      "A guide as to why this operation needs to be run in order to facilitate the parent operation. There are six different possibilities:\nOuter\n: The value you’ll see most often. It means “take in the rows from this operation as input, process them and pass them on”.\nInner\n: Only ever seen on the second child of join operations, and is always seen there. This is the “inner” part of the loop — for each outer row, we look up its match using this operation.\nMember\n: Used for all children of Append and ModifyTable nodes, and on bitmap processing nodes like BitmapAnd and BitmapOr operations.\nInitPlan\n: Used for calculations performed before the query can start, eg a constant referred to in the query or the result of a CTE scan.\nSubquery\n: The child is a subquery of the parent operation. Since Postgres always uses subquery scans to feed subquery data to parent queries, only ever appears on the children of subquery scans.\nSubPlan\n: Like a Subquery, represents a new query, but used when a subquery scan is not necessary.",
    "Parallel Aware":
      "Whether or not the operation will be run in a special mode to support parallelism. Some operations need to be aware that they are running in parallel, for example sequential scans need to know they only need to scan a smaller proportion of the table. Other operations can be run on several threads without each one having any knowledge of the others.",
    "Relation Name":
      "The data source being read/written from. Normally a table name (including when the data is accessed via an index), but can also be a materialised view or foreign data source.",
    Schema:
      "The schema of the “Relation Name” object.\nThis is only shown when VERBOSE is on.",
    Alias: "The alias used to refer to the Relation Name object.",
    "Startup Cost":
      "The estimated cost of returning the first row.\nThis is in an arbitrary unit, with the aim of being correlated to the startup time.",
    "Total Cost":
      "The estimated cost of returning all rows. This is in an arbitrary unit, with the aim of being correlated to the total time.\nThe Postgres query planner often has several ways it could resolve the same query. It calculates costs — which are hopefully correlated with the time it would take — for potential plans, and then picks the one with the lowest cost. It’s worth bearing in mind that the costs are unit-free — they’re not designed to convert into time, or disk reads. They’re just supposed to be bigger for slower operations, and smaller for faster ones.\nIf the planner thinks it can finish early due to a parent Limit operation, the total cost of the Limit operation will reflect this, but the total cost of its child operations will not.",
    "Plan Rows":
      "The number of rows,\nper-loop\n, that the planner expects to be returned by the operation.\nPoor row estimates can lead to suboptimal query planning. They can often be improved by running\nANALYZE\n(not the EXPLAIN parameter), by increasing statistics, or by allowing Postgres to understand correlation between columns using multivariate statistics.\nIf the planner thinks it can finish early due to a Limit operation, the plan rows of the Limit operation will reflect this, but the plan rows of its child operations will not.",
    "Plan Width":
      "The\nestimated\naverage size of the rows produced by the operation, in\nbytes\n.",
    "Actual Startup Time":
      "The amount of time, in\nmilliseconds\n, it takes to get the first row out of the operation.\nSometimes, this is very close to the setup time — for example on a sequential scan which returns all the rows in a table.\nOther times, though, it’s more or less the total time. For example, in order to return the first row of a sort, you have to sort all of the rows to work out which one comes first.",
    "Actual Total Time":
      "The actual amount of time in milliseconds spent on this operation\nand all of its children\n. It’s a\nper-loop average\n, rounded to the nearest thousandth of a millisecond.\nWorking out individual operation timings, especially where CTEs and SubPlans are concerned, can be tricky. This is one of the main reasons we decided to build\npgMustard\n.",
    "Actual Rows":
      "The number of rows returned by the operation\nper loop\n.\nThe important thing to notice about this is that it’s an average of all the loops executed, rounded to the nearest integer. This means that while “Actual Loops” multiplied by “Actual Rows” is a pretty good approximation for total number of rows returned most of the time, it can be off by as much as half of the number of loops. Usually it’s just slightly confusing as you see a row or two appear or disappear between operations, but on operations with lots of loops there is potential for serious miscalculation.\nPoor row estimates, where Actual Rows differs substantially from Plan Rows, can lead to suboptimal query planning. Estimates can often be improved by running\nANALYZE\n(not the EXPLAIN parameter), by increasing statistics, or by allowing Postgres to understand correlation between columns using multivariate statistics.",
    "Actual Loops":
      "The number of times the operation is executed. For a lot of operations it will have a value of one, but when it is not, there are three different cases:\nSome operations can be executed more than once. For example, “Nested Loops” run their “Inner” child once for every row returned by their “Outer” child.\nWhen an operation that would normally only consist of one loop is split across multiple threads, each partial operation is counted as a Loop.\nThe number of loops can be zero when an operation doesn’t need to be executed at all. For example if a table read is planned to provide candidates for an inner join, but there turns out to be no rows on the other side of the join, the operation can be effectively eliminated.",
    Output:
      "A list of the columns returned by the operation.\nThis is only shown when VERBOSE is on.",
    Filter:
      "When present, this is a filter used to remove rows.\nThe important thing to note is that this is a filter in the traditional sense: these rows are read in (either from a data source or another operation in the plan), inspected, and then approved or removed based on the filter.\nIf a high proportion of rows are being removed by the Filter, you may want to investigate whether a (more) selective index could help.\nIf you notice a lot of rows being filtered late in a query plan, this might be due to an operation (like a GROUP BY or SORT) using more columns than are necessary, requiring joins to take place before rows can be discarded. It is also sometimes a result of unnecessary or ill-advised uses of DISTINCT.",
    "Rows Removed by Filter":
      "The number of rows removed by the\nFilter\n. This is a\nper-loop average\n, rounded to the nearest integer.\nIf a high proportion of rows are being removed, you may want to investigate whether a (more) selective index could help.",
    "Shared Hit Blocks":
      "The number of blocks from indexes/tables that were found in the Postgres buffer cache.\nThis\nincludes\nvalues for child operations and is a\ntotal\nvalue (i.e. not a per-loop average).\nOnce you have subtracted child operation values, the proportion of shared hit to shared read blocks is an interesting measure of cache performance.\nThe ratio of shared blocks (hit plus read) to rows processed (including any filtered out) is also interesting: a high ratio means Postgres is reading a lot of data for what it is doing, which can be a sign of bloat.",
    "Shared Read Blocks":
      "The number of blocks from tables/indexes that were read from disk (or the OS cache).\nThis\nincludes\nvalues for child operations and is a\ntotal\nvalue (i.e. not per-loop).\nOnce you have subtracted child operation values, the proportion of shared hit to shared read blocks is an interesting measure of cache performance.\nThe ratio of shared blocks (hit plus read) to rows processed (including any filtered out) is also interesting: a high ratio means Postgres is reading a lot of data for what it is doing, which can be a sign of bloat.",
    "Shared Dirtied Blocks":
      "The number of blocks from tables/indexes that were modified by the operation.\nThis\nincludes\nvalues for child operations and is a\ntotal\nvalue (i.e. not per-loop).\nInterestingly, a SELECT query can report shared dirtied blocks when setting hint bits on recently-committed rows, or pruning old row versions. While somewhat surprising, both of these are perfectly normal and healthy.",
    "Shared Written Blocks":
      "The number of blocks from tables/indexes that were evicted from the cache.\nThis\nincludes\nvalues for child operations and is a\ntotal\nvalue (i.e. not a per-loop average).",
    "Local Hit Blocks":
      "The number of blocks from temporary tables and indexes that were found in the cache.\nThis\nincludes\nvalues for child operations and is a\ntotal\nvalue (not a per-loop average).",
    "Local Read Blocks":
      "The number of blocks read from\ntemporary tables and indexes that were not found in the Postgres cache (read from disk or the OS cache).\nThis\nincludes\nvalues for child operations and is a\ntotal\nvalue (not a per-loop average).",
    "Local Dirtied Blocks":
      "The number of blocks from\ntemporary tables and indexes that have been modified by the operation.\nThis\nincludes\nvalues for child operations and is a\ntotal\nvalue (i.e. not a per-loop average).",
    "Local Written Blocks":
      "The number of blocks from\ntemporary tables and indexes that were evicted from the cache.\nThis\nincludes\nvalues for child operations and is a\ntotal\nvalue (i.e. not a per-loop average).",
    "Temp Read Blocks":
      "The number of blocks read from short-term data used to calculate hashes, sorts, Materialize operations, and similar.\nThis\nincludes\nvalues for child operations and is a\ntotal\nvalue (i.e. not a per-loop average).\nYour settings of\nwork_mem\nand\nhash_mem_multiplier\ndetermine how much memory is available to Postgres per operation.",
    "Temp Written Blocks":
      "The number of blocks from short-term data (used to calculate operations like hashes, sorts, and materializes) that were evicted from the cache.\nThis\nincludes\nvalues for child operations and is a\ntotal\nvalue (i.e. not a per-loop average).\nYour settings of\nwork_mem\nand\nhash_mem_multiplier\ndetermine how much memory is available to Postgres per operation.",
    "Shared I/O Read Time":
      "The time spent reading data from tables and indexes, in\nmilliseconds\n.\nThis\nincludes\nvalues for child operations and is a total value (not a per-loop average).\nRequires\ntrack_io_timing\nand\nBUFFERS\nto be on.\nIn the latest version, the text format of explain displays this as\nI/O Timings: shared read\nIn PostgreSQL 15 and 16 it shows as a combined metric\nI/O Timings: shared/local read\nGetting timing information has an overhead, due to checking the system clock. You can use\npg_test_timing\nto measure this for your system.",
    "Shared I/O Write Time":
      "The time spent writing data for tables and indexes, in\nmilliseconds\n.\nThis\nincludes\nvalues for child operations and is a total value (not a per-loop average).\nRequires\ntrack_io_timing\nand\nBUFFERS\nto be on.\nIn the latest version, the text format of explain displays this as\nI/O Timings: shared write\nIn PostgreSQL 15 and 16 it shows as a combined metric\nI/O Timings: shared/local write\nGetting timing information has an overhead, due to checking the system clock. You can use\npg_test_timing\nto measure this for your system.",
    "Local I/O Read Time":
      "The time spent reading local data (e.g. from temporary tables and indexes), in\nmilliseconds\n.\nThis\nincludes\nvalues for child operations and is a total value (i.e. not a per-loop average).\nThis was added as a separate field in PostgreSQL 17, and requires both\ntrack_io_timing\nand\nBUFFERS\n.\nIn the default text format, this will show as\nI/O Timings: local read\nIn versions 15 and 16 it is available as a combined metric as\nshared/local\nGetting timing information has an overhead, due to checking the system clock. You can use\npg_test_timing\nto measure this for your system.",
    "Local I/O Write Time":
      "The time spent writing local data (e.g. for temporary tables and indexes), in\nmilliseconds\n.\nThis\nincludes\nvalues for child operations and is a total value (i.e. not a per-loop average).\nThis was added as a separate field in PostgreSQL 17, and requires both\ntrack_io_timing\nand\nBUFFERS\n.\nIn the default text format, this will show as\nI/O Timings: local write\nIn versions 15 and 16 it is available as a combined metric as\nshared/local\nGetting timing information has an overhead, due to checking the system clock. You can use\npg_test_timing\nto measure this for your system.",
    "Temp I/O Read Time":
      "The time spent reading short-term data, in\nmilliseconds\n(for example during sort and hash operations that were not done in memory).\nThis\nincludes\nvalues for child operations and is a total value (i.e. not a per-loop average).\nThis was added in PostgreSQL 15, and requires both\ntrack_io_timing\nand\nBUFFERS\n.\nIn the text format of explain, this shows as\nI/O Timings: temp read\nGetting timing information has an overhead, due to checking the system clock. You can use\npg_test_timing\nto measure this for your system.",
    "Temp I/O Write Time":
      "The time spent writing short-term data, in\nmilliseconds\n(for example during sort and hash operations that were not done in memory).\nThis\nincludes\nvalues for child operations and is a total value (i.e. not a per-loop average).\nThis was added in PostgreSQL 15, and requires both\ntrack_io_timing\nand\nBUFFERS\n.\nIn the text format of explain, this shows as\nI/O Timings: temp write\nGetting timing information has an overhead, due to checking the system clock. You can use\npg_test_timing\nto measure this for your system.",
    Workers:
      "A summary of the operation detail broken down by thread.\nThese entries\ndon’t\ninclude the main (or leader) thread.\nYou can work out the values for the main thread by subtracting the worker statistics from the total.\nThis information is only shown when VERBOSE is on.",
  },
  ProjectSet: {
    "Parent Relationship":
      "A guide as to why this operation needs to be run in order to facilitate the parent operation. There are six different possibilities:\nOuter\n: The value you’ll see most often. It means “take in the rows from this operation as input, process them and pass them on”.\nInner\n: Only ever seen on the second child of join operations, and is always seen there. This is the “inner” part of the loop — for each outer row, we look up its match using this operation.\nMember\n: Used for all children of Append and ModifyTable nodes, and on bitmap processing nodes like BitmapAnd and BitmapOr operations.\nInitPlan\n: Used for calculations performed before the query can start, eg a constant referred to in the query or the result of a CTE scan.\nSubquery\n: The child is a subquery of the parent operation. Since Postgres always uses subquery scans to feed subquery data to parent queries, only ever appears on the children of subquery scans.\nSubPlan\n: Like a Subquery, represents a new query, but used when a subquery scan is not necessary.",
    "Parallel Aware":
      "Whether or not the operation will be run in a special mode to support parallelism. Some operations need to be aware that they are running in parallel, for example sequential scans need to know they only need to scan a smaller proportion of the table. Other operations can be run on several threads without each one having any knowledge of the others.",
    "Startup Cost":
      "The estimated cost of returning the first row.\nThis is in an arbitrary unit, with the aim of being correlated to the startup time.",
    "Total Cost":
      "The estimated cost of returning all rows. This is in an arbitrary unit, with the aim of being correlated to the total time.\nThe Postgres query planner often has several ways it could resolve the same query. It calculates costs — which are hopefully correlated with the time it would take — for potential plans, and then picks the one with the lowest cost. It’s worth bearing in mind that the costs are unit-free — they’re not designed to convert into time, or disk reads. They’re just supposed to be bigger for slower operations, and smaller for faster ones.\nIf the planner thinks it can finish early due to a parent Limit operation, the total cost of the Limit operation will reflect this, but the total cost of its child operations will not.",
    "Plan Rows":
      "The number of rows,\nper-loop\n, that the planner expects to be returned by the operation.\nPoor row estimates can lead to suboptimal query planning. They can often be improved by running\nANALYZE\n(not the EXPLAIN parameter), by increasing statistics, or by allowing Postgres to understand correlation between columns using multivariate statistics.\nIf the planner thinks it can finish early due to a Limit operation, the plan rows of the Limit operation will reflect this, but the plan rows of its child operations will not.",
    "Plan Width":
      "The\nestimated\naverage size of the rows produced by the operation, in\nbytes\n.",
    "Actual Startup Time":
      "The amount of time, in\nmilliseconds\n, it takes to get the first row out of the operation.\nSometimes, this is very close to the setup time — for example on a sequential scan which returns all the rows in a table.\nOther times, though, it’s more or less the total time. For example, in order to return the first row of a sort, you have to sort all of the rows to work out which one comes first.",
    "Actual Total Time":
      "The actual amount of time in milliseconds spent on this operation\nand all of its children\n. It’s a\nper-loop average\n, rounded to the nearest thousandth of a millisecond.\nWorking out individual operation timings, especially where CTEs and SubPlans are concerned, can be tricky. This is one of the main reasons we decided to build\npgMustard\n.",
    "Actual Rows":
      "The number of rows returned by the operation\nper loop\n.\nThe important thing to notice about this is that it’s an average of all the loops executed, rounded to the nearest integer. This means that while “Actual Loops” multiplied by “Actual Rows” is a pretty good approximation for total number of rows returned most of the time, it can be off by as much as half of the number of loops. Usually it’s just slightly confusing as you see a row or two appear or disappear between operations, but on operations with lots of loops there is potential for serious miscalculation.\nPoor row estimates, where Actual Rows differs substantially from Plan Rows, can lead to suboptimal query planning. Estimates can often be improved by running\nANALYZE\n(not the EXPLAIN parameter), by increasing statistics, or by allowing Postgres to understand correlation between columns using multivariate statistics.",
    "Actual Loops":
      "The number of times the operation is executed. For a lot of operations it will have a value of one, but when it is not, there are three different cases:\nSome operations can be executed more than once. For example, “Nested Loops” run their “Inner” child once for every row returned by their “Outer” child.\nWhen an operation that would normally only consist of one loop is split across multiple threads, each partial operation is counted as a Loop.\nThe number of loops can be zero when an operation doesn’t need to be executed at all. For example if a table read is planned to provide candidates for an inner join, but there turns out to be no rows on the other side of the join, the operation can be effectively eliminated.",
    Output:
      "A list of the columns returned by the operation.\nThis is only shown when VERBOSE is on.",
    "Shared Hit Blocks":
      "The number of blocks from indexes/tables that were found in the Postgres buffer cache.\nThis\nincludes\nvalues for child operations and is a\ntotal\nvalue (i.e. not a per-loop average).\nOnce you have subtracted child operation values, the proportion of shared hit to shared read blocks is an interesting measure of cache performance.\nThe ratio of shared blocks (hit plus read) to rows processed (including any filtered out) is also interesting: a high ratio means Postgres is reading a lot of data for what it is doing, which can be a sign of bloat.",
    "Shared Read Blocks":
      "The number of blocks from tables/indexes that were read from disk (or the OS cache).\nThis\nincludes\nvalues for child operations and is a\ntotal\nvalue (i.e. not per-loop).\nOnce you have subtracted child operation values, the proportion of shared hit to shared read blocks is an interesting measure of cache performance.\nThe ratio of shared blocks (hit plus read) to rows processed (including any filtered out) is also interesting: a high ratio means Postgres is reading a lot of data for what it is doing, which can be a sign of bloat.",
    "Shared Dirtied Blocks":
      "The number of blocks from tables/indexes that were modified by the operation.\nThis\nincludes\nvalues for child operations and is a\ntotal\nvalue (i.e. not per-loop).\nInterestingly, a SELECT query can report shared dirtied blocks when setting hint bits on recently-committed rows, or pruning old row versions. While somewhat surprising, both of these are perfectly normal and healthy.",
    "Shared Written Blocks":
      "The number of blocks from tables/indexes that were evicted from the cache.\nThis\nincludes\nvalues for child operations and is a\ntotal\nvalue (i.e. not a per-loop average).",
    "Local Hit Blocks":
      "The number of blocks from temporary tables and indexes that were found in the cache.\nThis\nincludes\nvalues for child operations and is a\ntotal\nvalue (not a per-loop average).",
    "Local Read Blocks":
      "The number of blocks read from\ntemporary tables and indexes that were not found in the Postgres cache (read from disk or the OS cache).\nThis\nincludes\nvalues for child operations and is a\ntotal\nvalue (not a per-loop average).",
    "Local Dirtied Blocks":
      "The number of blocks from\ntemporary tables and indexes that have been modified by the operation.\nThis\nincludes\nvalues for child operations and is a\ntotal\nvalue (i.e. not a per-loop average).",
    "Local Written Blocks":
      "The number of blocks from\ntemporary tables and indexes that were evicted from the cache.\nThis\nincludes\nvalues for child operations and is a\ntotal\nvalue (i.e. not a per-loop average).",
    "Temp Read Blocks":
      "The number of blocks read from short-term data used to calculate hashes, sorts, Materialize operations, and similar.\nThis\nincludes\nvalues for child operations and is a\ntotal\nvalue (i.e. not a per-loop average).\nYour settings of\nwork_mem\nand\nhash_mem_multiplier\ndetermine how much memory is available to Postgres per operation.",
    "Temp Written Blocks":
      "The number of blocks from short-term data (used to calculate operations like hashes, sorts, and materializes) that were evicted from the cache.\nThis\nincludes\nvalues for child operations and is a\ntotal\nvalue (i.e. not a per-loop average).\nYour settings of\nwork_mem\nand\nhash_mem_multiplier\ndetermine how much memory is available to Postgres per operation.",
    "Shared I/O Read Time":
      "The time spent reading data from tables and indexes, in\nmilliseconds\n.\nThis\nincludes\nvalues for child operations and is a total value (not a per-loop average).\nRequires\ntrack_io_timing\nand\nBUFFERS\nto be on.\nIn the latest version, the text format of explain displays this as\nI/O Timings: shared read\nIn PostgreSQL 15 and 16 it shows as a combined metric\nI/O Timings: shared/local read\nGetting timing information has an overhead, due to checking the system clock. You can use\npg_test_timing\nto measure this for your system.",
    "Shared I/O Write Time":
      "The time spent writing data for tables and indexes, in\nmilliseconds\n.\nThis\nincludes\nvalues for child operations and is a total value (not a per-loop average).\nRequires\ntrack_io_timing\nand\nBUFFERS\nto be on.\nIn the latest version, the text format of explain displays this as\nI/O Timings: shared write\nIn PostgreSQL 15 and 16 it shows as a combined metric\nI/O Timings: shared/local write\nGetting timing information has an overhead, due to checking the system clock. You can use\npg_test_timing\nto measure this for your system.",
    "Local I/O Read Time":
      "The time spent reading local data (e.g. from temporary tables and indexes), in\nmilliseconds\n.\nThis\nincludes\nvalues for child operations and is a total value (i.e. not a per-loop average).\nThis was added as a separate field in PostgreSQL 17, and requires both\ntrack_io_timing\nand\nBUFFERS\n.\nIn the default text format, this will show as\nI/O Timings: local read\nIn versions 15 and 16 it is available as a combined metric as\nshared/local\nGetting timing information has an overhead, due to checking the system clock. You can use\npg_test_timing\nto measure this for your system.",
    "Local I/O Write Time":
      "The time spent writing local data (e.g. for temporary tables and indexes), in\nmilliseconds\n.\nThis\nincludes\nvalues for child operations and is a total value (i.e. not a per-loop average).\nThis was added as a separate field in PostgreSQL 17, and requires both\ntrack_io_timing\nand\nBUFFERS\n.\nIn the default text format, this will show as\nI/O Timings: local write\nIn versions 15 and 16 it is available as a combined metric as\nshared/local\nGetting timing information has an overhead, due to checking the system clock. You can use\npg_test_timing\nto measure this for your system.",
    "Temp I/O Read Time":
      "The time spent reading short-term data, in\nmilliseconds\n(for example during sort and hash operations that were not done in memory).\nThis\nincludes\nvalues for child operations and is a total value (i.e. not a per-loop average).\nThis was added in PostgreSQL 15, and requires both\ntrack_io_timing\nand\nBUFFERS\n.\nIn the text format of explain, this shows as\nI/O Timings: temp read\nGetting timing information has an overhead, due to checking the system clock. You can use\npg_test_timing\nto measure this for your system.",
    "Temp I/O Write Time":
      "The time spent writing short-term data, in\nmilliseconds\n(for example during sort and hash operations that were not done in memory).\nThis\nincludes\nvalues for child operations and is a total value (i.e. not a per-loop average).\nThis was added in PostgreSQL 15, and requires both\ntrack_io_timing\nand\nBUFFERS\n.\nIn the text format of explain, this shows as\nI/O Timings: temp write\nGetting timing information has an overhead, due to checking the system clock. You can use\npg_test_timing\nto measure this for your system.",
  },
  "Recursive Union": {
    "Parent Relationship":
      "A guide as to why this operation needs to be run in order to facilitate the parent operation. There are six different possibilities:\nOuter\n: The value you’ll see most often. It means “take in the rows from this operation as input, process them and pass them on”.\nInner\n: Only ever seen on the second child of join operations, and is always seen there. This is the “inner” part of the loop — for each outer row, we look up its match using this operation.\nMember\n: Used for all children of Append and ModifyTable nodes, and on bitmap processing nodes like BitmapAnd and BitmapOr operations.\nInitPlan\n: Used for calculations performed before the query can start, eg a constant referred to in the query or the result of a CTE scan.\nSubquery\n: The child is a subquery of the parent operation. Since Postgres always uses subquery scans to feed subquery data to parent queries, only ever appears on the children of subquery scans.\nSubPlan\n: Like a Subquery, represents a new query, but used when a subquery scan is not necessary.",
    "Parallel Aware":
      "Whether or not the operation will be run in a special mode to support parallelism. Some operations need to be aware that they are running in parallel, for example sequential scans need to know they only need to scan a smaller proportion of the table. Other operations can be run on several threads without each one having any knowledge of the others.",
    "Startup Cost":
      "The estimated cost of returning the first row.\nThis is in an arbitrary unit, with the aim of being correlated to the startup time.",
    "Total Cost":
      "The estimated cost of returning all rows. This is in an arbitrary unit, with the aim of being correlated to the total time.\nThe Postgres query planner often has several ways it could resolve the same query. It calculates costs — which are hopefully correlated with the time it would take — for potential plans, and then picks the one with the lowest cost. It’s worth bearing in mind that the costs are unit-free — they’re not designed to convert into time, or disk reads. They’re just supposed to be bigger for slower operations, and smaller for faster ones.\nIf the planner thinks it can finish early due to a parent Limit operation, the total cost of the Limit operation will reflect this, but the total cost of its child operations will not.",
    "Plan Rows":
      "The number of rows,\nper-loop\n, that the planner expects to be returned by the operation.\nPoor row estimates can lead to suboptimal query planning. They can often be improved by running\nANALYZE\n(not the EXPLAIN parameter), by increasing statistics, or by allowing Postgres to understand correlation between columns using multivariate statistics.\nIf the planner thinks it can finish early due to a Limit operation, the plan rows of the Limit operation will reflect this, but the plan rows of its child operations will not.",
    "Plan Width":
      "The\nestimated\naverage size of the rows produced by the operation, in\nbytes\n.",
    "Actual Startup Time":
      "The amount of time, in\nmilliseconds\n, it takes to get the first row out of the operation.\nSometimes, this is very close to the setup time — for example on a sequential scan which returns all the rows in a table.\nOther times, though, it’s more or less the total time. For example, in order to return the first row of a sort, you have to sort all of the rows to work out which one comes first.",
    "Actual Total Time":
      "The actual amount of time in milliseconds spent on this operation\nand all of its children\n. It’s a\nper-loop average\n, rounded to the nearest thousandth of a millisecond.\nWorking out individual operation timings, especially where CTEs and SubPlans are concerned, can be tricky. This is one of the main reasons we decided to build\npgMustard\n.",
    "Actual Rows":
      "The number of rows returned by the operation\nper loop\n.\nThe important thing to notice about this is that it’s an average of all the loops executed, rounded to the nearest integer. This means that while “Actual Loops” multiplied by “Actual Rows” is a pretty good approximation for total number of rows returned most of the time, it can be off by as much as half of the number of loops. Usually it’s just slightly confusing as you see a row or two appear or disappear between operations, but on operations with lots of loops there is potential for serious miscalculation.\nPoor row estimates, where Actual Rows differs substantially from Plan Rows, can lead to suboptimal query planning. Estimates can often be improved by running\nANALYZE\n(not the EXPLAIN parameter), by increasing statistics, or by allowing Postgres to understand correlation between columns using multivariate statistics.",
    "Actual Loops":
      "The number of times the operation is executed. For a lot of operations it will have a value of one, but when it is not, there are three different cases:\nSome operations can be executed more than once. For example, “Nested Loops” run their “Inner” child once for every row returned by their “Outer” child.\nWhen an operation that would normally only consist of one loop is split across multiple threads, each partial operation is counted as a Loop.\nThe number of loops can be zero when an operation doesn’t need to be executed at all. For example if a table read is planned to provide candidates for an inner join, but there turns out to be no rows on the other side of the join, the operation can be effectively eliminated.",
    Output:
      "A list of the columns returned by the operation.\nThis is only shown when VERBOSE is on.",
    "Shared Hit Blocks":
      "The number of blocks from indexes/tables that were found in the Postgres buffer cache.\nThis\nincludes\nvalues for child operations and is a\ntotal\nvalue (i.e. not a per-loop average).\nOnce you have subtracted child operation values, the proportion of shared hit to shared read blocks is an interesting measure of cache performance.\nThe ratio of shared blocks (hit plus read) to rows processed (including any filtered out) is also interesting: a high ratio means Postgres is reading a lot of data for what it is doing, which can be a sign of bloat.",
    "Shared Read Blocks":
      "The number of blocks from tables/indexes that were read from disk (or the OS cache).\nThis\nincludes\nvalues for child operations and is a\ntotal\nvalue (i.e. not per-loop).\nOnce you have subtracted child operation values, the proportion of shared hit to shared read blocks is an interesting measure of cache performance.\nThe ratio of shared blocks (hit plus read) to rows processed (including any filtered out) is also interesting: a high ratio means Postgres is reading a lot of data for what it is doing, which can be a sign of bloat.",
    "Shared Dirtied Blocks":
      "The number of blocks from tables/indexes that were modified by the operation.\nThis\nincludes\nvalues for child operations and is a\ntotal\nvalue (i.e. not per-loop).\nInterestingly, a SELECT query can report shared dirtied blocks when setting hint bits on recently-committed rows, or pruning old row versions. While somewhat surprising, both of these are perfectly normal and healthy.",
    "Shared Written Blocks":
      "The number of blocks from tables/indexes that were evicted from the cache.\nThis\nincludes\nvalues for child operations and is a\ntotal\nvalue (i.e. not a per-loop average).",
    "Local Hit Blocks":
      "The number of blocks from temporary tables and indexes that were found in the cache.\nThis\nincludes\nvalues for child operations and is a\ntotal\nvalue (not a per-loop average).",
    "Local Read Blocks":
      "The number of blocks read from\ntemporary tables and indexes that were not found in the Postgres cache (read from disk or the OS cache).\nThis\nincludes\nvalues for child operations and is a\ntotal\nvalue (not a per-loop average).",
    "Local Dirtied Blocks":
      "The number of blocks from\ntemporary tables and indexes that have been modified by the operation.\nThis\nincludes\nvalues for child operations and is a\ntotal\nvalue (i.e. not a per-loop average).",
    "Local Written Blocks":
      "The number of blocks from\ntemporary tables and indexes that were evicted from the cache.\nThis\nincludes\nvalues for child operations and is a\ntotal\nvalue (i.e. not a per-loop average).",
    "Temp Read Blocks":
      "The number of blocks read from short-term data used to calculate hashes, sorts, Materialize operations, and similar.\nThis\nincludes\nvalues for child operations and is a\ntotal\nvalue (i.e. not a per-loop average).\nYour settings of\nwork_mem\nand\nhash_mem_multiplier\ndetermine how much memory is available to Postgres per operation.",
    "Temp Written Blocks":
      "The number of blocks from short-term data (used to calculate operations like hashes, sorts, and materializes) that were evicted from the cache.\nThis\nincludes\nvalues for child operations and is a\ntotal\nvalue (i.e. not a per-loop average).\nYour settings of\nwork_mem\nand\nhash_mem_multiplier\ndetermine how much memory is available to Postgres per operation.",
    "Shared I/O Read Time":
      "The time spent reading data from tables and indexes, in\nmilliseconds\n.\nThis\nincludes\nvalues for child operations and is a total value (not a per-loop average).\nRequires\ntrack_io_timing\nand\nBUFFERS\nto be on.\nIn the latest version, the text format of explain displays this as\nI/O Timings: shared read\nIn PostgreSQL 15 and 16 it shows as a combined metric\nI/O Timings: shared/local read\nGetting timing information has an overhead, due to checking the system clock. You can use\npg_test_timing\nto measure this for your system.",
    "Shared I/O Write Time":
      "The time spent writing data for tables and indexes, in\nmilliseconds\n.\nThis\nincludes\nvalues for child operations and is a total value (not a per-loop average).\nRequires\ntrack_io_timing\nand\nBUFFERS\nto be on.\nIn the latest version, the text format of explain displays this as\nI/O Timings: shared write\nIn PostgreSQL 15 and 16 it shows as a combined metric\nI/O Timings: shared/local write\nGetting timing information has an overhead, due to checking the system clock. You can use\npg_test_timing\nto measure this for your system.",
    "Local I/O Read Time":
      "The time spent reading local data (e.g. from temporary tables and indexes), in\nmilliseconds\n.\nThis\nincludes\nvalues for child operations and is a total value (i.e. not a per-loop average).\nThis was added as a separate field in PostgreSQL 17, and requires both\ntrack_io_timing\nand\nBUFFERS\n.\nIn the default text format, this will show as\nI/O Timings: local read\nIn versions 15 and 16 it is available as a combined metric as\nshared/local\nGetting timing information has an overhead, due to checking the system clock. You can use\npg_test_timing\nto measure this for your system.",
    "Local I/O Write Time":
      "The time spent writing local data (e.g. for temporary tables and indexes), in\nmilliseconds\n.\nThis\nincludes\nvalues for child operations and is a total value (i.e. not a per-loop average).\nThis was added as a separate field in PostgreSQL 17, and requires both\ntrack_io_timing\nand\nBUFFERS\n.\nIn the default text format, this will show as\nI/O Timings: local write\nIn versions 15 and 16 it is available as a combined metric as\nshared/local\nGetting timing information has an overhead, due to checking the system clock. You can use\npg_test_timing\nto measure this for your system.",
    "Temp I/O Read Time":
      "The time spent reading short-term data, in\nmilliseconds\n(for example during sort and hash operations that were not done in memory).\nThis\nincludes\nvalues for child operations and is a total value (i.e. not a per-loop average).\nThis was added in PostgreSQL 15, and requires both\ntrack_io_timing\nand\nBUFFERS\n.\nIn the text format of explain, this shows as\nI/O Timings: temp read\nGetting timing information has an overhead, due to checking the system clock. You can use\npg_test_timing\nto measure this for your system.",
    "Temp I/O Write Time":
      "The time spent writing short-term data, in\nmilliseconds\n(for example during sort and hash operations that were not done in memory).\nThis\nincludes\nvalues for child operations and is a total value (i.e. not a per-loop average).\nThis was added in PostgreSQL 15, and requires both\ntrack_io_timing\nand\nBUFFERS\n.\nIn the text format of explain, this shows as\nI/O Timings: temp write\nGetting timing information has an overhead, due to checking the system clock. You can use\npg_test_timing\nto measure this for your system.",
  },
  Result: {
    "Parent Relationship":
      "A guide as to why this operation needs to be run in order to facilitate the parent operation. There are six different possibilities:\nOuter\n: The value you’ll see most often. It means “take in the rows from this operation as input, process them and pass them on”.\nInner\n: Only ever seen on the second child of join operations, and is always seen there. This is the “inner” part of the loop — for each outer row, we look up its match using this operation.\nMember\n: Used for all children of Append and ModifyTable nodes, and on bitmap processing nodes like BitmapAnd and BitmapOr operations.\nInitPlan\n: Used for calculations performed before the query can start, eg a constant referred to in the query or the result of a CTE scan.\nSubquery\n: The child is a subquery of the parent operation. Since Postgres always uses subquery scans to feed subquery data to parent queries, only ever appears on the children of subquery scans.\nSubPlan\n: Like a Subquery, represents a new query, but used when a subquery scan is not necessary.",
    "Parallel Aware":
      "Whether or not the operation will be run in a special mode to support parallelism. Some operations need to be aware that they are running in parallel, for example sequential scans need to know they only need to scan a smaller proportion of the table. Other operations can be run on several threads without each one having any knowledge of the others.",
    "Startup Cost":
      "The estimated cost of returning the first row.\nThis is in an arbitrary unit, with the aim of being correlated to the startup time.",
    "Total Cost":
      "The estimated cost of returning all rows. This is in an arbitrary unit, with the aim of being correlated to the total time.\nThe Postgres query planner often has several ways it could resolve the same query. It calculates costs — which are hopefully correlated with the time it would take — for potential plans, and then picks the one with the lowest cost. It’s worth bearing in mind that the costs are unit-free — they’re not designed to convert into time, or disk reads. They’re just supposed to be bigger for slower operations, and smaller for faster ones.\nIf the planner thinks it can finish early due to a parent Limit operation, the total cost of the Limit operation will reflect this, but the total cost of its child operations will not.",
    "Plan Rows":
      "The number of rows,\nper-loop\n, that the planner expects to be returned by the operation.\nPoor row estimates can lead to suboptimal query planning. They can often be improved by running\nANALYZE\n(not the EXPLAIN parameter), by increasing statistics, or by allowing Postgres to understand correlation between columns using multivariate statistics.\nIf the planner thinks it can finish early due to a Limit operation, the plan rows of the Limit operation will reflect this, but the plan rows of its child operations will not.",
    "Plan Width":
      "The\nestimated\naverage size of the rows produced by the operation, in\nbytes\n.",
    "Actual Startup Time":
      "The amount of time, in\nmilliseconds\n, it takes to get the first row out of the operation.\nSometimes, this is very close to the setup time — for example on a sequential scan which returns all the rows in a table.\nOther times, though, it’s more or less the total time. For example, in order to return the first row of a sort, you have to sort all of the rows to work out which one comes first.",
    "Actual Total Time":
      "The actual amount of time in milliseconds spent on this operation\nand all of its children\n. It’s a\nper-loop average\n, rounded to the nearest thousandth of a millisecond.\nWorking out individual operation timings, especially where CTEs and SubPlans are concerned, can be tricky. This is one of the main reasons we decided to build\npgMustard\n.",
    "Actual Rows":
      "The number of rows returned by the operation\nper loop\n.\nThe important thing to notice about this is that it’s an average of all the loops executed, rounded to the nearest integer. This means that while “Actual Loops” multiplied by “Actual Rows” is a pretty good approximation for total number of rows returned most of the time, it can be off by as much as half of the number of loops. Usually it’s just slightly confusing as you see a row or two appear or disappear between operations, but on operations with lots of loops there is potential for serious miscalculation.\nPoor row estimates, where Actual Rows differs substantially from Plan Rows, can lead to suboptimal query planning. Estimates can often be improved by running\nANALYZE\n(not the EXPLAIN parameter), by increasing statistics, or by allowing Postgres to understand correlation between columns using multivariate statistics.",
    "Actual Loops":
      "The number of times the operation is executed. For a lot of operations it will have a value of one, but when it is not, there are three different cases:\nSome operations can be executed more than once. For example, “Nested Loops” run their “Inner” child once for every row returned by their “Outer” child.\nWhen an operation that would normally only consist of one loop is split across multiple threads, each partial operation is counted as a Loop.\nThe number of loops can be zero when an operation doesn’t need to be executed at all. For example if a table read is planned to provide candidates for an inner join, but there turns out to be no rows on the other side of the join, the operation can be effectively eliminated.",
    Output:
      "A list of the columns returned by the operation.\nThis is only shown when VERBOSE is on.",
    "One-Time Filter":
      "A qualification used by a Result operation.\nIf it is false, an empty result set can be returned without further work.",
    "Shared Hit Blocks":
      "The number of blocks from indexes/tables that were found in the Postgres buffer cache.\nThis\nincludes\nvalues for child operations and is a\ntotal\nvalue (i.e. not a per-loop average).\nOnce you have subtracted child operation values, the proportion of shared hit to shared read blocks is an interesting measure of cache performance.\nThe ratio of shared blocks (hit plus read) to rows processed (including any filtered out) is also interesting: a high ratio means Postgres is reading a lot of data for what it is doing, which can be a sign of bloat.",
    "Shared Read Blocks":
      "The number of blocks from tables/indexes that were read from disk (or the OS cache).\nThis\nincludes\nvalues for child operations and is a\ntotal\nvalue (i.e. not per-loop).\nOnce you have subtracted child operation values, the proportion of shared hit to shared read blocks is an interesting measure of cache performance.\nThe ratio of shared blocks (hit plus read) to rows processed (including any filtered out) is also interesting: a high ratio means Postgres is reading a lot of data for what it is doing, which can be a sign of bloat.",
    "Shared Dirtied Blocks":
      "The number of blocks from tables/indexes that were modified by the operation.\nThis\nincludes\nvalues for child operations and is a\ntotal\nvalue (i.e. not per-loop).\nInterestingly, a SELECT query can report shared dirtied blocks when setting hint bits on recently-committed rows, or pruning old row versions. While somewhat surprising, both of these are perfectly normal and healthy.",
    "Shared Written Blocks":
      "The number of blocks from tables/indexes that were evicted from the cache.\nThis\nincludes\nvalues for child operations and is a\ntotal\nvalue (i.e. not a per-loop average).",
    "Local Hit Blocks":
      "The number of blocks from temporary tables and indexes that were found in the cache.\nThis\nincludes\nvalues for child operations and is a\ntotal\nvalue (not a per-loop average).",
    "Local Read Blocks":
      "The number of blocks read from\ntemporary tables and indexes that were not found in the Postgres cache (read from disk or the OS cache).\nThis\nincludes\nvalues for child operations and is a\ntotal\nvalue (not a per-loop average).",
    "Local Dirtied Blocks":
      "The number of blocks from\ntemporary tables and indexes that have been modified by the operation.\nThis\nincludes\nvalues for child operations and is a\ntotal\nvalue (i.e. not a per-loop average).",
    "Local Written Blocks":
      "The number of blocks from\ntemporary tables and indexes that were evicted from the cache.\nThis\nincludes\nvalues for child operations and is a\ntotal\nvalue (i.e. not a per-loop average).",
    "Temp Read Blocks":
      "The number of blocks read from short-term data used to calculate hashes, sorts, Materialize operations, and similar.\nThis\nincludes\nvalues for child operations and is a\ntotal\nvalue (i.e. not a per-loop average).\nYour settings of\nwork_mem\nand\nhash_mem_multiplier\ndetermine how much memory is available to Postgres per operation.",
    "Temp Written Blocks":
      "The number of blocks from short-term data (used to calculate operations like hashes, sorts, and materializes) that were evicted from the cache.\nThis\nincludes\nvalues for child operations and is a\ntotal\nvalue (i.e. not a per-loop average).\nYour settings of\nwork_mem\nand\nhash_mem_multiplier\ndetermine how much memory is available to Postgres per operation.",
    "Shared I/O Read Time":
      "The time spent reading data from tables and indexes, in\nmilliseconds\n.\nThis\nincludes\nvalues for child operations and is a total value (not a per-loop average).\nRequires\ntrack_io_timing\nand\nBUFFERS\nto be on.\nIn the latest version, the text format of explain displays this as\nI/O Timings: shared read\nIn PostgreSQL 15 and 16 it shows as a combined metric\nI/O Timings: shared/local read\nGetting timing information has an overhead, due to checking the system clock. You can use\npg_test_timing\nto measure this for your system.",
    "Shared I/O Write Time":
      "The time spent writing data for tables and indexes, in\nmilliseconds\n.\nThis\nincludes\nvalues for child operations and is a total value (not a per-loop average).\nRequires\ntrack_io_timing\nand\nBUFFERS\nto be on.\nIn the latest version, the text format of explain displays this as\nI/O Timings: shared write\nIn PostgreSQL 15 and 16 it shows as a combined metric\nI/O Timings: shared/local write\nGetting timing information has an overhead, due to checking the system clock. You can use\npg_test_timing\nto measure this for your system.",
    "Local I/O Read Time":
      "The time spent reading local data (e.g. from temporary tables and indexes), in\nmilliseconds\n.\nThis\nincludes\nvalues for child operations and is a total value (i.e. not a per-loop average).\nThis was added as a separate field in PostgreSQL 17, and requires both\ntrack_io_timing\nand\nBUFFERS\n.\nIn the default text format, this will show as\nI/O Timings: local read\nIn versions 15 and 16 it is available as a combined metric as\nshared/local\nGetting timing information has an overhead, due to checking the system clock. You can use\npg_test_timing\nto measure this for your system.",
    "Local I/O Write Time":
      "The time spent writing local data (e.g. for temporary tables and indexes), in\nmilliseconds\n.\nThis\nincludes\nvalues for child operations and is a total value (i.e. not a per-loop average).\nThis was added as a separate field in PostgreSQL 17, and requires both\ntrack_io_timing\nand\nBUFFERS\n.\nIn the default text format, this will show as\nI/O Timings: local write\nIn versions 15 and 16 it is available as a combined metric as\nshared/local\nGetting timing information has an overhead, due to checking the system clock. You can use\npg_test_timing\nto measure this for your system.",
    "Temp I/O Read Time":
      "The time spent reading short-term data, in\nmilliseconds\n(for example during sort and hash operations that were not done in memory).\nThis\nincludes\nvalues for child operations and is a total value (i.e. not a per-loop average).\nThis was added in PostgreSQL 15, and requires both\ntrack_io_timing\nand\nBUFFERS\n.\nIn the text format of explain, this shows as\nI/O Timings: temp read\nGetting timing information has an overhead, due to checking the system clock. You can use\npg_test_timing\nto measure this for your system.",
    "Temp I/O Write Time":
      "The time spent writing short-term data, in\nmilliseconds\n(for example during sort and hash operations that were not done in memory).\nThis\nincludes\nvalues for child operations and is a total value (i.e. not a per-loop average).\nThis was added in PostgreSQL 15, and requires both\ntrack_io_timing\nand\nBUFFERS\n.\nIn the text format of explain, this shows as\nI/O Timings: temp write\nGetting timing information has an overhead, due to checking the system clock. You can use\npg_test_timing\nto measure this for your system.",
  },
  SetOp: {
    Strategy:
      "Which strategy of aggregation was performed: Plain, Hashed, Sorted, or Mixed.\nIn non-text format query plans, this lets you see whether Postgres is doing a HashAggregate (Hashed), a GroupAggregate (Sorted), or a MixedAggregate (Mixed).",
    "Parent Relationship":
      "A guide as to why this operation needs to be run in order to facilitate the parent operation. There are six different possibilities:\nOuter\n: The value you’ll see most often. It means “take in the rows from this operation as input, process them and pass them on”.\nInner\n: Only ever seen on the second child of join operations, and is always seen there. This is the “inner” part of the loop — for each outer row, we look up its match using this operation.\nMember\n: Used for all children of Append and ModifyTable nodes, and on bitmap processing nodes like BitmapAnd and BitmapOr operations.\nInitPlan\n: Used for calculations performed before the query can start, eg a constant referred to in the query or the result of a CTE scan.\nSubquery\n: The child is a subquery of the parent operation. Since Postgres always uses subquery scans to feed subquery data to parent queries, only ever appears on the children of subquery scans.\nSubPlan\n: Like a Subquery, represents a new query, but used when a subquery scan is not necessary.",
    "Parallel Aware":
      "Whether or not the operation will be run in a special mode to support parallelism. Some operations need to be aware that they are running in parallel, for example sequential scans need to know they only need to scan a smaller proportion of the table. Other operations can be run on several threads without each one having any knowledge of the others.",
    Command:
      "The set operation:\nIntersect\nor\nExcept\n.\nUNION operations are handled by Append.",
    "Startup Cost":
      "The estimated cost of returning the first row.\nThis is in an arbitrary unit, with the aim of being correlated to the startup time.",
    "Total Cost":
      "The estimated cost of returning all rows. This is in an arbitrary unit, with the aim of being correlated to the total time.\nThe Postgres query planner often has several ways it could resolve the same query. It calculates costs — which are hopefully correlated with the time it would take — for potential plans, and then picks the one with the lowest cost. It’s worth bearing in mind that the costs are unit-free — they’re not designed to convert into time, or disk reads. They’re just supposed to be bigger for slower operations, and smaller for faster ones.\nIf the planner thinks it can finish early due to a parent Limit operation, the total cost of the Limit operation will reflect this, but the total cost of its child operations will not.",
    "Plan Rows":
      "The number of rows,\nper-loop\n, that the planner expects to be returned by the operation.\nPoor row estimates can lead to suboptimal query planning. They can often be improved by running\nANALYZE\n(not the EXPLAIN parameter), by increasing statistics, or by allowing Postgres to understand correlation between columns using multivariate statistics.\nIf the planner thinks it can finish early due to a Limit operation, the plan rows of the Limit operation will reflect this, but the plan rows of its child operations will not.",
    "Plan Width":
      "The\nestimated\naverage size of the rows produced by the operation, in\nbytes\n.",
    "Actual Startup Time":
      "The amount of time, in\nmilliseconds\n, it takes to get the first row out of the operation.\nSometimes, this is very close to the setup time — for example on a sequential scan which returns all the rows in a table.\nOther times, though, it’s more or less the total time. For example, in order to return the first row of a sort, you have to sort all of the rows to work out which one comes first.",
    "Actual Total Time":
      "The actual amount of time in milliseconds spent on this operation\nand all of its children\n. It’s a\nper-loop average\n, rounded to the nearest thousandth of a millisecond.\nWorking out individual operation timings, especially where CTEs and SubPlans are concerned, can be tricky. This is one of the main reasons we decided to build\npgMustard\n.",
    "Actual Rows":
      "The number of rows returned by the operation\nper loop\n.\nThe important thing to notice about this is that it’s an average of all the loops executed, rounded to the nearest integer. This means that while “Actual Loops” multiplied by “Actual Rows” is a pretty good approximation for total number of rows returned most of the time, it can be off by as much as half of the number of loops. Usually it’s just slightly confusing as you see a row or two appear or disappear between operations, but on operations with lots of loops there is potential for serious miscalculation.\nPoor row estimates, where Actual Rows differs substantially from Plan Rows, can lead to suboptimal query planning. Estimates can often be improved by running\nANALYZE\n(not the EXPLAIN parameter), by increasing statistics, or by allowing Postgres to understand correlation between columns using multivariate statistics.",
    "Actual Loops":
      "The number of times the operation is executed. For a lot of operations it will have a value of one, but when it is not, there are three different cases:\nSome operations can be executed more than once. For example, “Nested Loops” run their “Inner” child once for every row returned by their “Outer” child.\nWhen an operation that would normally only consist of one loop is split across multiple threads, each partial operation is counted as a Loop.\nThe number of loops can be zero when an operation doesn’t need to be executed at all. For example if a table read is planned to provide candidates for an inner join, but there turns out to be no rows on the other side of the join, the operation can be effectively eliminated.",
    Output:
      "A list of the columns returned by the operation.\nThis is only shown when VERBOSE is on.",
    "Shared Hit Blocks":
      "The number of blocks from indexes/tables that were found in the Postgres buffer cache.\nThis\nincludes\nvalues for child operations and is a\ntotal\nvalue (i.e. not a per-loop average).\nOnce you have subtracted child operation values, the proportion of shared hit to shared read blocks is an interesting measure of cache performance.\nThe ratio of shared blocks (hit plus read) to rows processed (including any filtered out) is also interesting: a high ratio means Postgres is reading a lot of data for what it is doing, which can be a sign of bloat.",
    "Shared Read Blocks":
      "The number of blocks from tables/indexes that were read from disk (or the OS cache).\nThis\nincludes\nvalues for child operations and is a\ntotal\nvalue (i.e. not per-loop).\nOnce you have subtracted child operation values, the proportion of shared hit to shared read blocks is an interesting measure of cache performance.\nThe ratio of shared blocks (hit plus read) to rows processed (including any filtered out) is also interesting: a high ratio means Postgres is reading a lot of data for what it is doing, which can be a sign of bloat.",
    "Shared Dirtied Blocks":
      "The number of blocks from tables/indexes that were modified by the operation.\nThis\nincludes\nvalues for child operations and is a\ntotal\nvalue (i.e. not per-loop).\nInterestingly, a SELECT query can report shared dirtied blocks when setting hint bits on recently-committed rows, or pruning old row versions. While somewhat surprising, both of these are perfectly normal and healthy.",
    "Shared Written Blocks":
      "The number of blocks from tables/indexes that were evicted from the cache.\nThis\nincludes\nvalues for child operations and is a\ntotal\nvalue (i.e. not a per-loop average).",
    "Local Hit Blocks":
      "The number of blocks from temporary tables and indexes that were found in the cache.\nThis\nincludes\nvalues for child operations and is a\ntotal\nvalue (not a per-loop average).",
    "Local Read Blocks":
      "The number of blocks read from\ntemporary tables and indexes that were not found in the Postgres cache (read from disk or the OS cache).\nThis\nincludes\nvalues for child operations and is a\ntotal\nvalue (not a per-loop average).",
    "Local Dirtied Blocks":
      "The number of blocks from\ntemporary tables and indexes that have been modified by the operation.\nThis\nincludes\nvalues for child operations and is a\ntotal\nvalue (i.e. not a per-loop average).",
    "Local Written Blocks":
      "The number of blocks from\ntemporary tables and indexes that were evicted from the cache.\nThis\nincludes\nvalues for child operations and is a\ntotal\nvalue (i.e. not a per-loop average).",
    "Temp Read Blocks":
      "The number of blocks read from short-term data used to calculate hashes, sorts, Materialize operations, and similar.\nThis\nincludes\nvalues for child operations and is a\ntotal\nvalue (i.e. not a per-loop average).\nYour settings of\nwork_mem\nand\nhash_mem_multiplier\ndetermine how much memory is available to Postgres per operation.",
    "Temp Written Blocks":
      "The number of blocks from short-term data (used to calculate operations like hashes, sorts, and materializes) that were evicted from the cache.\nThis\nincludes\nvalues for child operations and is a\ntotal\nvalue (i.e. not a per-loop average).\nYour settings of\nwork_mem\nand\nhash_mem_multiplier\ndetermine how much memory is available to Postgres per operation.",
    "Shared I/O Read Time":
      "The time spent reading data from tables and indexes, in\nmilliseconds\n.\nThis\nincludes\nvalues for child operations and is a total value (not a per-loop average).\nRequires\ntrack_io_timing\nand\nBUFFERS\nto be on.\nIn the latest version, the text format of explain displays this as\nI/O Timings: shared read\nIn PostgreSQL 15 and 16 it shows as a combined metric\nI/O Timings: shared/local read\nGetting timing information has an overhead, due to checking the system clock. You can use\npg_test_timing\nto measure this for your system.",
    "Shared I/O Write Time":
      "The time spent writing data for tables and indexes, in\nmilliseconds\n.\nThis\nincludes\nvalues for child operations and is a total value (not a per-loop average).\nRequires\ntrack_io_timing\nand\nBUFFERS\nto be on.\nIn the latest version, the text format of explain displays this as\nI/O Timings: shared write\nIn PostgreSQL 15 and 16 it shows as a combined metric\nI/O Timings: shared/local write\nGetting timing information has an overhead, due to checking the system clock. You can use\npg_test_timing\nto measure this for your system.",
    "Local I/O Read Time":
      "The time spent reading local data (e.g. from temporary tables and indexes), in\nmilliseconds\n.\nThis\nincludes\nvalues for child operations and is a total value (i.e. not a per-loop average).\nThis was added as a separate field in PostgreSQL 17, and requires both\ntrack_io_timing\nand\nBUFFERS\n.\nIn the default text format, this will show as\nI/O Timings: local read\nIn versions 15 and 16 it is available as a combined metric as\nshared/local\nGetting timing information has an overhead, due to checking the system clock. You can use\npg_test_timing\nto measure this for your system.",
    "Local I/O Write Time":
      "The time spent writing local data (e.g. for temporary tables and indexes), in\nmilliseconds\n.\nThis\nincludes\nvalues for child operations and is a total value (i.e. not a per-loop average).\nThis was added as a separate field in PostgreSQL 17, and requires both\ntrack_io_timing\nand\nBUFFERS\n.\nIn the default text format, this will show as\nI/O Timings: local write\nIn versions 15 and 16 it is available as a combined metric as\nshared/local\nGetting timing information has an overhead, due to checking the system clock. You can use\npg_test_timing\nto measure this for your system.",
    "Temp I/O Read Time":
      "The time spent reading short-term data, in\nmilliseconds\n(for example during sort and hash operations that were not done in memory).\nThis\nincludes\nvalues for child operations and is a total value (i.e. not a per-loop average).\nThis was added in PostgreSQL 15, and requires both\ntrack_io_timing\nand\nBUFFERS\n.\nIn the text format of explain, this shows as\nI/O Timings: temp read\nGetting timing information has an overhead, due to checking the system clock. You can use\npg_test_timing\nto measure this for your system.",
    "Temp I/O Write Time":
      "The time spent writing short-term data, in\nmilliseconds\n(for example during sort and hash operations that were not done in memory).\nThis\nincludes\nvalues for child operations and is a total value (i.e. not a per-loop average).\nThis was added in PostgreSQL 15, and requires both\ntrack_io_timing\nand\nBUFFERS\n.\nIn the text format of explain, this shows as\nI/O Timings: temp write\nGetting timing information has an overhead, due to checking the system clock. You can use\npg_test_timing\nto measure this for your system.",
  },
  Sort: {
    "Parent Relationship":
      "A guide as to why this operation needs to be run in order to facilitate the parent operation. There are six different possibilities:\nOuter\n: The value you’ll see most often. It means “take in the rows from this operation as input, process them and pass them on”.\nInner\n: Only ever seen on the second child of join operations, and is always seen there. This is the “inner” part of the loop — for each outer row, we look up its match using this operation.\nMember\n: Used for all children of Append and ModifyTable nodes, and on bitmap processing nodes like BitmapAnd and BitmapOr operations.\nInitPlan\n: Used for calculations performed before the query can start, eg a constant referred to in the query or the result of a CTE scan.\nSubquery\n: The child is a subquery of the parent operation. Since Postgres always uses subquery scans to feed subquery data to parent queries, only ever appears on the children of subquery scans.\nSubPlan\n: Like a Subquery, represents a new query, but used when a subquery scan is not necessary.",
    "Parallel Aware":
      "Whether or not the operation will be run in a special mode to support parallelism. Some operations need to be aware that they are running in parallel, for example sequential scans need to know they only need to scan a smaller proportion of the table. Other operations can be run on several threads without each one having any knowledge of the others.",
    "Startup Cost":
      "The estimated cost of returning the first row.\nThis is in an arbitrary unit, with the aim of being correlated to the startup time.",
    "Total Cost":
      "The estimated cost of returning all rows. This is in an arbitrary unit, with the aim of being correlated to the total time.\nThe Postgres query planner often has several ways it could resolve the same query. It calculates costs — which are hopefully correlated with the time it would take — for potential plans, and then picks the one with the lowest cost. It’s worth bearing in mind that the costs are unit-free — they’re not designed to convert into time, or disk reads. They’re just supposed to be bigger for slower operations, and smaller for faster ones.\nIf the planner thinks it can finish early due to a parent Limit operation, the total cost of the Limit operation will reflect this, but the total cost of its child operations will not.",
    "Plan Rows":
      "The number of rows,\nper-loop\n, that the planner expects to be returned by the operation.\nPoor row estimates can lead to suboptimal query planning. They can often be improved by running\nANALYZE\n(not the EXPLAIN parameter), by increasing statistics, or by allowing Postgres to understand correlation between columns using multivariate statistics.\nIf the planner thinks it can finish early due to a Limit operation, the plan rows of the Limit operation will reflect this, but the plan rows of its child operations will not.",
    "Plan Width":
      "The\nestimated\naverage size of the rows produced by the operation, in\nbytes\n.",
    "Actual Startup Time":
      "The amount of time, in\nmilliseconds\n, it takes to get the first row out of the operation.\nSometimes, this is very close to the setup time — for example on a sequential scan which returns all the rows in a table.\nOther times, though, it’s more or less the total time. For example, in order to return the first row of a sort, you have to sort all of the rows to work out which one comes first.",
    "Actual Total Time":
      "The actual amount of time in milliseconds spent on this operation\nand all of its children\n. It’s a\nper-loop average\n, rounded to the nearest thousandth of a millisecond.\nWorking out individual operation timings, especially where CTEs and SubPlans are concerned, can be tricky. This is one of the main reasons we decided to build\npgMustard\n.",
    "Actual Rows":
      "The number of rows returned by the operation\nper loop\n.\nThe important thing to notice about this is that it’s an average of all the loops executed, rounded to the nearest integer. This means that while “Actual Loops” multiplied by “Actual Rows” is a pretty good approximation for total number of rows returned most of the time, it can be off by as much as half of the number of loops. Usually it’s just slightly confusing as you see a row or two appear or disappear between operations, but on operations with lots of loops there is potential for serious miscalculation.\nPoor row estimates, where Actual Rows differs substantially from Plan Rows, can lead to suboptimal query planning. Estimates can often be improved by running\nANALYZE\n(not the EXPLAIN parameter), by increasing statistics, or by allowing Postgres to understand correlation between columns using multivariate statistics.",
    "Actual Loops":
      "The number of times the operation is executed. For a lot of operations it will have a value of one, but when it is not, there are three different cases:\nSome operations can be executed more than once. For example, “Nested Loops” run their “Inner” child once for every row returned by their “Outer” child.\nWhen an operation that would normally only consist of one loop is split across multiple threads, each partial operation is counted as a Loop.\nThe number of loops can be zero when an operation doesn’t need to be executed at all. For example if a table read is planned to provide candidates for an inner join, but there turns out to be no rows on the other side of the join, the operation can be effectively eliminated.",
    Output:
      "A list of the columns returned by the operation.\nThis is only shown when VERBOSE is on.",
    "Sort Key":
      "The order by condition.\nIf the sort is by a single column, or multiple columns from the same table, you may be able to avoid the sort entirely by adding an index with the desired order.",
    "Sort Method":
      "If the memory it requires is lower than your\nwork_mem\nsetting, Postgres can use a\nquicksort\n, or (if there is a LIMIT) a\ntop-N heapsort\n.\nOtherwise, it will do an\nexternal\nsort on-disk, which is slow but may be necessary for a large sort. If the sort is by a single column, or multiple columns from the same table, you may be able to avoid it entirely by adding an index with the desired order.\nAn external sort has a lower footprint than a quicksort, so it is possible to see external sorts with\nsort space used\nlower than\nwork_mem\n.",
    "Sort Space Used":
      "The amount of memory or disk space, in\nKB\n, used for the sort.\nAn external sort has a lower footprint than a quicksort, so it is possible to see external sorts with sort space used lower than\nwork_mem\n.",
    "Sort Space Type":
      "Whether the sort was done in\nmemory\nor on\ndisk\n.\nOn-disk sorts have a lower footprint than in-memory sorts, so it is possible to see on-disk sorts with\nsort space used\nlower than\nwork_mem\n.",
    "Shared Hit Blocks":
      "The number of blocks from indexes/tables that were found in the Postgres buffer cache.\nThis\nincludes\nvalues for child operations and is a\ntotal\nvalue (i.e. not a per-loop average).\nOnce you have subtracted child operation values, the proportion of shared hit to shared read blocks is an interesting measure of cache performance.\nThe ratio of shared blocks (hit plus read) to rows processed (including any filtered out) is also interesting: a high ratio means Postgres is reading a lot of data for what it is doing, which can be a sign of bloat.",
    "Shared Read Blocks":
      "The number of blocks from tables/indexes that were read from disk (or the OS cache).\nThis\nincludes\nvalues for child operations and is a\ntotal\nvalue (i.e. not per-loop).\nOnce you have subtracted child operation values, the proportion of shared hit to shared read blocks is an interesting measure of cache performance.\nThe ratio of shared blocks (hit plus read) to rows processed (including any filtered out) is also interesting: a high ratio means Postgres is reading a lot of data for what it is doing, which can be a sign of bloat.",
    "Shared Dirtied Blocks":
      "The number of blocks from tables/indexes that were modified by the operation.\nThis\nincludes\nvalues for child operations and is a\ntotal\nvalue (i.e. not per-loop).\nInterestingly, a SELECT query can report shared dirtied blocks when setting hint bits on recently-committed rows, or pruning old row versions. While somewhat surprising, both of these are perfectly normal and healthy.",
    "Shared Written Blocks":
      "The number of blocks from tables/indexes that were evicted from the cache.\nThis\nincludes\nvalues for child operations and is a\ntotal\nvalue (i.e. not a per-loop average).",
    "Local Hit Blocks":
      "The number of blocks from temporary tables and indexes that were found in the cache.\nThis\nincludes\nvalues for child operations and is a\ntotal\nvalue (not a per-loop average).",
    "Local Read Blocks":
      "The number of blocks read from\ntemporary tables and indexes that were not found in the Postgres cache (read from disk or the OS cache).\nThis\nincludes\nvalues for child operations and is a\ntotal\nvalue (not a per-loop average).",
    "Local Dirtied Blocks":
      "The number of blocks from\ntemporary tables and indexes that have been modified by the operation.\nThis\nincludes\nvalues for child operations and is a\ntotal\nvalue (i.e. not a per-loop average).",
    "Local Written Blocks":
      "The number of blocks from\ntemporary tables and indexes that were evicted from the cache.\nThis\nincludes\nvalues for child operations and is a\ntotal\nvalue (i.e. not a per-loop average).",
    "Temp Read Blocks":
      "The number of blocks read from short-term data used to calculate hashes, sorts, Materialize operations, and similar.\nThis\nincludes\nvalues for child operations and is a\ntotal\nvalue (i.e. not a per-loop average).\nYour settings of\nwork_mem\nand\nhash_mem_multiplier\ndetermine how much memory is available to Postgres per operation.",
    "Temp Written Blocks":
      "The number of blocks from short-term data (used to calculate operations like hashes, sorts, and materializes) that were evicted from the cache.\nThis\nincludes\nvalues for child operations and is a\ntotal\nvalue (i.e. not a per-loop average).\nYour settings of\nwork_mem\nand\nhash_mem_multiplier\ndetermine how much memory is available to Postgres per operation.",
    "Shared I/O Read Time":
      "The time spent reading data from tables and indexes, in\nmilliseconds\n.\nThis\nincludes\nvalues for child operations and is a total value (not a per-loop average).\nRequires\ntrack_io_timing\nand\nBUFFERS\nto be on.\nIn the latest version, the text format of explain displays this as\nI/O Timings: shared read\nIn PostgreSQL 15 and 16 it shows as a combined metric\nI/O Timings: shared/local read\nGetting timing information has an overhead, due to checking the system clock. You can use\npg_test_timing\nto measure this for your system.",
    "Shared I/O Write Time":
      "The time spent writing data for tables and indexes, in\nmilliseconds\n.\nThis\nincludes\nvalues for child operations and is a total value (not a per-loop average).\nRequires\ntrack_io_timing\nand\nBUFFERS\nto be on.\nIn the latest version, the text format of explain displays this as\nI/O Timings: shared write\nIn PostgreSQL 15 and 16 it shows as a combined metric\nI/O Timings: shared/local write\nGetting timing information has an overhead, due to checking the system clock. You can use\npg_test_timing\nto measure this for your system.",
    "Local I/O Read Time":
      "The time spent reading local data (e.g. from temporary tables and indexes), in\nmilliseconds\n.\nThis\nincludes\nvalues for child operations and is a total value (i.e. not a per-loop average).\nThis was added as a separate field in PostgreSQL 17, and requires both\ntrack_io_timing\nand\nBUFFERS\n.\nIn the default text format, this will show as\nI/O Timings: local read\nIn versions 15 and 16 it is available as a combined metric as\nshared/local\nGetting timing information has an overhead, due to checking the system clock. You can use\npg_test_timing\nto measure this for your system.",
    "Local I/O Write Time":
      "The time spent writing local data (e.g. for temporary tables and indexes), in\nmilliseconds\n.\nThis\nincludes\nvalues for child operations and is a total value (i.e. not a per-loop average).\nThis was added as a separate field in PostgreSQL 17, and requires both\ntrack_io_timing\nand\nBUFFERS\n.\nIn the default text format, this will show as\nI/O Timings: local write\nIn versions 15 and 16 it is available as a combined metric as\nshared/local\nGetting timing information has an overhead, due to checking the system clock. You can use\npg_test_timing\nto measure this for your system.",
    "Temp I/O Read Time":
      "The time spent reading short-term data, in\nmilliseconds\n(for example during sort and hash operations that were not done in memory).\nThis\nincludes\nvalues for child operations and is a total value (i.e. not a per-loop average).\nThis was added in PostgreSQL 15, and requires both\ntrack_io_timing\nand\nBUFFERS\n.\nIn the text format of explain, this shows as\nI/O Timings: temp read\nGetting timing information has an overhead, due to checking the system clock. You can use\npg_test_timing\nto measure this for your system.",
    "Temp I/O Write Time":
      "The time spent writing short-term data, in\nmilliseconds\n(for example during sort and hash operations that were not done in memory).\nThis\nincludes\nvalues for child operations and is a total value (i.e. not a per-loop average).\nThis was added in PostgreSQL 15, and requires both\ntrack_io_timing\nand\nBUFFERS\n.\nIn the text format of explain, this shows as\nI/O Timings: temp write\nGetting timing information has an overhead, due to checking the system clock. You can use\npg_test_timing\nto measure this for your system.",
    Workers:
      "A summary of the operation detail broken down by thread.\nThese entries\ndon’t\ninclude the main (or leader) thread.\nYou can work out the values for the main thread by subtracting the worker statistics from the total.\nThis information is only shown when VERBOSE is on.",
  },
  "Subquery Scan": {
    "Parent Relationship":
      "A guide as to why this operation needs to be run in order to facilitate the parent operation. There are six different possibilities:\nOuter\n: The value you’ll see most often. It means “take in the rows from this operation as input, process them and pass them on”.\nInner\n: Only ever seen on the second child of join operations, and is always seen there. This is the “inner” part of the loop — for each outer row, we look up its match using this operation.\nMember\n: Used for all children of Append and ModifyTable nodes, and on bitmap processing nodes like BitmapAnd and BitmapOr operations.\nInitPlan\n: Used for calculations performed before the query can start, eg a constant referred to in the query or the result of a CTE scan.\nSubquery\n: The child is a subquery of the parent operation. Since Postgres always uses subquery scans to feed subquery data to parent queries, only ever appears on the children of subquery scans.\nSubPlan\n: Like a Subquery, represents a new query, but used when a subquery scan is not necessary.",
    "Parallel Aware":
      "Whether or not the operation will be run in a special mode to support parallelism. Some operations need to be aware that they are running in parallel, for example sequential scans need to know they only need to scan a smaller proportion of the table. Other operations can be run on several threads without each one having any knowledge of the others.",
    Alias: "The alias used to refer to the Relation Name object.",
    "Startup Cost":
      "The estimated cost of returning the first row.\nThis is in an arbitrary unit, with the aim of being correlated to the startup time.",
    "Total Cost":
      "The estimated cost of returning all rows. This is in an arbitrary unit, with the aim of being correlated to the total time.\nThe Postgres query planner often has several ways it could resolve the same query. It calculates costs — which are hopefully correlated with the time it would take — for potential plans, and then picks the one with the lowest cost. It’s worth bearing in mind that the costs are unit-free — they’re not designed to convert into time, or disk reads. They’re just supposed to be bigger for slower operations, and smaller for faster ones.\nIf the planner thinks it can finish early due to a parent Limit operation, the total cost of the Limit operation will reflect this, but the total cost of its child operations will not.",
    "Plan Rows":
      "The number of rows,\nper-loop\n, that the planner expects to be returned by the operation.\nPoor row estimates can lead to suboptimal query planning. They can often be improved by running\nANALYZE\n(not the EXPLAIN parameter), by increasing statistics, or by allowing Postgres to understand correlation between columns using multivariate statistics.\nIf the planner thinks it can finish early due to a Limit operation, the plan rows of the Limit operation will reflect this, but the plan rows of its child operations will not.",
    "Plan Width":
      "The\nestimated\naverage size of the rows produced by the operation, in\nbytes\n.",
    "Actual Startup Time":
      "The amount of time, in\nmilliseconds\n, it takes to get the first row out of the operation.\nSometimes, this is very close to the setup time — for example on a sequential scan which returns all the rows in a table.\nOther times, though, it’s more or less the total time. For example, in order to return the first row of a sort, you have to sort all of the rows to work out which one comes first.",
    "Actual Total Time":
      "The actual amount of time in milliseconds spent on this operation\nand all of its children\n. It’s a\nper-loop average\n, rounded to the nearest thousandth of a millisecond.\nWorking out individual operation timings, especially where CTEs and SubPlans are concerned, can be tricky. This is one of the main reasons we decided to build\npgMustard\n.",
    "Actual Rows":
      "The number of rows returned by the operation\nper loop\n.\nThe important thing to notice about this is that it’s an average of all the loops executed, rounded to the nearest integer. This means that while “Actual Loops” multiplied by “Actual Rows” is a pretty good approximation for total number of rows returned most of the time, it can be off by as much as half of the number of loops. Usually it’s just slightly confusing as you see a row or two appear or disappear between operations, but on operations with lots of loops there is potential for serious miscalculation.\nPoor row estimates, where Actual Rows differs substantially from Plan Rows, can lead to suboptimal query planning. Estimates can often be improved by running\nANALYZE\n(not the EXPLAIN parameter), by increasing statistics, or by allowing Postgres to understand correlation between columns using multivariate statistics.",
    "Actual Loops":
      "The number of times the operation is executed. For a lot of operations it will have a value of one, but when it is not, there are three different cases:\nSome operations can be executed more than once. For example, “Nested Loops” run their “Inner” child once for every row returned by their “Outer” child.\nWhen an operation that would normally only consist of one loop is split across multiple threads, each partial operation is counted as a Loop.\nThe number of loops can be zero when an operation doesn’t need to be executed at all. For example if a table read is planned to provide candidates for an inner join, but there turns out to be no rows on the other side of the join, the operation can be effectively eliminated.",
    Output:
      "A list of the columns returned by the operation.\nThis is only shown when VERBOSE is on.",
    Filter:
      "When present, this is a filter used to remove rows.\nThe important thing to note is that this is a filter in the traditional sense: these rows are read in (either from a data source or another operation in the plan), inspected, and then approved or removed based on the filter.\nIf a high proportion of rows are being removed by the Filter, you may want to investigate whether a (more) selective index could help.\nIf you notice a lot of rows being filtered late in a query plan, this might be due to an operation (like a GROUP BY or SORT) using more columns than are necessary, requiring joins to take place before rows can be discarded. It is also sometimes a result of unnecessary or ill-advised uses of DISTINCT.",
    "Rows Removed by Filter":
      "The number of rows removed by the\nFilter\n. This is a\nper-loop average\n, rounded to the nearest integer.\nIf a high proportion of rows are being removed, you may want to investigate whether a (more) selective index could help.",
    "Shared Hit Blocks":
      "The number of blocks from indexes/tables that were found in the Postgres buffer cache.\nThis\nincludes\nvalues for child operations and is a\ntotal\nvalue (i.e. not a per-loop average).\nOnce you have subtracted child operation values, the proportion of shared hit to shared read blocks is an interesting measure of cache performance.\nThe ratio of shared blocks (hit plus read) to rows processed (including any filtered out) is also interesting: a high ratio means Postgres is reading a lot of data for what it is doing, which can be a sign of bloat.",
    "Shared Read Blocks":
      "The number of blocks from tables/indexes that were read from disk (or the OS cache).\nThis\nincludes\nvalues for child operations and is a\ntotal\nvalue (i.e. not per-loop).\nOnce you have subtracted child operation values, the proportion of shared hit to shared read blocks is an interesting measure of cache performance.\nThe ratio of shared blocks (hit plus read) to rows processed (including any filtered out) is also interesting: a high ratio means Postgres is reading a lot of data for what it is doing, which can be a sign of bloat.",
    "Shared Dirtied Blocks":
      "The number of blocks from tables/indexes that were modified by the operation.\nThis\nincludes\nvalues for child operations and is a\ntotal\nvalue (i.e. not per-loop).\nInterestingly, a SELECT query can report shared dirtied blocks when setting hint bits on recently-committed rows, or pruning old row versions. While somewhat surprising, both of these are perfectly normal and healthy.",
    "Shared Written Blocks":
      "The number of blocks from tables/indexes that were evicted from the cache.\nThis\nincludes\nvalues for child operations and is a\ntotal\nvalue (i.e. not a per-loop average).",
    "Local Hit Blocks":
      "The number of blocks from temporary tables and indexes that were found in the cache.\nThis\nincludes\nvalues for child operations and is a\ntotal\nvalue (not a per-loop average).",
    "Local Read Blocks":
      "The number of blocks read from\ntemporary tables and indexes that were not found in the Postgres cache (read from disk or the OS cache).\nThis\nincludes\nvalues for child operations and is a\ntotal\nvalue (not a per-loop average).",
    "Local Dirtied Blocks":
      "The number of blocks from\ntemporary tables and indexes that have been modified by the operation.\nThis\nincludes\nvalues for child operations and is a\ntotal\nvalue (i.e. not a per-loop average).",
    "Local Written Blocks":
      "The number of blocks from\ntemporary tables and indexes that were evicted from the cache.\nThis\nincludes\nvalues for child operations and is a\ntotal\nvalue (i.e. not a per-loop average).",
    "Temp Read Blocks":
      "The number of blocks read from short-term data used to calculate hashes, sorts, Materialize operations, and similar.\nThis\nincludes\nvalues for child operations and is a\ntotal\nvalue (i.e. not a per-loop average).\nYour settings of\nwork_mem\nand\nhash_mem_multiplier\ndetermine how much memory is available to Postgres per operation.",
    "Temp Written Blocks":
      "The number of blocks from short-term data (used to calculate operations like hashes, sorts, and materializes) that were evicted from the cache.\nThis\nincludes\nvalues for child operations and is a\ntotal\nvalue (i.e. not a per-loop average).\nYour settings of\nwork_mem\nand\nhash_mem_multiplier\ndetermine how much memory is available to Postgres per operation.",
    "Shared I/O Read Time":
      "The time spent reading data from tables and indexes, in\nmilliseconds\n.\nThis\nincludes\nvalues for child operations and is a total value (not a per-loop average).\nRequires\ntrack_io_timing\nand\nBUFFERS\nto be on.\nIn the latest version, the text format of explain displays this as\nI/O Timings: shared read\nIn PostgreSQL 15 and 16 it shows as a combined metric\nI/O Timings: shared/local read\nGetting timing information has an overhead, due to checking the system clock. You can use\npg_test_timing\nto measure this for your system.",
    "Shared I/O Write Time":
      "The time spent writing data for tables and indexes, in\nmilliseconds\n.\nThis\nincludes\nvalues for child operations and is a total value (not a per-loop average).\nRequires\ntrack_io_timing\nand\nBUFFERS\nto be on.\nIn the latest version, the text format of explain displays this as\nI/O Timings: shared write\nIn PostgreSQL 15 and 16 it shows as a combined metric\nI/O Timings: shared/local write\nGetting timing information has an overhead, due to checking the system clock. You can use\npg_test_timing\nto measure this for your system.",
    "Local I/O Read Time":
      "The time spent reading local data (e.g. from temporary tables and indexes), in\nmilliseconds\n.\nThis\nincludes\nvalues for child operations and is a total value (i.e. not a per-loop average).\nThis was added as a separate field in PostgreSQL 17, and requires both\ntrack_io_timing\nand\nBUFFERS\n.\nIn the default text format, this will show as\nI/O Timings: local read\nIn versions 15 and 16 it is available as a combined metric as\nshared/local\nGetting timing information has an overhead, due to checking the system clock. You can use\npg_test_timing\nto measure this for your system.",
    "Local I/O Write Time":
      "The time spent writing local data (e.g. for temporary tables and indexes), in\nmilliseconds\n.\nThis\nincludes\nvalues for child operations and is a total value (i.e. not a per-loop average).\nThis was added as a separate field in PostgreSQL 17, and requires both\ntrack_io_timing\nand\nBUFFERS\n.\nIn the default text format, this will show as\nI/O Timings: local write\nIn versions 15 and 16 it is available as a combined metric as\nshared/local\nGetting timing information has an overhead, due to checking the system clock. You can use\npg_test_timing\nto measure this for your system.",
    "Temp I/O Read Time":
      "The time spent reading short-term data, in\nmilliseconds\n(for example during sort and hash operations that were not done in memory).\nThis\nincludes\nvalues for child operations and is a total value (i.e. not a per-loop average).\nThis was added in PostgreSQL 15, and requires both\ntrack_io_timing\nand\nBUFFERS\n.\nIn the text format of explain, this shows as\nI/O Timings: temp read\nGetting timing information has an overhead, due to checking the system clock. You can use\npg_test_timing\nto measure this for your system.",
    "Temp I/O Write Time":
      "The time spent writing short-term data, in\nmilliseconds\n(for example during sort and hash operations that were not done in memory).\nThis\nincludes\nvalues for child operations and is a total value (i.e. not a per-loop average).\nThis was added in PostgreSQL 15, and requires both\ntrack_io_timing\nand\nBUFFERS\n.\nIn the text format of explain, this shows as\nI/O Timings: temp write\nGetting timing information has an overhead, due to checking the system clock. You can use\npg_test_timing\nto measure this for your system.",
  },
  "TID Scan": {
    "Parent Relationship":
      "A guide as to why this operation needs to be run in order to facilitate the parent operation. There are six different possibilities:\nOuter\n: The value you’ll see most often. It means “take in the rows from this operation as input, process them and pass them on”.\nInner\n: Only ever seen on the second child of join operations, and is always seen there. This is the “inner” part of the loop — for each outer row, we look up its match using this operation.\nMember\n: Used for all children of Append and ModifyTable nodes, and on bitmap processing nodes like BitmapAnd and BitmapOr operations.\nInitPlan\n: Used for calculations performed before the query can start, eg a constant referred to in the query or the result of a CTE scan.\nSubquery\n: The child is a subquery of the parent operation. Since Postgres always uses subquery scans to feed subquery data to parent queries, only ever appears on the children of subquery scans.\nSubPlan\n: Like a Subquery, represents a new query, but used when a subquery scan is not necessary.",
    "Parallel Aware":
      "Whether or not the operation will be run in a special mode to support parallelism. Some operations need to be aware that they are running in parallel, for example sequential scans need to know they only need to scan a smaller proportion of the table. Other operations can be run on several threads without each one having any knowledge of the others.",
    "Relation Name":
      "The data source being read/written from. Normally a table name (including when the data is accessed via an index), but can also be a materialised view or foreign data source.",
    Schema:
      "The schema of the “Relation Name” object.\nThis is only shown when VERBOSE is on.",
    Alias: "The alias used to refer to the Relation Name object.",
    "Startup Cost":
      "The estimated cost of returning the first row.\nThis is in an arbitrary unit, with the aim of being correlated to the startup time.",
    "Total Cost":
      "The estimated cost of returning all rows. This is in an arbitrary unit, with the aim of being correlated to the total time.\nThe Postgres query planner often has several ways it could resolve the same query. It calculates costs — which are hopefully correlated with the time it would take — for potential plans, and then picks the one with the lowest cost. It’s worth bearing in mind that the costs are unit-free — they’re not designed to convert into time, or disk reads. They’re just supposed to be bigger for slower operations, and smaller for faster ones.\nIf the planner thinks it can finish early due to a parent Limit operation, the total cost of the Limit operation will reflect this, but the total cost of its child operations will not.",
    "Plan Rows":
      "The number of rows,\nper-loop\n, that the planner expects to be returned by the operation.\nPoor row estimates can lead to suboptimal query planning. They can often be improved by running\nANALYZE\n(not the EXPLAIN parameter), by increasing statistics, or by allowing Postgres to understand correlation between columns using multivariate statistics.\nIf the planner thinks it can finish early due to a Limit operation, the plan rows of the Limit operation will reflect this, but the plan rows of its child operations will not.",
    "Plan Width":
      "The\nestimated\naverage size of the rows produced by the operation, in\nbytes\n.",
    "Actual Startup Time":
      "The amount of time, in\nmilliseconds\n, it takes to get the first row out of the operation.\nSometimes, this is very close to the setup time — for example on a sequential scan which returns all the rows in a table.\nOther times, though, it’s more or less the total time. For example, in order to return the first row of a sort, you have to sort all of the rows to work out which one comes first.",
    "Actual Total Time":
      "The actual amount of time in milliseconds spent on this operation\nand all of its children\n. It’s a\nper-loop average\n, rounded to the nearest thousandth of a millisecond.\nWorking out individual operation timings, especially where CTEs and SubPlans are concerned, can be tricky. This is one of the main reasons we decided to build\npgMustard\n.",
    "Actual Rows":
      "The number of rows returned by the operation\nper loop\n.\nThe important thing to notice about this is that it’s an average of all the loops executed, rounded to the nearest integer. This means that while “Actual Loops” multiplied by “Actual Rows” is a pretty good approximation for total number of rows returned most of the time, it can be off by as much as half of the number of loops. Usually it’s just slightly confusing as you see a row or two appear or disappear between operations, but on operations with lots of loops there is potential for serious miscalculation.\nPoor row estimates, where Actual Rows differs substantially from Plan Rows, can lead to suboptimal query planning. Estimates can often be improved by running\nANALYZE\n(not the EXPLAIN parameter), by increasing statistics, or by allowing Postgres to understand correlation between columns using multivariate statistics.",
    "Actual Loops":
      "The number of times the operation is executed. For a lot of operations it will have a value of one, but when it is not, there are three different cases:\nSome operations can be executed more than once. For example, “Nested Loops” run their “Inner” child once for every row returned by their “Outer” child.\nWhen an operation that would normally only consist of one loop is split across multiple threads, each partial operation is counted as a Loop.\nThe number of loops can be zero when an operation doesn’t need to be executed at all. For example if a table read is planned to provide candidates for an inner join, but there turns out to be no rows on the other side of the join, the operation can be effectively eliminated.",
    Output:
      "A list of the columns returned by the operation.\nThis is only shown when VERBOSE is on.",
    "Shared Hit Blocks":
      "The number of blocks from indexes/tables that were found in the Postgres buffer cache.\nThis\nincludes\nvalues for child operations and is a\ntotal\nvalue (i.e. not a per-loop average).\nOnce you have subtracted child operation values, the proportion of shared hit to shared read blocks is an interesting measure of cache performance.\nThe ratio of shared blocks (hit plus read) to rows processed (including any filtered out) is also interesting: a high ratio means Postgres is reading a lot of data for what it is doing, which can be a sign of bloat.",
    "Shared Read Blocks":
      "The number of blocks from tables/indexes that were read from disk (or the OS cache).\nThis\nincludes\nvalues for child operations and is a\ntotal\nvalue (i.e. not per-loop).\nOnce you have subtracted child operation values, the proportion of shared hit to shared read blocks is an interesting measure of cache performance.\nThe ratio of shared blocks (hit plus read) to rows processed (including any filtered out) is also interesting: a high ratio means Postgres is reading a lot of data for what it is doing, which can be a sign of bloat.",
    "Shared Dirtied Blocks":
      "The number of blocks from tables/indexes that were modified by the operation.\nThis\nincludes\nvalues for child operations and is a\ntotal\nvalue (i.e. not per-loop).\nInterestingly, a SELECT query can report shared dirtied blocks when setting hint bits on recently-committed rows, or pruning old row versions. While somewhat surprising, both of these are perfectly normal and healthy.",
    "Shared Written Blocks":
      "The number of blocks from tables/indexes that were evicted from the cache.\nThis\nincludes\nvalues for child operations and is a\ntotal\nvalue (i.e. not a per-loop average).",
    "Local Hit Blocks":
      "The number of blocks from temporary tables and indexes that were found in the cache.\nThis\nincludes\nvalues for child operations and is a\ntotal\nvalue (not a per-loop average).",
    "Local Read Blocks":
      "The number of blocks read from\ntemporary tables and indexes that were not found in the Postgres cache (read from disk or the OS cache).\nThis\nincludes\nvalues for child operations and is a\ntotal\nvalue (not a per-loop average).",
    "Local Dirtied Blocks":
      "The number of blocks from\ntemporary tables and indexes that have been modified by the operation.\nThis\nincludes\nvalues for child operations and is a\ntotal\nvalue (i.e. not a per-loop average).",
    "Local Written Blocks":
      "The number of blocks from\ntemporary tables and indexes that were evicted from the cache.\nThis\nincludes\nvalues for child operations and is a\ntotal\nvalue (i.e. not a per-loop average).",
    "Temp Read Blocks":
      "The number of blocks read from short-term data used to calculate hashes, sorts, Materialize operations, and similar.\nThis\nincludes\nvalues for child operations and is a\ntotal\nvalue (i.e. not a per-loop average).\nYour settings of\nwork_mem\nand\nhash_mem_multiplier\ndetermine how much memory is available to Postgres per operation.",
    "Temp Written Blocks":
      "The number of blocks from short-term data (used to calculate operations like hashes, sorts, and materializes) that were evicted from the cache.\nThis\nincludes\nvalues for child operations and is a\ntotal\nvalue (i.e. not a per-loop average).\nYour settings of\nwork_mem\nand\nhash_mem_multiplier\ndetermine how much memory is available to Postgres per operation.",
    "Shared I/O Read Time":
      "The time spent reading data from tables and indexes, in\nmilliseconds\n.\nThis\nincludes\nvalues for child operations and is a total value (not a per-loop average).\nRequires\ntrack_io_timing\nand\nBUFFERS\nto be on.\nIn the latest version, the text format of explain displays this as\nI/O Timings: shared read\nIn PostgreSQL 15 and 16 it shows as a combined metric\nI/O Timings: shared/local read\nGetting timing information has an overhead, due to checking the system clock. You can use\npg_test_timing\nto measure this for your system.",
    "Shared I/O Write Time":
      "The time spent writing data for tables and indexes, in\nmilliseconds\n.\nThis\nincludes\nvalues for child operations and is a total value (not a per-loop average).\nRequires\ntrack_io_timing\nand\nBUFFERS\nto be on.\nIn the latest version, the text format of explain displays this as\nI/O Timings: shared write\nIn PostgreSQL 15 and 16 it shows as a combined metric\nI/O Timings: shared/local write\nGetting timing information has an overhead, due to checking the system clock. You can use\npg_test_timing\nto measure this for your system.",
    "Local I/O Read Time":
      "The time spent reading local data (e.g. from temporary tables and indexes), in\nmilliseconds\n.\nThis\nincludes\nvalues for child operations and is a total value (i.e. not a per-loop average).\nThis was added as a separate field in PostgreSQL 17, and requires both\ntrack_io_timing\nand\nBUFFERS\n.\nIn the default text format, this will show as\nI/O Timings: local read\nIn versions 15 and 16 it is available as a combined metric as\nshared/local\nGetting timing information has an overhead, due to checking the system clock. You can use\npg_test_timing\nto measure this for your system.",
    "Local I/O Write Time":
      "The time spent writing local data (e.g. for temporary tables and indexes), in\nmilliseconds\n.\nThis\nincludes\nvalues for child operations and is a total value (i.e. not a per-loop average).\nThis was added as a separate field in PostgreSQL 17, and requires both\ntrack_io_timing\nand\nBUFFERS\n.\nIn the default text format, this will show as\nI/O Timings: local write\nIn versions 15 and 16 it is available as a combined metric as\nshared/local\nGetting timing information has an overhead, due to checking the system clock. You can use\npg_test_timing\nto measure this for your system.",
    "Temp I/O Read Time":
      "The time spent reading short-term data, in\nmilliseconds\n(for example during sort and hash operations that were not done in memory).\nThis\nincludes\nvalues for child operations and is a total value (i.e. not a per-loop average).\nThis was added in PostgreSQL 15, and requires both\ntrack_io_timing\nand\nBUFFERS\n.\nIn the text format of explain, this shows as\nI/O Timings: temp read\nGetting timing information has an overhead, due to checking the system clock. You can use\npg_test_timing\nto measure this for your system.",
    "Temp I/O Write Time":
      "The time spent writing short-term data, in\nmilliseconds\n(for example during sort and hash operations that were not done in memory).\nThis\nincludes\nvalues for child operations and is a total value (i.e. not a per-loop average).\nThis was added in PostgreSQL 15, and requires both\ntrack_io_timing\nand\nBUFFERS\n.\nIn the text format of explain, this shows as\nI/O Timings: temp write\nGetting timing information has an overhead, due to checking the system clock. You can use\npg_test_timing\nto measure this for your system.",
    "WAL Records":
      "The number of WAL (Write-Ahead Logging) records generated by the operation.",
    "WAL FPI":
      "The number of WAL (Write Ahead Logging)\nfull page images\ngenerated by the operation.\nIn other places, including pre-release versions of PostgreSQL 13, you may see these referred to as\nfull page writes\n.",
    "WAL Bytes":
      "The amount of WAL (Write Ahead Logging) data generated by the operation.",
  },
  "TID Range Scan": {
    "Parent Relationship":
      "A guide as to why this operation needs to be run in order to facilitate the parent operation. There are six different possibilities:\nOuter\n: The value you’ll see most often. It means “take in the rows from this operation as input, process them and pass them on”.\nInner\n: Only ever seen on the second child of join operations, and is always seen there. This is the “inner” part of the loop — for each outer row, we look up its match using this operation.\nMember\n: Used for all children of Append and ModifyTable nodes, and on bitmap processing nodes like BitmapAnd and BitmapOr operations.\nInitPlan\n: Used for calculations performed before the query can start, eg a constant referred to in the query or the result of a CTE scan.\nSubquery\n: The child is a subquery of the parent operation. Since Postgres always uses subquery scans to feed subquery data to parent queries, only ever appears on the children of subquery scans.\nSubPlan\n: Like a Subquery, represents a new query, but used when a subquery scan is not necessary.",
    "Parallel Aware":
      "Whether or not the operation will be run in a special mode to support parallelism. Some operations need to be aware that they are running in parallel, for example sequential scans need to know they only need to scan a smaller proportion of the table. Other operations can be run on several threads without each one having any knowledge of the others.",
    "Async Capable":
      "As of PostgreSQL 14, queries referencing multiple foreign tables can now perform foreign table scans in parallel.\nThis happens if an Append node requests a tuple from an “async-capable”\nForeign Scan\nnode.",
    "Relation Name":
      "The data source being read/written from. Normally a table name (including when the data is accessed via an index), but can also be a materialised view or foreign data source.",
    Schema:
      "The schema of the “Relation Name” object.\nThis is only shown when VERBOSE is on.",
    Alias: "The alias used to refer to the Relation Name object.",
    "Startup Cost":
      "The estimated cost of returning the first row.\nThis is in an arbitrary unit, with the aim of being correlated to the startup time.",
    "Total Cost":
      "The estimated cost of returning all rows. This is in an arbitrary unit, with the aim of being correlated to the total time.\nThe Postgres query planner often has several ways it could resolve the same query. It calculates costs — which are hopefully correlated with the time it would take — for potential plans, and then picks the one with the lowest cost. It’s worth bearing in mind that the costs are unit-free — they’re not designed to convert into time, or disk reads. They’re just supposed to be bigger for slower operations, and smaller for faster ones.\nIf the planner thinks it can finish early due to a parent Limit operation, the total cost of the Limit operation will reflect this, but the total cost of its child operations will not.",
    "Plan Rows":
      "The number of rows,\nper-loop\n, that the planner expects to be returned by the operation.\nPoor row estimates can lead to suboptimal query planning. They can often be improved by running\nANALYZE\n(not the EXPLAIN parameter), by increasing statistics, or by allowing Postgres to understand correlation between columns using multivariate statistics.\nIf the planner thinks it can finish early due to a Limit operation, the plan rows of the Limit operation will reflect this, but the plan rows of its child operations will not.",
    "Plan Width":
      "The\nestimated\naverage size of the rows produced by the operation, in\nbytes\n.",
    "Actual Startup Time":
      "The amount of time, in\nmilliseconds\n, it takes to get the first row out of the operation.\nSometimes, this is very close to the setup time — for example on a sequential scan which returns all the rows in a table.\nOther times, though, it’s more or less the total time. For example, in order to return the first row of a sort, you have to sort all of the rows to work out which one comes first.",
    "Actual Total Time":
      "The actual amount of time in milliseconds spent on this operation\nand all of its children\n. It’s a\nper-loop average\n, rounded to the nearest thousandth of a millisecond.\nWorking out individual operation timings, especially where CTEs and SubPlans are concerned, can be tricky. This is one of the main reasons we decided to build\npgMustard\n.",
    "Actual Rows":
      "The number of rows returned by the operation\nper loop\n.\nThe important thing to notice about this is that it’s an average of all the loops executed, rounded to the nearest integer. This means that while “Actual Loops” multiplied by “Actual Rows” is a pretty good approximation for total number of rows returned most of the time, it can be off by as much as half of the number of loops. Usually it’s just slightly confusing as you see a row or two appear or disappear between operations, but on operations with lots of loops there is potential for serious miscalculation.\nPoor row estimates, where Actual Rows differs substantially from Plan Rows, can lead to suboptimal query planning. Estimates can often be improved by running\nANALYZE\n(not the EXPLAIN parameter), by increasing statistics, or by allowing Postgres to understand correlation between columns using multivariate statistics.",
    "Actual Loops":
      "The number of times the operation is executed. For a lot of operations it will have a value of one, but when it is not, there are three different cases:\nSome operations can be executed more than once. For example, “Nested Loops” run their “Inner” child once for every row returned by their “Outer” child.\nWhen an operation that would normally only consist of one loop is split across multiple threads, each partial operation is counted as a Loop.\nThe number of loops can be zero when an operation doesn’t need to be executed at all. For example if a table read is planned to provide candidates for an inner join, but there turns out to be no rows on the other side of the join, the operation can be effectively eliminated.",
    Output:
      "A list of the columns returned by the operation.\nThis is only shown when VERBOSE is on.",
    "Shared Hit Blocks":
      "The number of blocks from indexes/tables that were found in the Postgres buffer cache.\nThis\nincludes\nvalues for child operations and is a\ntotal\nvalue (i.e. not a per-loop average).\nOnce you have subtracted child operation values, the proportion of shared hit to shared read blocks is an interesting measure of cache performance.\nThe ratio of shared blocks (hit plus read) to rows processed (including any filtered out) is also interesting: a high ratio means Postgres is reading a lot of data for what it is doing, which can be a sign of bloat.",
    "Shared Read Blocks":
      "The number of blocks from tables/indexes that were read from disk (or the OS cache).\nThis\nincludes\nvalues for child operations and is a\ntotal\nvalue (i.e. not per-loop).\nOnce you have subtracted child operation values, the proportion of shared hit to shared read blocks is an interesting measure of cache performance.\nThe ratio of shared blocks (hit plus read) to rows processed (including any filtered out) is also interesting: a high ratio means Postgres is reading a lot of data for what it is doing, which can be a sign of bloat.",
    "Shared Dirtied Blocks":
      "The number of blocks from tables/indexes that were modified by the operation.\nThis\nincludes\nvalues for child operations and is a\ntotal\nvalue (i.e. not per-loop).\nInterestingly, a SELECT query can report shared dirtied blocks when setting hint bits on recently-committed rows, or pruning old row versions. While somewhat surprising, both of these are perfectly normal and healthy.",
    "Shared Written Blocks":
      "The number of blocks from tables/indexes that were evicted from the cache.\nThis\nincludes\nvalues for child operations and is a\ntotal\nvalue (i.e. not a per-loop average).",
    "Local Hit Blocks":
      "The number of blocks from temporary tables and indexes that were found in the cache.\nThis\nincludes\nvalues for child operations and is a\ntotal\nvalue (not a per-loop average).",
    "Local Read Blocks":
      "The number of blocks read from\ntemporary tables and indexes that were not found in the Postgres cache (read from disk or the OS cache).\nThis\nincludes\nvalues for child operations and is a\ntotal\nvalue (not a per-loop average).",
    "Local Dirtied Blocks":
      "The number of blocks from\ntemporary tables and indexes that have been modified by the operation.\nThis\nincludes\nvalues for child operations and is a\ntotal\nvalue (i.e. not a per-loop average).",
    "Local Written Blocks":
      "The number of blocks from\ntemporary tables and indexes that were evicted from the cache.\nThis\nincludes\nvalues for child operations and is a\ntotal\nvalue (i.e. not a per-loop average).",
    "Temp Read Blocks":
      "The number of blocks read from short-term data used to calculate hashes, sorts, Materialize operations, and similar.\nThis\nincludes\nvalues for child operations and is a\ntotal\nvalue (i.e. not a per-loop average).\nYour settings of\nwork_mem\nand\nhash_mem_multiplier\ndetermine how much memory is available to Postgres per operation.",
    "Temp Written Blocks":
      "The number of blocks from short-term data (used to calculate operations like hashes, sorts, and materializes) that were evicted from the cache.\nThis\nincludes\nvalues for child operations and is a\ntotal\nvalue (i.e. not a per-loop average).\nYour settings of\nwork_mem\nand\nhash_mem_multiplier\ndetermine how much memory is available to Postgres per operation.",
    "Shared I/O Read Time":
      "The time spent reading data from tables and indexes, in\nmilliseconds\n.\nThis\nincludes\nvalues for child operations and is a total value (not a per-loop average).\nRequires\ntrack_io_timing\nand\nBUFFERS\nto be on.\nIn the latest version, the text format of explain displays this as\nI/O Timings: shared read\nIn PostgreSQL 15 and 16 it shows as a combined metric\nI/O Timings: shared/local read\nGetting timing information has an overhead, due to checking the system clock. You can use\npg_test_timing\nto measure this for your system.",
    "Shared I/O Write Time":
      "The time spent writing data for tables and indexes, in\nmilliseconds\n.\nThis\nincludes\nvalues for child operations and is a total value (not a per-loop average).\nRequires\ntrack_io_timing\nand\nBUFFERS\nto be on.\nIn the latest version, the text format of explain displays this as\nI/O Timings: shared write\nIn PostgreSQL 15 and 16 it shows as a combined metric\nI/O Timings: shared/local write\nGetting timing information has an overhead, due to checking the system clock. You can use\npg_test_timing\nto measure this for your system.",
    "Local I/O Read Time":
      "The time spent reading local data (e.g. from temporary tables and indexes), in\nmilliseconds\n.\nThis\nincludes\nvalues for child operations and is a total value (i.e. not a per-loop average).\nThis was added as a separate field in PostgreSQL 17, and requires both\ntrack_io_timing\nand\nBUFFERS\n.\nIn the default text format, this will show as\nI/O Timings: local read\nIn versions 15 and 16 it is available as a combined metric as\nshared/local\nGetting timing information has an overhead, due to checking the system clock. You can use\npg_test_timing\nto measure this for your system.",
    "Local I/O Write Time":
      "The time spent writing local data (e.g. for temporary tables and indexes), in\nmilliseconds\n.\nThis\nincludes\nvalues for child operations and is a total value (i.e. not a per-loop average).\nThis was added as a separate field in PostgreSQL 17, and requires both\ntrack_io_timing\nand\nBUFFERS\n.\nIn the default text format, this will show as\nI/O Timings: local write\nIn versions 15 and 16 it is available as a combined metric as\nshared/local\nGetting timing information has an overhead, due to checking the system clock. You can use\npg_test_timing\nto measure this for your system.",
    "Temp I/O Read Time":
      "The time spent reading short-term data, in\nmilliseconds\n(for example during sort and hash operations that were not done in memory).\nThis\nincludes\nvalues for child operations and is a total value (i.e. not a per-loop average).\nThis was added in PostgreSQL 15, and requires both\ntrack_io_timing\nand\nBUFFERS\n.\nIn the text format of explain, this shows as\nI/O Timings: temp read\nGetting timing information has an overhead, due to checking the system clock. You can use\npg_test_timing\nto measure this for your system.",
    "Temp I/O Write Time":
      "The time spent writing short-term data, in\nmilliseconds\n(for example during sort and hash operations that were not done in memory).\nThis\nincludes\nvalues for child operations and is a total value (i.e. not a per-loop average).\nThis was added in PostgreSQL 15, and requires both\ntrack_io_timing\nand\nBUFFERS\n.\nIn the text format of explain, this shows as\nI/O Timings: temp write\nGetting timing information has an overhead, due to checking the system clock. You can use\npg_test_timing\nto measure this for your system.",
    "WAL Records":
      "The number of WAL (Write-Ahead Logging) records generated by the operation.",
    "WAL FPI":
      "The number of WAL (Write Ahead Logging)\nfull page images\ngenerated by the operation.\nIn other places, including pre-release versions of PostgreSQL 13, you may see these referred to as\nfull page writes\n.",
    "WAL Bytes":
      "The amount of WAL (Write Ahead Logging) data generated by the operation.",
  },
  Unique: {
    "Parent Relationship":
      "A guide as to why this operation needs to be run in order to facilitate the parent operation. There are six different possibilities:\nOuter\n: The value you’ll see most often. It means “take in the rows from this operation as input, process them and pass them on”.\nInner\n: Only ever seen on the second child of join operations, and is always seen there. This is the “inner” part of the loop — for each outer row, we look up its match using this operation.\nMember\n: Used for all children of Append and ModifyTable nodes, and on bitmap processing nodes like BitmapAnd and BitmapOr operations.\nInitPlan\n: Used for calculations performed before the query can start, eg a constant referred to in the query or the result of a CTE scan.\nSubquery\n: The child is a subquery of the parent operation. Since Postgres always uses subquery scans to feed subquery data to parent queries, only ever appears on the children of subquery scans.\nSubPlan\n: Like a Subquery, represents a new query, but used when a subquery scan is not necessary.",
    "Subplan Name": "The name of the SubPlan.",
    "Parallel Aware":
      "Whether or not the operation will be run in a special mode to support parallelism. Some operations need to be aware that they are running in parallel, for example sequential scans need to know they only need to scan a smaller proportion of the table. Other operations can be run on several threads without each one having any knowledge of the others.",
    "Startup Cost":
      "The estimated cost of returning the first row.\nThis is in an arbitrary unit, with the aim of being correlated to the startup time.",
    "Total Cost":
      "The estimated cost of returning all rows. This is in an arbitrary unit, with the aim of being correlated to the total time.\nThe Postgres query planner often has several ways it could resolve the same query. It calculates costs — which are hopefully correlated with the time it would take — for potential plans, and then picks the one with the lowest cost. It’s worth bearing in mind that the costs are unit-free — they’re not designed to convert into time, or disk reads. They’re just supposed to be bigger for slower operations, and smaller for faster ones.\nIf the planner thinks it can finish early due to a parent Limit operation, the total cost of the Limit operation will reflect this, but the total cost of its child operations will not.",
    "Plan Rows":
      "The number of rows,\nper-loop\n, that the planner expects to be returned by the operation.\nPoor row estimates can lead to suboptimal query planning. They can often be improved by running\nANALYZE\n(not the EXPLAIN parameter), by increasing statistics, or by allowing Postgres to understand correlation between columns using multivariate statistics.\nIf the planner thinks it can finish early due to a Limit operation, the plan rows of the Limit operation will reflect this, but the plan rows of its child operations will not.",
    "Plan Width":
      "The\nestimated\naverage size of the rows produced by the operation, in\nbytes\n.",
    "Actual Startup Time":
      "The amount of time, in\nmilliseconds\n, it takes to get the first row out of the operation.\nSometimes, this is very close to the setup time — for example on a sequential scan which returns all the rows in a table.\nOther times, though, it’s more or less the total time. For example, in order to return the first row of a sort, you have to sort all of the rows to work out which one comes first.",
    "Actual Total Time":
      "The actual amount of time in milliseconds spent on this operation\nand all of its children\n. It’s a\nper-loop average\n, rounded to the nearest thousandth of a millisecond.\nWorking out individual operation timings, especially where CTEs and SubPlans are concerned, can be tricky. This is one of the main reasons we decided to build\npgMustard\n.",
    "Actual Rows":
      "The number of rows returned by the operation\nper loop\n.\nThe important thing to notice about this is that it’s an average of all the loops executed, rounded to the nearest integer. This means that while “Actual Loops” multiplied by “Actual Rows” is a pretty good approximation for total number of rows returned most of the time, it can be off by as much as half of the number of loops. Usually it’s just slightly confusing as you see a row or two appear or disappear between operations, but on operations with lots of loops there is potential for serious miscalculation.\nPoor row estimates, where Actual Rows differs substantially from Plan Rows, can lead to suboptimal query planning. Estimates can often be improved by running\nANALYZE\n(not the EXPLAIN parameter), by increasing statistics, or by allowing Postgres to understand correlation between columns using multivariate statistics.",
    "Actual Loops":
      "The number of times the operation is executed. For a lot of operations it will have a value of one, but when it is not, there are three different cases:\nSome operations can be executed more than once. For example, “Nested Loops” run their “Inner” child once for every row returned by their “Outer” child.\nWhen an operation that would normally only consist of one loop is split across multiple threads, each partial operation is counted as a Loop.\nThe number of loops can be zero when an operation doesn’t need to be executed at all. For example if a table read is planned to provide candidates for an inner join, but there turns out to be no rows on the other side of the join, the operation can be effectively eliminated.",
    Output:
      "A list of the columns returned by the operation.\nThis is only shown when VERBOSE is on.",
    "Shared Hit Blocks":
      "The number of blocks from indexes/tables that were found in the Postgres buffer cache.\nThis\nincludes\nvalues for child operations and is a\ntotal\nvalue (i.e. not a per-loop average).\nOnce you have subtracted child operation values, the proportion of shared hit to shared read blocks is an interesting measure of cache performance.\nThe ratio of shared blocks (hit plus read) to rows processed (including any filtered out) is also interesting: a high ratio means Postgres is reading a lot of data for what it is doing, which can be a sign of bloat.",
    "Shared Read Blocks":
      "The number of blocks from tables/indexes that were read from disk (or the OS cache).\nThis\nincludes\nvalues for child operations and is a\ntotal\nvalue (i.e. not per-loop).\nOnce you have subtracted child operation values, the proportion of shared hit to shared read blocks is an interesting measure of cache performance.\nThe ratio of shared blocks (hit plus read) to rows processed (including any filtered out) is also interesting: a high ratio means Postgres is reading a lot of data for what it is doing, which can be a sign of bloat.",
    "Shared Dirtied Blocks":
      "The number of blocks from tables/indexes that were modified by the operation.\nThis\nincludes\nvalues for child operations and is a\ntotal\nvalue (i.e. not per-loop).\nInterestingly, a SELECT query can report shared dirtied blocks when setting hint bits on recently-committed rows, or pruning old row versions. While somewhat surprising, both of these are perfectly normal and healthy.",
    "Shared Written Blocks":
      "The number of blocks from tables/indexes that were evicted from the cache.\nThis\nincludes\nvalues for child operations and is a\ntotal\nvalue (i.e. not a per-loop average).",
    "Local Hit Blocks":
      "The number of blocks from temporary tables and indexes that were found in the cache.\nThis\nincludes\nvalues for child operations and is a\ntotal\nvalue (not a per-loop average).",
    "Local Read Blocks":
      "The number of blocks read from\ntemporary tables and indexes that were not found in the Postgres cache (read from disk or the OS cache).\nThis\nincludes\nvalues for child operations and is a\ntotal\nvalue (not a per-loop average).",
    "Local Dirtied Blocks":
      "The number of blocks from\ntemporary tables and indexes that have been modified by the operation.\nThis\nincludes\nvalues for child operations and is a\ntotal\nvalue (i.e. not a per-loop average).",
    "Local Written Blocks":
      "The number of blocks from\ntemporary tables and indexes that were evicted from the cache.\nThis\nincludes\nvalues for child operations and is a\ntotal\nvalue (i.e. not a per-loop average).",
    "Temp Read Blocks":
      "The number of blocks read from short-term data used to calculate hashes, sorts, Materialize operations, and similar.\nThis\nincludes\nvalues for child operations and is a\ntotal\nvalue (i.e. not a per-loop average).\nYour settings of\nwork_mem\nand\nhash_mem_multiplier\ndetermine how much memory is available to Postgres per operation.",
    "Temp Written Blocks":
      "The number of blocks from short-term data (used to calculate operations like hashes, sorts, and materializes) that were evicted from the cache.\nThis\nincludes\nvalues for child operations and is a\ntotal\nvalue (i.e. not a per-loop average).\nYour settings of\nwork_mem\nand\nhash_mem_multiplier\ndetermine how much memory is available to Postgres per operation.",
    "Shared I/O Read Time":
      "The time spent reading data from tables and indexes, in\nmilliseconds\n.\nThis\nincludes\nvalues for child operations and is a total value (not a per-loop average).\nRequires\ntrack_io_timing\nand\nBUFFERS\nto be on.\nIn the latest version, the text format of explain displays this as\nI/O Timings: shared read\nIn PostgreSQL 15 and 16 it shows as a combined metric\nI/O Timings: shared/local read\nGetting timing information has an overhead, due to checking the system clock. You can use\npg_test_timing\nto measure this for your system.",
    "Shared I/O Write Time":
      "The time spent writing data for tables and indexes, in\nmilliseconds\n.\nThis\nincludes\nvalues for child operations and is a total value (not a per-loop average).\nRequires\ntrack_io_timing\nand\nBUFFERS\nto be on.\nIn the latest version, the text format of explain displays this as\nI/O Timings: shared write\nIn PostgreSQL 15 and 16 it shows as a combined metric\nI/O Timings: shared/local write\nGetting timing information has an overhead, due to checking the system clock. You can use\npg_test_timing\nto measure this for your system.",
    "Local I/O Read Time":
      "The time spent reading local data (e.g. from temporary tables and indexes), in\nmilliseconds\n.\nThis\nincludes\nvalues for child operations and is a total value (i.e. not a per-loop average).\nThis was added as a separate field in PostgreSQL 17, and requires both\ntrack_io_timing\nand\nBUFFERS\n.\nIn the default text format, this will show as\nI/O Timings: local read\nIn versions 15 and 16 it is available as a combined metric as\nshared/local\nGetting timing information has an overhead, due to checking the system clock. You can use\npg_test_timing\nto measure this for your system.",
    "Local I/O Write Time":
      "The time spent writing local data (e.g. for temporary tables and indexes), in\nmilliseconds\n.\nThis\nincludes\nvalues for child operations and is a total value (i.e. not a per-loop average).\nThis was added as a separate field in PostgreSQL 17, and requires both\ntrack_io_timing\nand\nBUFFERS\n.\nIn the default text format, this will show as\nI/O Timings: local write\nIn versions 15 and 16 it is available as a combined metric as\nshared/local\nGetting timing information has an overhead, due to checking the system clock. You can use\npg_test_timing\nto measure this for your system.",
    "Temp I/O Read Time":
      "The time spent reading short-term data, in\nmilliseconds\n(for example during sort and hash operations that were not done in memory).\nThis\nincludes\nvalues for child operations and is a total value (i.e. not a per-loop average).\nThis was added in PostgreSQL 15, and requires both\ntrack_io_timing\nand\nBUFFERS\n.\nIn the text format of explain, this shows as\nI/O Timings: temp read\nGetting timing information has an overhead, due to checking the system clock. You can use\npg_test_timing\nto measure this for your system.",
    "Temp I/O Write Time":
      "The time spent writing short-term data, in\nmilliseconds\n(for example during sort and hash operations that were not done in memory).\nThis\nincludes\nvalues for child operations and is a total value (i.e. not a per-loop average).\nThis was added in PostgreSQL 15, and requires both\ntrack_io_timing\nand\nBUFFERS\n.\nIn the text format of explain, this shows as\nI/O Timings: temp write\nGetting timing information has an overhead, due to checking the system clock. You can use\npg_test_timing\nto measure this for your system.",
  },
  "Values Scan": {
    "Parent Relationship":
      "A guide as to why this operation needs to be run in order to facilitate the parent operation. There are six different possibilities:\nOuter\n: The value you’ll see most often. It means “take in the rows from this operation as input, process them and pass them on”.\nInner\n: Only ever seen on the second child of join operations, and is always seen there. This is the “inner” part of the loop — for each outer row, we look up its match using this operation.\nMember\n: Used for all children of Append and ModifyTable nodes, and on bitmap processing nodes like BitmapAnd and BitmapOr operations.\nInitPlan\n: Used for calculations performed before the query can start, eg a constant referred to in the query or the result of a CTE scan.\nSubquery\n: The child is a subquery of the parent operation. Since Postgres always uses subquery scans to feed subquery data to parent queries, only ever appears on the children of subquery scans.\nSubPlan\n: Like a Subquery, represents a new query, but used when a subquery scan is not necessary.",
    "Parallel Aware":
      "Whether or not the operation will be run in a special mode to support parallelism. Some operations need to be aware that they are running in parallel, for example sequential scans need to know they only need to scan a smaller proportion of the table. Other operations can be run on several threads without each one having any knowledge of the others.",
    Alias: "The alias used to refer to the Relation Name object.",
    "Startup Cost":
      "The estimated cost of returning the first row.\nThis is in an arbitrary unit, with the aim of being correlated to the startup time.",
    "Total Cost":
      "The estimated cost of returning all rows. This is in an arbitrary unit, with the aim of being correlated to the total time.\nThe Postgres query planner often has several ways it could resolve the same query. It calculates costs — which are hopefully correlated with the time it would take — for potential plans, and then picks the one with the lowest cost. It’s worth bearing in mind that the costs are unit-free — they’re not designed to convert into time, or disk reads. They’re just supposed to be bigger for slower operations, and smaller for faster ones.\nIf the planner thinks it can finish early due to a parent Limit operation, the total cost of the Limit operation will reflect this, but the total cost of its child operations will not.",
    "Plan Rows":
      "The number of rows,\nper-loop\n, that the planner expects to be returned by the operation.\nPoor row estimates can lead to suboptimal query planning. They can often be improved by running\nANALYZE\n(not the EXPLAIN parameter), by increasing statistics, or by allowing Postgres to understand correlation between columns using multivariate statistics.\nIf the planner thinks it can finish early due to a Limit operation, the plan rows of the Limit operation will reflect this, but the plan rows of its child operations will not.",
    "Plan Width":
      "The\nestimated\naverage size of the rows produced by the operation, in\nbytes\n.",
    "Actual Startup Time":
      "The amount of time, in\nmilliseconds\n, it takes to get the first row out of the operation.\nSometimes, this is very close to the setup time — for example on a sequential scan which returns all the rows in a table.\nOther times, though, it’s more or less the total time. For example, in order to return the first row of a sort, you have to sort all of the rows to work out which one comes first.",
    "Actual Total Time":
      "The actual amount of time in milliseconds spent on this operation\nand all of its children\n. It’s a\nper-loop average\n, rounded to the nearest thousandth of a millisecond.\nWorking out individual operation timings, especially where CTEs and SubPlans are concerned, can be tricky. This is one of the main reasons we decided to build\npgMustard\n.",
    "Actual Rows":
      "The number of rows returned by the operation\nper loop\n.\nThe important thing to notice about this is that it’s an average of all the loops executed, rounded to the nearest integer. This means that while “Actual Loops” multiplied by “Actual Rows” is a pretty good approximation for total number of rows returned most of the time, it can be off by as much as half of the number of loops. Usually it’s just slightly confusing as you see a row or two appear or disappear between operations, but on operations with lots of loops there is potential for serious miscalculation.\nPoor row estimates, where Actual Rows differs substantially from Plan Rows, can lead to suboptimal query planning. Estimates can often be improved by running\nANALYZE\n(not the EXPLAIN parameter), by increasing statistics, or by allowing Postgres to understand correlation between columns using multivariate statistics.",
    "Actual Loops":
      "The number of times the operation is executed. For a lot of operations it will have a value of one, but when it is not, there are three different cases:\nSome operations can be executed more than once. For example, “Nested Loops” run their “Inner” child once for every row returned by their “Outer” child.\nWhen an operation that would normally only consist of one loop is split across multiple threads, each partial operation is counted as a Loop.\nThe number of loops can be zero when an operation doesn’t need to be executed at all. For example if a table read is planned to provide candidates for an inner join, but there turns out to be no rows on the other side of the join, the operation can be effectively eliminated.",
    Output:
      "A list of the columns returned by the operation.\nThis is only shown when VERBOSE is on.",
    "Shared Hit Blocks":
      "The number of blocks from indexes/tables that were found in the Postgres buffer cache.\nThis\nincludes\nvalues for child operations and is a\ntotal\nvalue (i.e. not a per-loop average).\nOnce you have subtracted child operation values, the proportion of shared hit to shared read blocks is an interesting measure of cache performance.\nThe ratio of shared blocks (hit plus read) to rows processed (including any filtered out) is also interesting: a high ratio means Postgres is reading a lot of data for what it is doing, which can be a sign of bloat.",
    "Shared Read Blocks":
      "The number of blocks from tables/indexes that were read from disk (or the OS cache).\nThis\nincludes\nvalues for child operations and is a\ntotal\nvalue (i.e. not per-loop).\nOnce you have subtracted child operation values, the proportion of shared hit to shared read blocks is an interesting measure of cache performance.\nThe ratio of shared blocks (hit plus read) to rows processed (including any filtered out) is also interesting: a high ratio means Postgres is reading a lot of data for what it is doing, which can be a sign of bloat.",
    "Shared Dirtied Blocks":
      "The number of blocks from tables/indexes that were modified by the operation.\nThis\nincludes\nvalues for child operations and is a\ntotal\nvalue (i.e. not per-loop).\nInterestingly, a SELECT query can report shared dirtied blocks when setting hint bits on recently-committed rows, or pruning old row versions. While somewhat surprising, both of these are perfectly normal and healthy.",
    "Shared Written Blocks":
      "The number of blocks from tables/indexes that were evicted from the cache.\nThis\nincludes\nvalues for child operations and is a\ntotal\nvalue (i.e. not a per-loop average).",
    "Local Hit Blocks":
      "The number of blocks from temporary tables and indexes that were found in the cache.\nThis\nincludes\nvalues for child operations and is a\ntotal\nvalue (not a per-loop average).",
    "Local Read Blocks":
      "The number of blocks read from\ntemporary tables and indexes that were not found in the Postgres cache (read from disk or the OS cache).\nThis\nincludes\nvalues for child operations and is a\ntotal\nvalue (not a per-loop average).",
    "Local Dirtied Blocks":
      "The number of blocks from\ntemporary tables and indexes that have been modified by the operation.\nThis\nincludes\nvalues for child operations and is a\ntotal\nvalue (i.e. not a per-loop average).",
    "Local Written Blocks":
      "The number of blocks from\ntemporary tables and indexes that were evicted from the cache.\nThis\nincludes\nvalues for child operations and is a\ntotal\nvalue (i.e. not a per-loop average).",
    "Temp Read Blocks":
      "The number of blocks read from short-term data used to calculate hashes, sorts, Materialize operations, and similar.\nThis\nincludes\nvalues for child operations and is a\ntotal\nvalue (i.e. not a per-loop average).\nYour settings of\nwork_mem\nand\nhash_mem_multiplier\ndetermine how much memory is available to Postgres per operation.",
    "Temp Written Blocks":
      "The number of blocks from short-term data (used to calculate operations like hashes, sorts, and materializes) that were evicted from the cache.\nThis\nincludes\nvalues for child operations and is a\ntotal\nvalue (i.e. not a per-loop average).\nYour settings of\nwork_mem\nand\nhash_mem_multiplier\ndetermine how much memory is available to Postgres per operation.",
    "Shared I/O Read Time":
      "The time spent reading data from tables and indexes, in\nmilliseconds\n.\nThis\nincludes\nvalues for child operations and is a total value (not a per-loop average).\nRequires\ntrack_io_timing\nand\nBUFFERS\nto be on.\nIn the latest version, the text format of explain displays this as\nI/O Timings: shared read\nIn PostgreSQL 15 and 16 it shows as a combined metric\nI/O Timings: shared/local read\nGetting timing information has an overhead, due to checking the system clock. You can use\npg_test_timing\nto measure this for your system.",
    "Shared I/O Write Time":
      "The time spent writing data for tables and indexes, in\nmilliseconds\n.\nThis\nincludes\nvalues for child operations and is a total value (not a per-loop average).\nRequires\ntrack_io_timing\nand\nBUFFERS\nto be on.\nIn the latest version, the text format of explain displays this as\nI/O Timings: shared write\nIn PostgreSQL 15 and 16 it shows as a combined metric\nI/O Timings: shared/local write\nGetting timing information has an overhead, due to checking the system clock. You can use\npg_test_timing\nto measure this for your system.",
    "Local I/O Read Time":
      "The time spent reading local data (e.g. from temporary tables and indexes), in\nmilliseconds\n.\nThis\nincludes\nvalues for child operations and is a total value (i.e. not a per-loop average).\nThis was added as a separate field in PostgreSQL 17, and requires both\ntrack_io_timing\nand\nBUFFERS\n.\nIn the default text format, this will show as\nI/O Timings: local read\nIn versions 15 and 16 it is available as a combined metric as\nshared/local\nGetting timing information has an overhead, due to checking the system clock. You can use\npg_test_timing\nto measure this for your system.",
    "Local I/O Write Time":
      "The time spent writing local data (e.g. for temporary tables and indexes), in\nmilliseconds\n.\nThis\nincludes\nvalues for child operations and is a total value (i.e. not a per-loop average).\nThis was added as a separate field in PostgreSQL 17, and requires both\ntrack_io_timing\nand\nBUFFERS\n.\nIn the default text format, this will show as\nI/O Timings: local write\nIn versions 15 and 16 it is available as a combined metric as\nshared/local\nGetting timing information has an overhead, due to checking the system clock. You can use\npg_test_timing\nto measure this for your system.",
    "Temp I/O Read Time":
      "The time spent reading short-term data, in\nmilliseconds\n(for example during sort and hash operations that were not done in memory).\nThis\nincludes\nvalues for child operations and is a total value (i.e. not a per-loop average).\nThis was added in PostgreSQL 15, and requires both\ntrack_io_timing\nand\nBUFFERS\n.\nIn the text format of explain, this shows as\nI/O Timings: temp read\nGetting timing information has an overhead, due to checking the system clock. You can use\npg_test_timing\nto measure this for your system.",
    "Temp I/O Write Time":
      "The time spent writing short-term data, in\nmilliseconds\n(for example during sort and hash operations that were not done in memory).\nThis\nincludes\nvalues for child operations and is a total value (i.e. not a per-loop average).\nThis was added in PostgreSQL 15, and requires both\ntrack_io_timing\nand\nBUFFERS\n.\nIn the text format of explain, this shows as\nI/O Timings: temp write\nGetting timing information has an overhead, due to checking the system clock. You can use\npg_test_timing\nto measure this for your system.",
  },
  WindowAgg: {
    "Parent Relationship":
      "A guide as to why this operation needs to be run in order to facilitate the parent operation. There are six different possibilities:\nOuter\n: The value you’ll see most often. It means “take in the rows from this operation as input, process them and pass them on”.\nInner\n: Only ever seen on the second child of join operations, and is always seen there. This is the “inner” part of the loop — for each outer row, we look up its match using this operation.\nMember\n: Used for all children of Append and ModifyTable nodes, and on bitmap processing nodes like BitmapAnd and BitmapOr operations.\nInitPlan\n: Used for calculations performed before the query can start, eg a constant referred to in the query or the result of a CTE scan.\nSubquery\n: The child is a subquery of the parent operation. Since Postgres always uses subquery scans to feed subquery data to parent queries, only ever appears on the children of subquery scans.\nSubPlan\n: Like a Subquery, represents a new query, but used when a subquery scan is not necessary.",
    "Parallel Aware":
      "Whether or not the operation will be run in a special mode to support parallelism. Some operations need to be aware that they are running in parallel, for example sequential scans need to know they only need to scan a smaller proportion of the table. Other operations can be run on several threads without each one having any knowledge of the others.",
    "Startup Cost":
      "The estimated cost of returning the first row.\nThis is in an arbitrary unit, with the aim of being correlated to the startup time.",
    "Total Cost":
      "The estimated cost of returning all rows. This is in an arbitrary unit, with the aim of being correlated to the total time.\nThe Postgres query planner often has several ways it could resolve the same query. It calculates costs — which are hopefully correlated with the time it would take — for potential plans, and then picks the one with the lowest cost. It’s worth bearing in mind that the costs are unit-free — they’re not designed to convert into time, or disk reads. They’re just supposed to be bigger for slower operations, and smaller for faster ones.\nIf the planner thinks it can finish early due to a parent Limit operation, the total cost of the Limit operation will reflect this, but the total cost of its child operations will not.",
    "Plan Rows":
      "The number of rows,\nper-loop\n, that the planner expects to be returned by the operation.\nPoor row estimates can lead to suboptimal query planning. They can often be improved by running\nANALYZE\n(not the EXPLAIN parameter), by increasing statistics, or by allowing Postgres to understand correlation between columns using multivariate statistics.\nIf the planner thinks it can finish early due to a Limit operation, the plan rows of the Limit operation will reflect this, but the plan rows of its child operations will not.",
    "Plan Width":
      "The\nestimated\naverage size of the rows produced by the operation, in\nbytes\n.",
    "Actual Startup Time":
      "The amount of time, in\nmilliseconds\n, it takes to get the first row out of the operation.\nSometimes, this is very close to the setup time — for example on a sequential scan which returns all the rows in a table.\nOther times, though, it’s more or less the total time. For example, in order to return the first row of a sort, you have to sort all of the rows to work out which one comes first.",
    "Actual Total Time":
      "The actual amount of time in milliseconds spent on this operation\nand all of its children\n. It’s a\nper-loop average\n, rounded to the nearest thousandth of a millisecond.\nWorking out individual operation timings, especially where CTEs and SubPlans are concerned, can be tricky. This is one of the main reasons we decided to build\npgMustard\n.",
    "Actual Rows":
      "The number of rows returned by the operation\nper loop\n.\nThe important thing to notice about this is that it’s an average of all the loops executed, rounded to the nearest integer. This means that while “Actual Loops” multiplied by “Actual Rows” is a pretty good approximation for total number of rows returned most of the time, it can be off by as much as half of the number of loops. Usually it’s just slightly confusing as you see a row or two appear or disappear between operations, but on operations with lots of loops there is potential for serious miscalculation.\nPoor row estimates, where Actual Rows differs substantially from Plan Rows, can lead to suboptimal query planning. Estimates can often be improved by running\nANALYZE\n(not the EXPLAIN parameter), by increasing statistics, or by allowing Postgres to understand correlation between columns using multivariate statistics.",
    "Actual Loops":
      "The number of times the operation is executed. For a lot of operations it will have a value of one, but when it is not, there are three different cases:\nSome operations can be executed more than once. For example, “Nested Loops” run their “Inner” child once for every row returned by their “Outer” child.\nWhen an operation that would normally only consist of one loop is split across multiple threads, each partial operation is counted as a Loop.\nThe number of loops can be zero when an operation doesn’t need to be executed at all. For example if a table read is planned to provide candidates for an inner join, but there turns out to be no rows on the other side of the join, the operation can be effectively eliminated.",
    Output:
      "A list of the columns returned by the operation.\nThis is only shown when VERBOSE is on.",
    "Shared Hit Blocks":
      "The number of blocks from indexes/tables that were found in the Postgres buffer cache.\nThis\nincludes\nvalues for child operations and is a\ntotal\nvalue (i.e. not a per-loop average).\nOnce you have subtracted child operation values, the proportion of shared hit to shared read blocks is an interesting measure of cache performance.\nThe ratio of shared blocks (hit plus read) to rows processed (including any filtered out) is also interesting: a high ratio means Postgres is reading a lot of data for what it is doing, which can be a sign of bloat.",
    "Shared Read Blocks":
      "The number of blocks from tables/indexes that were read from disk (or the OS cache).\nThis\nincludes\nvalues for child operations and is a\ntotal\nvalue (i.e. not per-loop).\nOnce you have subtracted child operation values, the proportion of shared hit to shared read blocks is an interesting measure of cache performance.\nThe ratio of shared blocks (hit plus read) to rows processed (including any filtered out) is also interesting: a high ratio means Postgres is reading a lot of data for what it is doing, which can be a sign of bloat.",
    "Shared Dirtied Blocks":
      "The number of blocks from tables/indexes that were modified by the operation.\nThis\nincludes\nvalues for child operations and is a\ntotal\nvalue (i.e. not per-loop).\nInterestingly, a SELECT query can report shared dirtied blocks when setting hint bits on recently-committed rows, or pruning old row versions. While somewhat surprising, both of these are perfectly normal and healthy.",
    "Shared Written Blocks":
      "The number of blocks from tables/indexes that were evicted from the cache.\nThis\nincludes\nvalues for child operations and is a\ntotal\nvalue (i.e. not a per-loop average).",
    "Local Hit Blocks":
      "The number of blocks from temporary tables and indexes that were found in the cache.\nThis\nincludes\nvalues for child operations and is a\ntotal\nvalue (not a per-loop average).",
    "Local Read Blocks":
      "The number of blocks read from\ntemporary tables and indexes that were not found in the Postgres cache (read from disk or the OS cache).\nThis\nincludes\nvalues for child operations and is a\ntotal\nvalue (not a per-loop average).",
    "Local Dirtied Blocks":
      "The number of blocks from\ntemporary tables and indexes that have been modified by the operation.\nThis\nincludes\nvalues for child operations and is a\ntotal\nvalue (i.e. not a per-loop average).",
    "Local Written Blocks":
      "The number of blocks from\ntemporary tables and indexes that were evicted from the cache.\nThis\nincludes\nvalues for child operations and is a\ntotal\nvalue (i.e. not a per-loop average).",
    "Temp Read Blocks":
      "The number of blocks read from short-term data used to calculate hashes, sorts, Materialize operations, and similar.\nThis\nincludes\nvalues for child operations and is a\ntotal\nvalue (i.e. not a per-loop average).\nYour settings of\nwork_mem\nand\nhash_mem_multiplier\ndetermine how much memory is available to Postgres per operation.",
    "Temp Written Blocks":
      "The number of blocks from short-term data (used to calculate operations like hashes, sorts, and materializes) that were evicted from the cache.\nThis\nincludes\nvalues for child operations and is a\ntotal\nvalue (i.e. not a per-loop average).\nYour settings of\nwork_mem\nand\nhash_mem_multiplier\ndetermine how much memory is available to Postgres per operation.",
    "Shared I/O Read Time":
      "The time spent reading data from tables and indexes, in\nmilliseconds\n.\nThis\nincludes\nvalues for child operations and is a total value (not a per-loop average).\nRequires\ntrack_io_timing\nand\nBUFFERS\nto be on.\nIn the latest version, the text format of explain displays this as\nI/O Timings: shared read\nIn PostgreSQL 15 and 16 it shows as a combined metric\nI/O Timings: shared/local read\nGetting timing information has an overhead, due to checking the system clock. You can use\npg_test_timing\nto measure this for your system.",
    "Shared I/O Write Time":
      "The time spent writing data for tables and indexes, in\nmilliseconds\n.\nThis\nincludes\nvalues for child operations and is a total value (not a per-loop average).\nRequires\ntrack_io_timing\nand\nBUFFERS\nto be on.\nIn the latest version, the text format of explain displays this as\nI/O Timings: shared write\nIn PostgreSQL 15 and 16 it shows as a combined metric\nI/O Timings: shared/local write\nGetting timing information has an overhead, due to checking the system clock. You can use\npg_test_timing\nto measure this for your system.",
    "Local I/O Read Time":
      "The time spent reading local data (e.g. from temporary tables and indexes), in\nmilliseconds\n.\nThis\nincludes\nvalues for child operations and is a total value (i.e. not a per-loop average).\nThis was added as a separate field in PostgreSQL 17, and requires both\ntrack_io_timing\nand\nBUFFERS\n.\nIn the default text format, this will show as\nI/O Timings: local read\nIn versions 15 and 16 it is available as a combined metric as\nshared/local\nGetting timing information has an overhead, due to checking the system clock. You can use\npg_test_timing\nto measure this for your system.",
    "Local I/O Write Time":
      "The time spent writing local data (e.g. for temporary tables and indexes), in\nmilliseconds\n.\nThis\nincludes\nvalues for child operations and is a total value (i.e. not a per-loop average).\nThis was added as a separate field in PostgreSQL 17, and requires both\ntrack_io_timing\nand\nBUFFERS\n.\nIn the default text format, this will show as\nI/O Timings: local write\nIn versions 15 and 16 it is available as a combined metric as\nshared/local\nGetting timing information has an overhead, due to checking the system clock. You can use\npg_test_timing\nto measure this for your system.",
    "Temp I/O Read Time":
      "The time spent reading short-term data, in\nmilliseconds\n(for example during sort and hash operations that were not done in memory).\nThis\nincludes\nvalues for child operations and is a total value (i.e. not a per-loop average).\nThis was added in PostgreSQL 15, and requires both\ntrack_io_timing\nand\nBUFFERS\n.\nIn the text format of explain, this shows as\nI/O Timings: temp read\nGetting timing information has an overhead, due to checking the system clock. You can use\npg_test_timing\nto measure this for your system.",
    "Temp I/O Write Time":
      "The time spent writing short-term data, in\nmilliseconds\n(for example during sort and hash operations that were not done in memory).\nThis\nincludes\nvalues for child operations and is a total value (i.e. not a per-loop average).\nThis was added in PostgreSQL 15, and requires both\ntrack_io_timing\nand\nBUFFERS\n.\nIn the text format of explain, this shows as\nI/O Timings: temp write\nGetting timing information has an overhead, due to checking the system clock. You can use\npg_test_timing\nto measure this for your system.",
  },
  "WorkTable Scan": {
    "Parent Relationship":
      "A guide as to why this operation needs to be run in order to facilitate the parent operation. There are six different possibilities:\nOuter\n: The value you’ll see most often. It means “take in the rows from this operation as input, process them and pass them on”.\nInner\n: Only ever seen on the second child of join operations, and is always seen there. This is the “inner” part of the loop — for each outer row, we look up its match using this operation.\nMember\n: Used for all children of Append and ModifyTable nodes, and on bitmap processing nodes like BitmapAnd and BitmapOr operations.\nInitPlan\n: Used for calculations performed before the query can start, eg a constant referred to in the query or the result of a CTE scan.\nSubquery\n: The child is a subquery of the parent operation. Since Postgres always uses subquery scans to feed subquery data to parent queries, only ever appears on the children of subquery scans.\nSubPlan\n: Like a Subquery, represents a new query, but used when a subquery scan is not necessary.",
    "Parallel Aware":
      "Whether or not the operation will be run in a special mode to support parallelism. Some operations need to be aware that they are running in parallel, for example sequential scans need to know they only need to scan a smaller proportion of the table. Other operations can be run on several threads without each one having any knowledge of the others.",
    Alias: "The alias used to refer to the Relation Name object.",
    "Startup Cost":
      "The estimated cost of returning the first row.\nThis is in an arbitrary unit, with the aim of being correlated to the startup time.",
    "Total Cost":
      "The estimated cost of returning all rows. This is in an arbitrary unit, with the aim of being correlated to the total time.\nThe Postgres query planner often has several ways it could resolve the same query. It calculates costs — which are hopefully correlated with the time it would take — for potential plans, and then picks the one with the lowest cost. It’s worth bearing in mind that the costs are unit-free — they’re not designed to convert into time, or disk reads. They’re just supposed to be bigger for slower operations, and smaller for faster ones.\nIf the planner thinks it can finish early due to a parent Limit operation, the total cost of the Limit operation will reflect this, but the total cost of its child operations will not.",
    "Plan Rows":
      "The number of rows,\nper-loop\n, that the planner expects to be returned by the operation.\nPoor row estimates can lead to suboptimal query planning. They can often be improved by running\nANALYZE\n(not the EXPLAIN parameter), by increasing statistics, or by allowing Postgres to understand correlation between columns using multivariate statistics.\nIf the planner thinks it can finish early due to a Limit operation, the plan rows of the Limit operation will reflect this, but the plan rows of its child operations will not.",
    "Plan Width":
      "The\nestimated\naverage size of the rows produced by the operation, in\nbytes\n.",
    "Actual Startup Time":
      "The amount of time, in\nmilliseconds\n, it takes to get the first row out of the operation.\nSometimes, this is very close to the setup time — for example on a sequential scan which returns all the rows in a table.\nOther times, though, it’s more or less the total time. For example, in order to return the first row of a sort, you have to sort all of the rows to work out which one comes first.",
    "Actual Total Time":
      "The actual amount of time in milliseconds spent on this operation\nand all of its children\n. It’s a\nper-loop average\n, rounded to the nearest thousandth of a millisecond.\nWorking out individual operation timings, especially where CTEs and SubPlans are concerned, can be tricky. This is one of the main reasons we decided to build\npgMustard\n.",
    "Actual Rows":
      "The number of rows returned by the operation\nper loop\n.\nThe important thing to notice about this is that it’s an average of all the loops executed, rounded to the nearest integer. This means that while “Actual Loops” multiplied by “Actual Rows” is a pretty good approximation for total number of rows returned most of the time, it can be off by as much as half of the number of loops. Usually it’s just slightly confusing as you see a row or two appear or disappear between operations, but on operations with lots of loops there is potential for serious miscalculation.\nPoor row estimates, where Actual Rows differs substantially from Plan Rows, can lead to suboptimal query planning. Estimates can often be improved by running\nANALYZE\n(not the EXPLAIN parameter), by increasing statistics, or by allowing Postgres to understand correlation between columns using multivariate statistics.",
    "Actual Loops":
      "The number of times the operation is executed. For a lot of operations it will have a value of one, but when it is not, there are three different cases:\nSome operations can be executed more than once. For example, “Nested Loops” run their “Inner” child once for every row returned by their “Outer” child.\nWhen an operation that would normally only consist of one loop is split across multiple threads, each partial operation is counted as a Loop.\nThe number of loops can be zero when an operation doesn’t need to be executed at all. For example if a table read is planned to provide candidates for an inner join, but there turns out to be no rows on the other side of the join, the operation can be effectively eliminated.",
    Output:
      "A list of the columns returned by the operation.\nThis is only shown when VERBOSE is on.",
    Filter:
      "When present, this is a filter used to remove rows.\nThe important thing to note is that this is a filter in the traditional sense: these rows are read in (either from a data source or another operation in the plan), inspected, and then approved or removed based on the filter.\nIf a high proportion of rows are being removed by the Filter, you may want to investigate whether a (more) selective index could help.\nIf you notice a lot of rows being filtered late in a query plan, this might be due to an operation (like a GROUP BY or SORT) using more columns than are necessary, requiring joins to take place before rows can be discarded. It is also sometimes a result of unnecessary or ill-advised uses of DISTINCT.",
    "Rows Removed by Filter":
      "The number of rows removed by the\nFilter\n. This is a\nper-loop average\n, rounded to the nearest integer.\nIf a high proportion of rows are being removed, you may want to investigate whether a (more) selective index could help.",
    "Shared Hit Blocks":
      "The number of blocks from indexes/tables that were found in the Postgres buffer cache.\nThis\nincludes\nvalues for child operations and is a\ntotal\nvalue (i.e. not a per-loop average).\nOnce you have subtracted child operation values, the proportion of shared hit to shared read blocks is an interesting measure of cache performance.\nThe ratio of shared blocks (hit plus read) to rows processed (including any filtered out) is also interesting: a high ratio means Postgres is reading a lot of data for what it is doing, which can be a sign of bloat.",
    "Shared Read Blocks":
      "The number of blocks from tables/indexes that were read from disk (or the OS cache).\nThis\nincludes\nvalues for child operations and is a\ntotal\nvalue (i.e. not per-loop).\nOnce you have subtracted child operation values, the proportion of shared hit to shared read blocks is an interesting measure of cache performance.\nThe ratio of shared blocks (hit plus read) to rows processed (including any filtered out) is also interesting: a high ratio means Postgres is reading a lot of data for what it is doing, which can be a sign of bloat.",
    "Shared Dirtied Blocks":
      "The number of blocks from tables/indexes that were modified by the operation.\nThis\nincludes\nvalues for child operations and is a\ntotal\nvalue (i.e. not per-loop).\nInterestingly, a SELECT query can report shared dirtied blocks when setting hint bits on recently-committed rows, or pruning old row versions. While somewhat surprising, both of these are perfectly normal and healthy.",
    "Shared Written Blocks":
      "The number of blocks from tables/indexes that were evicted from the cache.\nThis\nincludes\nvalues for child operations and is a\ntotal\nvalue (i.e. not a per-loop average).",
    "Local Hit Blocks":
      "The number of blocks from temporary tables and indexes that were found in the cache.\nThis\nincludes\nvalues for child operations and is a\ntotal\nvalue (not a per-loop average).",
    "Local Read Blocks":
      "The number of blocks read from\ntemporary tables and indexes that were not found in the Postgres cache (read from disk or the OS cache).\nThis\nincludes\nvalues for child operations and is a\ntotal\nvalue (not a per-loop average).",
    "Local Dirtied Blocks":
      "The number of blocks from\ntemporary tables and indexes that have been modified by the operation.\nThis\nincludes\nvalues for child operations and is a\ntotal\nvalue (i.e. not a per-loop average).",
    "Local Written Blocks":
      "The number of blocks from\ntemporary tables and indexes that were evicted from the cache.\nThis\nincludes\nvalues for child operations and is a\ntotal\nvalue (i.e. not a per-loop average).",
    "Temp Read Blocks":
      "The number of blocks read from short-term data used to calculate hashes, sorts, Materialize operations, and similar.\nThis\nincludes\nvalues for child operations and is a\ntotal\nvalue (i.e. not a per-loop average).\nYour settings of\nwork_mem\nand\nhash_mem_multiplier\ndetermine how much memory is available to Postgres per operation.",
    "Temp Written Blocks":
      "The number of blocks from short-term data (used to calculate operations like hashes, sorts, and materializes) that were evicted from the cache.\nThis\nincludes\nvalues for child operations and is a\ntotal\nvalue (i.e. not a per-loop average).\nYour settings of\nwork_mem\nand\nhash_mem_multiplier\ndetermine how much memory is available to Postgres per operation.",
    "Shared I/O Read Time":
      "The time spent reading data from tables and indexes, in\nmilliseconds\n.\nThis\nincludes\nvalues for child operations and is a total value (not a per-loop average).\nRequires\ntrack_io_timing\nand\nBUFFERS\nto be on.\nIn the latest version, the text format of explain displays this as\nI/O Timings: shared read\nIn PostgreSQL 15 and 16 it shows as a combined metric\nI/O Timings: shared/local read\nGetting timing information has an overhead, due to checking the system clock. You can use\npg_test_timing\nto measure this for your system.",
    "Shared I/O Write Time":
      "The time spent writing data for tables and indexes, in\nmilliseconds\n.\nThis\nincludes\nvalues for child operations and is a total value (not a per-loop average).\nRequires\ntrack_io_timing\nand\nBUFFERS\nto be on.\nIn the latest version, the text format of explain displays this as\nI/O Timings: shared write\nIn PostgreSQL 15 and 16 it shows as a combined metric\nI/O Timings: shared/local write\nGetting timing information has an overhead, due to checking the system clock. You can use\npg_test_timing\nto measure this for your system.",
    "Local I/O Read Time":
      "The time spent reading local data (e.g. from temporary tables and indexes), in\nmilliseconds\n.\nThis\nincludes\nvalues for child operations and is a total value (i.e. not a per-loop average).\nThis was added as a separate field in PostgreSQL 17, and requires both\ntrack_io_timing\nand\nBUFFERS\n.\nIn the default text format, this will show as\nI/O Timings: local read\nIn versions 15 and 16 it is available as a combined metric as\nshared/local\nGetting timing information has an overhead, due to checking the system clock. You can use\npg_test_timing\nto measure this for your system.",
    "Local I/O Write Time":
      "The time spent writing local data (e.g. for temporary tables and indexes), in\nmilliseconds\n.\nThis\nincludes\nvalues for child operations and is a total value (i.e. not a per-loop average).\nThis was added as a separate field in PostgreSQL 17, and requires both\ntrack_io_timing\nand\nBUFFERS\n.\nIn the default text format, this will show as\nI/O Timings: local write\nIn versions 15 and 16 it is available as a combined metric as\nshared/local\nGetting timing information has an overhead, due to checking the system clock. You can use\npg_test_timing\nto measure this for your system.",
    "Temp I/O Read Time":
      "The time spent reading short-term data, in\nmilliseconds\n(for example during sort and hash operations that were not done in memory).\nThis\nincludes\nvalues for child operations and is a total value (i.e. not a per-loop average).\nThis was added in PostgreSQL 15, and requires both\ntrack_io_timing\nand\nBUFFERS\n.\nIn the text format of explain, this shows as\nI/O Timings: temp read\nGetting timing information has an overhead, due to checking the system clock. You can use\npg_test_timing\nto measure this for your system.",
    "Temp I/O Write Time":
      "The time spent writing short-term data, in\nmilliseconds\n(for example during sort and hash operations that were not done in memory).\nThis\nincludes\nvalues for child operations and is a total value (i.e. not a per-loop average).\nThis was added in PostgreSQL 15, and requires both\ntrack_io_timing\nand\nBUFFERS\n.\nIn the text format of explain, this shows as\nI/O Timings: temp write\nGetting timing information has an overhead, due to checking the system clock. You can use\npg_test_timing\nto measure this for your system.",
  },
};
